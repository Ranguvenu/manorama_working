import {
  ShiftEnter
} from "./chunk-YPEUAVWJ.js";
import "./chunk-NICE7ARI.js";
import {
  UpcastWriter
} from "./chunk-X5QTGNDD.js";
import "./chunk-U5S3T6FN.js";
import {
  Model,
  SplitButtonView,
  addListToDropdown,
  createDropdown
} from "./chunk-2UXKTWKP.js";
import "./chunk-GJCFV3G2.js";
import {
  Collection,
  first
} from "./chunk-MFEZX3FO.js";
import {
  Command,
  Plugin,
  icons
} from "./chunk-YB4X7RFQ.js";
import "./chunk-VMNDBVXW.js";
import "./chunk-LQD6FQVM.js";
import "./chunk-ROME4SDB.js";

// node_modules/@ckeditor/ckeditor5-code-block/src/utils.js
function getNormalizedAndLocalizedLanguageDefinitions(editor) {
  const t = editor.t;
  const languageDefs = editor.config.get("codeBlock.languages");
  for (const def of languageDefs) {
    if (def.label === "Plain text") {
      def.label = t("Plain text");
    }
    if (def.class === void 0) {
      def.class = `language-${def.language}`;
    }
  }
  return languageDefs;
}
function getPropertyAssociation(languageDefs, key, value) {
  const association = {};
  for (const def of languageDefs) {
    if (key === "class") {
      const newKey = def[key].split(" ").shift();
      association[newKey] = def[value];
    } else {
      association[def[key]] = def[value];
    }
  }
  return association;
}
function getLeadingWhiteSpaces(textNode) {
  return textNode.data.match(/^(\s*)/)[0];
}
function rawSnippetTextToViewDocumentFragment(writer, text) {
  const fragment = writer.createDocumentFragment();
  const textLines = text.split("\n");
  const items = textLines.reduce((nodes, line, lineIndex) => {
    nodes.push(line);
    if (lineIndex < textLines.length - 1) {
      nodes.push(writer.createElement("br"));
    }
    return nodes;
  }, []);
  writer.appendChild(items, fragment);
  return fragment;
}
function getIndentOutdentPositions(model) {
  const selection = model.document.selection;
  const positions = [];
  if (selection.isCollapsed) {
    return [selection.anchor];
  }
  const walker = selection.getFirstRange().getWalker({
    ignoreElementEnd: true,
    direction: "backward"
  });
  for (const { item } of walker) {
    if (!item.is("$textProxy")) {
      continue;
    }
    const { parent, startOffset } = item.textNode;
    if (!parent.is("element", "codeBlock")) {
      continue;
    }
    const leadingWhiteSpaces = getLeadingWhiteSpaces(item.textNode);
    const position = model.createPositionAt(parent, startOffset + leadingWhiteSpaces.length);
    positions.push(position);
  }
  return positions;
}
function isModelSelectionInCodeBlock(selection) {
  const firstBlock = first(selection.getSelectedBlocks());
  return !!firstBlock && firstBlock.is("element", "codeBlock");
}
function canBeCodeBlock(schema, element) {
  if (element.is("rootElement") || schema.isLimit(element)) {
    return false;
  }
  return schema.checkChild(element.parent, "codeBlock");
}

// node_modules/@ckeditor/ckeditor5-code-block/src/codeblockcommand.js
var CodeBlockCommand = class extends Command {
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    this._lastLanguage = null;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    this.value = this._getValue();
    this.isEnabled = this._checkEnabled();
  }
  /**
   * Executes the command. When the command {@link #value is on}, all topmost code blocks within
   * the selection will be removed. If it is off, all selected blocks will be flattened and
   * wrapped by a code block.
   *
   * @fires execute
   * @param options Command options.
   * @param options.language The code block language.
   * @param options.forceValue If set, it will force the command behavior. If `true`, the command will apply a code block,
   * otherwise the command will remove the code block. If not set, the command will act basing on its current value.
   * @param options.usePreviousLanguageChoice If set on `true` and the `options.language` is not specified, the command
   * will apply the previous language (if the command was already executed) when inserting the `codeBlock` element.
   */
  execute(options = {}) {
    const editor = this.editor;
    const model = editor.model;
    const selection = model.document.selection;
    const normalizedLanguagesDefs = getNormalizedAndLocalizedLanguageDefinitions(editor);
    const firstLanguageInConfig = normalizedLanguagesDefs[0];
    const blocks = Array.from(selection.getSelectedBlocks());
    const value = options.forceValue == void 0 ? !this.value : options.forceValue;
    const language = getLanguage(options, this._lastLanguage, firstLanguageInConfig.language);
    model.change((writer) => {
      if (value) {
        this._applyCodeBlock(writer, blocks, language);
      } else {
        this._removeCodeBlock(writer, blocks);
      }
    });
  }
  /**
   * Checks the command's {@link #value}.
   *
   * @returns The current value.
   */
  _getValue() {
    const selection = this.editor.model.document.selection;
    const firstBlock = first(selection.getSelectedBlocks());
    const isCodeBlock = !!(firstBlock && firstBlock.is("element", "codeBlock"));
    return isCodeBlock ? firstBlock.getAttribute("language") : false;
  }
  /**
   * Checks whether the command can be enabled in the current context.
   *
   * @returns Whether the command should be enabled.
   */
  _checkEnabled() {
    if (this.value) {
      return true;
    }
    const selection = this.editor.model.document.selection;
    const schema = this.editor.model.schema;
    const firstBlock = first(selection.getSelectedBlocks());
    if (!firstBlock) {
      return false;
    }
    return canBeCodeBlock(schema, firstBlock);
  }
  _applyCodeBlock(writer, blocks, language) {
    this._lastLanguage = language;
    const schema = this.editor.model.schema;
    const allowedBlocks = blocks.filter((block) => canBeCodeBlock(schema, block));
    for (const block of allowedBlocks) {
      writer.rename(block, "codeBlock");
      writer.setAttribute("language", language, block);
      schema.removeDisallowedAttributes([block], writer);
      Array.from(block.getChildren()).filter((child) => !schema.checkChild(block, child)).forEach((child) => writer.remove(child));
    }
    allowedBlocks.reverse().forEach((currentBlock, i) => {
      const nextBlock = allowedBlocks[i + 1];
      if (currentBlock.previousSibling === nextBlock) {
        writer.appendElement("softBreak", nextBlock);
        writer.merge(writer.createPositionBefore(currentBlock));
      }
    });
  }
  _removeCodeBlock(writer, blocks) {
    const codeBlocks = blocks.filter((block) => block.is("element", "codeBlock"));
    for (const block of codeBlocks) {
      const range = writer.createRangeOn(block);
      for (const item of Array.from(range.getItems()).reverse()) {
        if (item.is("element", "softBreak") && item.parent.is("element", "codeBlock")) {
          const { position } = writer.split(writer.createPositionBefore(item));
          const elementAfter = position.nodeAfter;
          writer.rename(elementAfter, "paragraph");
          writer.removeAttribute("language", elementAfter);
          writer.remove(item);
        }
      }
      writer.rename(block, "paragraph");
      writer.removeAttribute("language", block);
    }
  }
};
function getLanguage(options, lastLanguage, defaultLanguage) {
  if (options.language) {
    return options.language;
  }
  if (options.usePreviousLanguageChoice && lastLanguage) {
    return lastLanguage;
  }
  return defaultLanguage;
}

// node_modules/@ckeditor/ckeditor5-code-block/src/indentcodeblockcommand.js
var IndentCodeBlockCommand = class extends Command {
  constructor(editor) {
    super(editor);
    this._indentSequence = editor.config.get("codeBlock.indentSequence");
  }
  /**
   * @inheritDoc
   */
  refresh() {
    this.isEnabled = this._checkEnabled();
  }
  /**
   * Executes the command. When the command {@link #isEnabled is enabled}, the indentation of the
   * code lines in the selection will be increased.
   *
   * @fires execute
   */
  execute() {
    const editor = this.editor;
    const model = editor.model;
    model.change((writer) => {
      const positions = getIndentOutdentPositions(model);
      for (const position of positions) {
        const indentSequenceTextElement = writer.createText(this._indentSequence);
        model.insertContent(indentSequenceTextElement, position);
      }
    });
  }
  /**
   * Checks whether the command can be enabled in the current context.
   */
  _checkEnabled() {
    if (!this._indentSequence) {
      return false;
    }
    return isModelSelectionInCodeBlock(this.editor.model.document.selection);
  }
};

// node_modules/@ckeditor/ckeditor5-code-block/src/outdentcodeblockcommand.js
var OutdentCodeBlockCommand = class extends Command {
  constructor(editor) {
    super(editor);
    this._indentSequence = editor.config.get("codeBlock.indentSequence");
  }
  /**
   * @inheritDoc
   */
  refresh() {
    this.isEnabled = this._checkEnabled();
  }
  /**
   * Executes the command. When the command {@link #isEnabled is enabled}, the indentation of the
   * code lines in the selection will be decreased.
   *
   * @fires execute
   */
  execute() {
    const editor = this.editor;
    const model = editor.model;
    model.change(() => {
      const positions = getIndentOutdentPositions(model);
      for (const position of positions) {
        const range = getLastOutdentableSequenceRange(model, position, this._indentSequence);
        if (range) {
          model.deleteContent(model.createSelection(range));
        }
      }
    });
  }
  /**
   * Checks whether the command can be enabled in the current context.
   *
   * @private
   * @returns {Boolean} Whether the command should be enabled.
   */
  _checkEnabled() {
    if (!this._indentSequence) {
      return false;
    }
    const model = this.editor.model;
    if (!isModelSelectionInCodeBlock(model.document.selection)) {
      return false;
    }
    return getIndentOutdentPositions(model).some((position) => {
      return getLastOutdentableSequenceRange(model, position, this._indentSequence);
    });
  }
};
function getLastOutdentableSequenceRange(model, position, sequence) {
  const nodeAtPosition = getCodeLineTextNodeAtPosition(position);
  if (!nodeAtPosition) {
    return null;
  }
  const leadingWhiteSpaces = getLeadingWhiteSpaces(nodeAtPosition);
  const lastIndexOfSequence = leadingWhiteSpaces.lastIndexOf(sequence);
  if (lastIndexOfSequence + sequence.length !== leadingWhiteSpaces.length) {
    return null;
  }
  if (lastIndexOfSequence === -1) {
    return null;
  }
  const { parent, startOffset } = nodeAtPosition;
  return model.createRange(model.createPositionAt(parent, startOffset + lastIndexOfSequence), model.createPositionAt(parent, startOffset + lastIndexOfSequence + sequence.length));
}
function getCodeLineTextNodeAtPosition(position) {
  let nodeAtPosition = position.parent.getChild(position.index);
  if (!nodeAtPosition || nodeAtPosition.is("element", "softBreak")) {
    nodeAtPosition = position.nodeBefore;
  }
  if (!nodeAtPosition || nodeAtPosition.is("element", "softBreak")) {
    return null;
  }
  return nodeAtPosition;
}

// node_modules/@ckeditor/ckeditor5-code-block/src/converters.js
function modelToViewCodeBlockInsertion(model, languageDefs, useLabels = false) {
  const languagesToClasses = getPropertyAssociation(languageDefs, "language", "class");
  const languagesToLabels = getPropertyAssociation(languageDefs, "language", "label");
  return (evt, data, conversionApi) => {
    const { writer, mapper, consumable } = conversionApi;
    if (!consumable.consume(data.item, "insert")) {
      return;
    }
    const codeBlockLanguage = data.item.getAttribute("language");
    const targetViewPosition = mapper.toViewPosition(model.createPositionBefore(data.item));
    const preAttributes = {};
    if (useLabels) {
      preAttributes["data-language"] = languagesToLabels[codeBlockLanguage];
      preAttributes.spellcheck = "false";
    }
    const codeAttributes = languagesToClasses[codeBlockLanguage] ? {
      class: languagesToClasses[codeBlockLanguage]
    } : void 0;
    const code = writer.createContainerElement("code", codeAttributes);
    const pre = writer.createContainerElement("pre", preAttributes, code);
    writer.insert(targetViewPosition, pre);
    mapper.bindElements(data.item, code);
  };
}
function modelToDataViewSoftBreakInsertion(model) {
  return (evt, data, conversionApi) => {
    if (data.item.parent.name !== "codeBlock") {
      return;
    }
    const { writer, mapper, consumable } = conversionApi;
    if (!consumable.consume(data.item, "insert")) {
      return;
    }
    const position = mapper.toViewPosition(model.createPositionBefore(data.item));
    writer.insert(position, writer.createText("\n"));
  };
}
function dataViewToModelCodeBlockInsertion(editingView, languageDefs) {
  const classesToLanguages = getPropertyAssociation(languageDefs, "class", "language");
  const defaultLanguageName = languageDefs[0].language;
  return (evt, data, conversionApi) => {
    const viewCodeElement = data.viewItem;
    const viewPreElement = viewCodeElement.parent;
    if (!viewPreElement || !viewPreElement.is("element", "pre")) {
      return;
    }
    if (data.modelCursor.findAncestor("codeBlock")) {
      return;
    }
    const { consumable, writer } = conversionApi;
    if (!consumable.test(viewCodeElement, { name: true })) {
      return;
    }
    const codeBlock = writer.createElement("codeBlock");
    const viewChildClasses = [...viewCodeElement.getClassNames()];
    if (!viewChildClasses.length) {
      viewChildClasses.push("");
    }
    for (const className of viewChildClasses) {
      const language = classesToLanguages[className];
      if (language) {
        writer.setAttribute("language", language, codeBlock);
        break;
      }
    }
    if (!codeBlock.hasAttribute("language")) {
      writer.setAttribute("language", defaultLanguageName, codeBlock);
    }
    conversionApi.convertChildren(viewCodeElement, codeBlock);
    if (!conversionApi.safeInsert(codeBlock, data.modelCursor)) {
      return;
    }
    consumable.consume(viewCodeElement, { name: true });
    conversionApi.updateConversionResult(codeBlock, data);
  };
}
function dataViewToModelTextNewlinesInsertion() {
  return (evt, data, { consumable, writer }) => {
    let position = data.modelCursor;
    if (!consumable.test(data.viewItem)) {
      return;
    }
    if (!position.findAncestor("codeBlock")) {
      return;
    }
    consumable.consume(data.viewItem);
    const text = data.viewItem.data;
    const textLines = text.split("\n").map((data2) => writer.createText(data2));
    const lastLine = textLines[textLines.length - 1];
    for (const node of textLines) {
      writer.insert(node, position);
      position = position.getShiftedBy(node.offsetSize);
      if (node !== lastLine) {
        const softBreak = writer.createElement("softBreak");
        writer.insert(softBreak, position);
        position = writer.createPositionAfter(softBreak);
      }
    }
    data.modelRange = writer.createRange(data.modelCursor, position);
    data.modelCursor = position;
  };
}
function dataViewToModelOrphanNodeConsumer() {
  return (evt, data, { consumable }) => {
    const preElement = data.viewItem;
    if (preElement.findAncestor("pre")) {
      return;
    }
    const preChildren = Array.from(preElement.getChildren());
    const childCodeElement = preChildren.find((node) => node.is("element", "code"));
    if (!childCodeElement) {
      return;
    }
    for (const child of preChildren) {
      if (child === childCodeElement || !child.is("$text")) {
        continue;
      }
      consumable.consume(child, { name: true });
    }
  };
}

// node_modules/@ckeditor/ckeditor5-code-block/src/codeblockediting.js
var DEFAULT_ELEMENT = "paragraph";
var CodeBlockEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "CodeBlockEditing";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ShiftEnter];
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    editor.config.define("codeBlock", {
      languages: [
        { language: "plaintext", label: "Plain text" },
        { language: "c", label: "C" },
        { language: "cs", label: "C#" },
        { language: "cpp", label: "C++" },
        { language: "css", label: "CSS" },
        { language: "diff", label: "Diff" },
        { language: "html", label: "HTML" },
        { language: "java", label: "Java" },
        { language: "javascript", label: "JavaScript" },
        { language: "php", label: "PHP" },
        { language: "python", label: "Python" },
        { language: "ruby", label: "Ruby" },
        { language: "typescript", label: "TypeScript" },
        { language: "xml", label: "XML" }
      ],
      // A single tab.
      indentSequence: "	"
    });
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const schema = editor.model.schema;
    const model = editor.model;
    const view = editor.editing.view;
    const listEditing = editor.plugins.has("ListEditing") ? editor.plugins.get("ListEditing") : null;
    const normalizedLanguagesDefs = getNormalizedAndLocalizedLanguageDefinitions(editor);
    editor.commands.add("codeBlock", new CodeBlockCommand(editor));
    editor.commands.add("indentCodeBlock", new IndentCodeBlockCommand(editor));
    editor.commands.add("outdentCodeBlock", new OutdentCodeBlockCommand(editor));
    this.listenTo(view.document, "tab", (evt, data) => {
      const commandName = data.shiftKey ? "outdentCodeBlock" : "indentCodeBlock";
      const command = editor.commands.get(commandName);
      if (!command.isEnabled) {
        return;
      }
      editor.execute(commandName);
      data.stopPropagation();
      data.preventDefault();
      evt.stop();
    }, { context: "pre" });
    schema.register("codeBlock", {
      allowWhere: "$block",
      allowChildren: "$text",
      isBlock: true,
      allowAttributes: ["language"]
    });
    schema.addAttributeCheck((context, attributeName) => {
      if (context.endsWith("codeBlock") && listEditing && listEditing.getListAttributeNames().includes(attributeName)) {
        return true;
      }
      if (context.endsWith("codeBlock $text")) {
        return false;
      }
    });
    editor.model.schema.addChildCheck((context, childDefinition) => {
      if (context.endsWith("codeBlock") && childDefinition.isObject) {
        return false;
      }
    });
    editor.editing.downcastDispatcher.on("insert:codeBlock", modelToViewCodeBlockInsertion(model, normalizedLanguagesDefs, true));
    editor.data.downcastDispatcher.on("insert:codeBlock", modelToViewCodeBlockInsertion(model, normalizedLanguagesDefs));
    editor.data.downcastDispatcher.on("insert:softBreak", modelToDataViewSoftBreakInsertion(model), { priority: "high" });
    editor.data.upcastDispatcher.on("element:code", dataViewToModelCodeBlockInsertion(view, normalizedLanguagesDefs));
    editor.data.upcastDispatcher.on("text", dataViewToModelTextNewlinesInsertion());
    editor.data.upcastDispatcher.on("element:pre", dataViewToModelOrphanNodeConsumer(), { priority: "high" });
    this.listenTo(editor.editing.view.document, "clipboardInput", (evt, data) => {
      let insertionRange = model.createRange(model.document.selection.anchor);
      if (data.targetRanges) {
        insertionRange = editor.editing.mapper.toModelRange(data.targetRanges[0]);
      }
      if (!insertionRange.start.parent.is("element", "codeBlock")) {
        return;
      }
      const text = data.dataTransfer.getData("text/plain");
      const writer = new UpcastWriter(editor.editing.view.document);
      data.content = rawSnippetTextToViewDocumentFragment(writer, text);
    });
    this.listenTo(model, "getSelectedContent", (evt, [selection]) => {
      const anchor = selection.anchor;
      if (selection.isCollapsed || !anchor.parent.is("element", "codeBlock") || !anchor.hasSameParentAs(selection.focus)) {
        return;
      }
      model.change((writer) => {
        const docFragment = evt.return;
        if (anchor.parent.is("element") && (docFragment.childCount > 1 || selection.containsEntireContent(anchor.parent))) {
          const codeBlock = writer.createElement("codeBlock", anchor.parent.getAttributes());
          writer.append(docFragment, codeBlock);
          const newDocumentFragment = writer.createDocumentFragment();
          writer.append(codeBlock, newDocumentFragment);
          evt.return = newDocumentFragment;
          return;
        }
        const textNode = docFragment.getChild(0);
        if (schema.checkAttribute(textNode, "code")) {
          writer.setAttribute("code", true, textNode);
        }
      });
    });
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    const editor = this.editor;
    const commands = editor.commands;
    const indent = commands.get("indent");
    const outdent = commands.get("outdent");
    if (indent) {
      indent.registerChildCommand(commands.get("indentCodeBlock"), { priority: "highest" });
    }
    if (outdent) {
      outdent.registerChildCommand(commands.get("outdentCodeBlock"));
    }
    this.listenTo(editor.editing.view.document, "enter", (evt, data) => {
      const positionParent = editor.model.document.selection.getLastPosition().parent;
      if (!positionParent.is("element", "codeBlock")) {
        return;
      }
      if (!leaveBlockStartOnEnter(editor, data.isSoft) && !leaveBlockEndOnEnter(editor, data.isSoft)) {
        breakLineOnEnter(editor);
      }
      data.preventDefault();
      evt.stop();
    }, { context: "pre" });
  }
};
function breakLineOnEnter(editor) {
  const model = editor.model;
  const modelDoc = model.document;
  const lastSelectionPosition = modelDoc.selection.getLastPosition();
  const node = lastSelectionPosition.nodeBefore || lastSelectionPosition.textNode;
  let leadingWhiteSpaces;
  if (node && node.is("$text")) {
    leadingWhiteSpaces = getLeadingWhiteSpaces(node);
  }
  editor.model.change((writer) => {
    editor.execute("shiftEnter");
    if (leadingWhiteSpaces) {
      writer.insertText(leadingWhiteSpaces, modelDoc.selection.anchor);
    }
  });
}
function leaveBlockStartOnEnter(editor, isSoftEnter) {
  const model = editor.model;
  const modelDoc = model.document;
  const view = editor.editing.view;
  const lastSelectionPosition = modelDoc.selection.getLastPosition();
  const nodeAfter = lastSelectionPosition.nodeAfter;
  if (isSoftEnter || !modelDoc.selection.isCollapsed || !lastSelectionPosition.isAtStart) {
    return false;
  }
  if (!isSoftBreakNode(nodeAfter)) {
    return false;
  }
  editor.model.change((writer) => {
    editor.execute("enter");
    const newBlock = modelDoc.selection.anchor.parent.previousSibling;
    writer.rename(newBlock, DEFAULT_ELEMENT);
    writer.setSelection(newBlock, "in");
    editor.model.schema.removeDisallowedAttributes([newBlock], writer);
    writer.remove(nodeAfter);
  });
  view.scrollToTheSelection();
  return true;
}
function leaveBlockEndOnEnter(editor, isSoftEnter) {
  const model = editor.model;
  const modelDoc = model.document;
  const view = editor.editing.view;
  const lastSelectionPosition = modelDoc.selection.getLastPosition();
  const nodeBefore = lastSelectionPosition.nodeBefore;
  let emptyLineRangeToRemoveOnEnter;
  if (isSoftEnter || !modelDoc.selection.isCollapsed || !lastSelectionPosition.isAtEnd || !nodeBefore || !nodeBefore.previousSibling) {
    return false;
  }
  if (isSoftBreakNode(nodeBefore) && isSoftBreakNode(nodeBefore.previousSibling)) {
    emptyLineRangeToRemoveOnEnter = model.createRange(model.createPositionBefore(nodeBefore.previousSibling), model.createPositionAfter(nodeBefore));
  } else if (isEmptyishTextNode(nodeBefore) && isSoftBreakNode(nodeBefore.previousSibling) && isSoftBreakNode(nodeBefore.previousSibling.previousSibling)) {
    emptyLineRangeToRemoveOnEnter = model.createRange(model.createPositionBefore(nodeBefore.previousSibling.previousSibling), model.createPositionAfter(nodeBefore));
  } else if (isEmptyishTextNode(nodeBefore) && isSoftBreakNode(nodeBefore.previousSibling) && isEmptyishTextNode(nodeBefore.previousSibling.previousSibling) && nodeBefore.previousSibling.previousSibling && isSoftBreakNode(nodeBefore.previousSibling.previousSibling.previousSibling)) {
    emptyLineRangeToRemoveOnEnter = model.createRange(model.createPositionBefore(nodeBefore.previousSibling.previousSibling.previousSibling), model.createPositionAfter(nodeBefore));
  } else {
    return false;
  }
  editor.model.change((writer) => {
    writer.remove(emptyLineRangeToRemoveOnEnter);
    editor.execute("enter");
    const newBlock = modelDoc.selection.anchor.parent;
    writer.rename(newBlock, DEFAULT_ELEMENT);
    editor.model.schema.removeDisallowedAttributes([newBlock], writer);
  });
  view.scrollToTheSelection();
  return true;
}
function isEmptyishTextNode(node) {
  return node && node.is("$text") && !node.data.match(/\S/);
}
function isSoftBreakNode(node) {
  return node && node.is("element", "softBreak");
}

// node_modules/@ckeditor/ckeditor5-code-block/src/codeblockui.js
import "/var/www/html/manorama/node_modules/@ckeditor/ckeditor5-code-block/theme/codeblock.css";
var CodeBlockUI = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "CodeBlockUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const t = editor.t;
    const componentFactory = editor.ui.componentFactory;
    const normalizedLanguageDefs = getNormalizedAndLocalizedLanguageDefinitions(editor);
    componentFactory.add("codeBlock", (locale) => {
      const command = editor.commands.get("codeBlock");
      const dropdownView = createDropdown(locale, SplitButtonView);
      const splitButtonView = dropdownView.buttonView;
      const accessibleLabel = t("Insert code block");
      splitButtonView.set({
        label: accessibleLabel,
        tooltip: true,
        icon: icons.codeBlock,
        isToggleable: true
      });
      splitButtonView.bind("isOn").to(command, "value", (value) => !!value);
      splitButtonView.on("execute", () => {
        editor.execute("codeBlock", {
          usePreviousLanguageChoice: true
        });
        editor.editing.view.focus();
      });
      dropdownView.on("execute", (evt) => {
        editor.execute("codeBlock", {
          language: evt.source._codeBlockLanguage,
          forceValue: true
        });
        editor.editing.view.focus();
      });
      dropdownView.class = "ck-code-block-dropdown";
      dropdownView.bind("isEnabled").to(command);
      addListToDropdown(dropdownView, () => this._getLanguageListItemDefinitions(normalizedLanguageDefs), {
        role: "menu",
        ariaLabel: accessibleLabel
      });
      return dropdownView;
    });
  }
  /**
   * A helper returning a collection of the `codeBlock` dropdown items representing languages
   * available for the user to choose from.
   */
  _getLanguageListItemDefinitions(normalizedLanguageDefs) {
    const editor = this.editor;
    const command = editor.commands.get("codeBlock");
    const itemDefinitions = new Collection();
    for (const languageDef of normalizedLanguageDefs) {
      const definition = {
        type: "button",
        model: new Model({
          _codeBlockLanguage: languageDef.language,
          label: languageDef.label,
          role: "menuitemradio",
          withText: true
        })
      };
      definition.model.bind("isOn").to(command, "value", (value) => {
        return value === definition.model._codeBlockLanguage;
      });
      itemDefinitions.add(definition);
    }
    return itemDefinitions;
  }
};

// node_modules/@ckeditor/ckeditor5-code-block/src/codeblock.js
var CodeBlock = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [CodeBlockEditing, CodeBlockUI];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "CodeBlock";
  }
};
export {
  CodeBlock,
  CodeBlockEditing,
  CodeBlockUI
};
/*! Bundled license information:

@ckeditor/ckeditor5-code-block/src/utils.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-code-block/src/codeblockcommand.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-code-block/src/indentcodeblockcommand.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-code-block/src/outdentcodeblockcommand.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-code-block/src/converters.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-code-block/src/codeblockediting.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-code-block/src/codeblockui.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-code-block/src/codeblock.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-code-block/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-code-block/src/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=@ckeditor_ckeditor5-code-block.js.map
