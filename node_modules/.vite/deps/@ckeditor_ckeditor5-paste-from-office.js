import "./chunk-BYFIKNKK.js";
import "./chunk-XTWUOPXT.js";
import "./chunk-NICE7ARI.js";
import {
  DataTransfer,
  Document,
  DomConverter,
  DomEventObserver,
  Matcher,
  Range,
  UpcastWriter
} from "./chunk-X5QTGNDD.js";
import "./chunk-2UXKTWKP.js";
import {
  EventInfo,
  toUnit,
  uid
} from "./chunk-MFEZX3FO.js";
import {
  Plugin
} from "./chunk-YB4X7RFQ.js";
import "./chunk-VMNDBVXW.js";
import {
  mapValues_default
} from "./chunk-LQD6FQVM.js";
import "./chunk-ROME4SDB.js";

// node_modules/ckeditor5/node_modules/@ckeditor/ckeditor5-clipboard/src/clipboardobserver.js
var ClipboardObserver = class extends DomEventObserver {
  constructor(view) {
    super(view);
    this.domEventType = [
      "paste",
      "copy",
      "cut",
      "drop",
      "dragover",
      "dragstart",
      "dragend",
      "dragenter",
      "dragleave"
    ];
    const viewDocument = this.document;
    this.listenTo(viewDocument, "paste", handleInput("clipboardInput"), { priority: "low" });
    this.listenTo(viewDocument, "drop", handleInput("clipboardInput"), { priority: "low" });
    this.listenTo(viewDocument, "dragover", handleInput("dragging"), { priority: "low" });
    function handleInput(type) {
      return (evt, data) => {
        data.preventDefault();
        const targetRanges = data.dropRange ? [data.dropRange] : null;
        const eventInfo = new EventInfo(viewDocument, type);
        viewDocument.fire(eventInfo, {
          dataTransfer: data.dataTransfer,
          method: evt.name,
          targetRanges,
          target: data.target,
          domEvent: data.domEvent
        });
        if (eventInfo.stop.called) {
          data.stopPropagation();
        }
      };
    }
  }
  onDomEvent(domEvent) {
    const nativeDataTransfer = "clipboardData" in domEvent ? domEvent.clipboardData : domEvent.dataTransfer;
    const cacheFiles = domEvent.type == "drop" || domEvent.type == "paste";
    const evtData = {
      dataTransfer: new DataTransfer(nativeDataTransfer, { cacheFiles })
    };
    if (domEvent.type == "drop" || domEvent.type == "dragover") {
      evtData.dropRange = getDropViewRange(this.view, domEvent);
    }
    this.fire(domEvent.type, domEvent, evtData);
  }
};
function getDropViewRange(view, domEvent) {
  const domDoc = domEvent.target.ownerDocument;
  const x = domEvent.clientX;
  const y = domEvent.clientY;
  let domRange;
  if (domDoc.caretRangeFromPoint && domDoc.caretRangeFromPoint(x, y)) {
    domRange = domDoc.caretRangeFromPoint(x, y);
  } else if (domEvent.rangeParent) {
    domRange = domDoc.createRange();
    domRange.setStart(domEvent.rangeParent, domEvent.rangeOffset);
    domRange.collapse(true);
  }
  if (domRange) {
    return view.domConverter.domRangeToView(domRange);
  }
  return null;
}

// node_modules/ckeditor5/node_modules/@ckeditor/ckeditor5-clipboard/src/utils/plaintexttohtml.js
function plainTextToHtml(text) {
  text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br>").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;");
  if (text.includes("</p><p>") || text.includes("<br>")) {
    text = `<p>${text}</p>`;
  }
  return text;
}

// node_modules/ckeditor5/node_modules/@ckeditor/ckeditor5-clipboard/src/utils/normalizeclipboarddata.js
function normalizeClipboardData(data) {
  return data.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (fullMatch, spaces) => {
    if (spaces.length == 1) {
      return " ";
    }
    return spaces;
  }).replace(/<!--[\s\S]*?-->/g, "");
}

// node_modules/ckeditor5/node_modules/@ckeditor/ckeditor5-clipboard/src/utils/viewtoplaintext.js
var smallPaddingElements = ["figcaption", "li"];
var listElements = ["ol", "ul"];
function viewToPlainText(viewItem) {
  if (viewItem.is("$text") || viewItem.is("$textProxy")) {
    return viewItem.data;
  }
  if (viewItem.is("element", "img") && viewItem.hasAttribute("alt")) {
    return viewItem.getAttribute("alt");
  }
  if (viewItem.is("element", "br")) {
    return "\n";
  }
  let text = "";
  let prev = null;
  for (const child of viewItem.getChildren()) {
    text += newLinePadding(child, prev) + viewToPlainText(child);
    prev = child;
  }
  return text;
}
function newLinePadding(element, previous) {
  if (!previous) {
    return "";
  }
  if (element.is("element", "li") && !element.isEmpty && element.getChild(0).is("containerElement")) {
    return "\n\n";
  }
  if (listElements.includes(element.name) && listElements.includes(previous.name)) {
    return "\n\n";
  }
  if (!element.is("containerElement") && !previous.is("containerElement")) {
    return "";
  }
  if (smallPaddingElements.includes(element.name) || smallPaddingElements.includes(previous.name)) {
    return "\n";
  }
  return "\n\n";
}

// node_modules/ckeditor5/node_modules/@ckeditor/ckeditor5-clipboard/src/clipboardmarkersutils.js
var ClipboardMarkersUtils = class extends Plugin {
  constructor() {
    super(...arguments);
    this._markersToCopy = /* @__PURE__ */ new Map();
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ClipboardMarkersUtils";
  }
  /**
   * Registers marker name as copyable in clipboard pipeline.
   *
   * @param markerName Name of marker that can be copied.
   * @param restrictions Preset or specified array of actions that can be performed on specified marker name.
   * @internal
   */
  _registerMarkerToCopy(markerName, restrictions) {
    const allowedActions = Array.isArray(restrictions) ? restrictions : this._mapRestrictionPresetToActions(restrictions);
    if (allowedActions.length) {
      this._markersToCopy.set(markerName, allowedActions);
    }
  }
  /**
   * Maps preset into array of clipboard operations to be allowed on marker.
   *
   * @param preset Restrictions preset to be mapped to actions
   * @internal
   */
  _mapRestrictionPresetToActions(preset) {
    switch (preset) {
      case "always":
        return ["copy", "cut", "dragstart"];
      case "default":
        return ["cut", "dragstart"];
      case "never":
        return [];
      default: {
        const unreachable = preset;
        return [];
      }
    }
  }
  /**
   * Performs copy markers on provided selection and paste it to fragment returned from `getCopiedFragment`.
   *
   * 	1. Picks all markers in provided selection.
   * 	2. Inserts fake markers to document.
   * 	3. Gets copied selection fragment from document.
   * 	4. Removes fake elements from fragment and document.
   * 	5. Inserts markers in the place of removed fake markers.
   *
   * Due to selection modification, when inserting items, `getCopiedFragment` must *always* operate on `writer.model.document.selection'.
   * Do not use any other custom selection object within callback, as this will lead to out-of-bounds exceptions in rare scenarios.
   *
   * @param action Type of clipboard action.
   * @param writer An instance of the model writer.
   * @param selection Selection to be checked.
   * @param getCopiedFragment	Callback that performs copy of selection and returns it as fragment.
   * @internal
   */
  _copySelectedFragmentWithMarkers(action, selection, getCopiedFragment = (writer) => writer.model.getSelectedContent(writer.model.document.selection)) {
    return this.editor.model.change((writer) => {
      const oldSelection = writer.model.document.selection;
      writer.setSelection(selection);
      const sourceSelectionInsertedMarkers = this._insertFakeMarkersIntoSelection(writer, writer.model.document.selection, action);
      const fragment = getCopiedFragment(writer);
      const fakeMarkersRangesInsideRange = this._removeFakeMarkersInsideElement(writer, fragment);
      for (const [markerName, elements] of Object.entries(sourceSelectionInsertedMarkers)) {
        fakeMarkersRangesInsideRange[markerName] || (fakeMarkersRangesInsideRange[markerName] = writer.createRangeIn(fragment));
        for (const element of elements) {
          writer.remove(element);
        }
      }
      fragment.markers.clear();
      for (const [markerName, range] of Object.entries(fakeMarkersRangesInsideRange)) {
        fragment.markers.set(markerName, range);
      }
      writer.setSelection(oldSelection);
      return fragment;
    });
  }
  /**
   * Performs paste of markers on already pasted element.
   *
   * 	1. Inserts fake markers that are present in fragment element (such fragment will be processed in `getPastedDocumentElement`).
   * 	2. Calls `getPastedDocumentElement` and gets element that is inserted into root model.
   * 	3. Removes all fake markers present in transformed element.
   * 	4. Inserts new markers with removed fake markers ranges into pasted fragment.
   *
   * There are multiple edge cases that have to be considered before calling this function:
   *
   * 	* `markers` are inserted into the same element that must be later transformed inside `getPastedDocumentElement`.
   * 	* Fake marker elements inside `getPastedDocumentElement` can be cloned, but their ranges cannot overlap.
   *
   * @param action Type of clipboard action.
   * @param markers Object that maps marker name to corresponding range.
   * @param getPastedDocumentElement Getter used to get target markers element.
   * @internal
   */
  _pasteMarkersIntoTransformedElement(markers, getPastedDocumentElement) {
    const copyableMarkers = this._getCopyableMarkersFromRangeMap(markers);
    return this.editor.model.change((writer) => {
      const sourceFragmentFakeMarkers = this._insertFakeMarkersElements(writer, copyableMarkers);
      const transformedElement = getPastedDocumentElement(writer);
      const removedFakeMarkers = this._removeFakeMarkersInsideElement(writer, transformedElement);
      for (const element of Object.values(sourceFragmentFakeMarkers).flat()) {
        writer.remove(element);
      }
      for (const [markerName, range] of Object.entries(removedFakeMarkers)) {
        const uniqueName = writer.model.markers.has(markerName) ? this._getUniqueMarkerName(markerName) : markerName;
        writer.addMarker(uniqueName, {
          usingOperation: true,
          affectsData: true,
          range
        });
      }
      return transformedElement;
    });
  }
  /**
   * In some situations we have to perform copy on selected fragment with certain markers. This function allows to temporarily bypass
   * restrictions on markers that we want to copy.
   *
   * This function executes `executor()` callback. For the duration of the callback, if the clipboard pipeline is used to copy
   * content, markers with the specified name will be copied to the clipboard as well.
   *
   * @param markerName Which markers should be copied.
   * @param executor Callback executed.
   * @internal
   */
  _forceMarkersCopy(markerName, executor) {
    const before = this._markersToCopy.get(markerName);
    this._markersToCopy.set(markerName, this._mapRestrictionPresetToActions("always"));
    executor();
    if (before) {
      this._markersToCopy.set(markerName, before);
    } else {
      this._markersToCopy.delete(markerName);
    }
  }
  /**
   * Checks if marker can be copied.
   *
   * @param markerName Name of checked marker.
   * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.
   * @internal
   */
  _canPerformMarkerClipboardAction(markerName, action) {
    const [markerNamePrefix] = markerName.split(":");
    if (!action) {
      return this._markersToCopy.has(markerNamePrefix);
    }
    const possibleActions = this._markersToCopy.get(markerNamePrefix) || [];
    return possibleActions.includes(action);
  }
  /**
   * Changes marker names for markers stored in given document fragment so that they are unique.
   *
   * @param fragment
   * @internal
   */
  _setUniqueMarkerNamesInFragment(fragment) {
    const markers = Array.from(fragment.markers);
    fragment.markers.clear();
    for (const [name, range] of markers) {
      const newName = this._canPerformMarkerClipboardAction(name, null) ? this._getUniqueMarkerName(name) : name;
      fragment.markers.set(newName, range);
    }
  }
  /**
   * First step of copying markers. It looks for markers intersecting with given selection and inserts `$marker` elements
   * at positions where document markers start or end. This way `$marker` elements can be easily copied together with
   * the rest of the content of the selection.
   *
   * @param writer An instance of the model writer.
   * @param selection Selection to be checked.
   * @param action Type of clipboard action.
   */
  _insertFakeMarkersIntoSelection(writer, selection, action) {
    const copyableMarkers = this._getCopyableMarkersFromSelection(writer, selection, action);
    return this._insertFakeMarkersElements(writer, copyableMarkers);
  }
  /**
   * Returns array of markers that can be copied in specified selection.
   *
   * @param writer An instance of the model writer.
   * @param selection  Selection which will be checked.
   * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.
   */
  _getCopyableMarkersFromSelection(writer, selection, action) {
    return Array.from(selection.getRanges()).flatMap((selectionRange) => Array.from(writer.model.markers.getMarkersIntersectingRange(selectionRange))).filter((marker) => this._canPerformMarkerClipboardAction(marker.name, action)).map((marker) => ({
      name: marker.name,
      range: marker.getRange()
    }));
  }
  /**
   * Picks all markers from markers map that can be copied.
   *
   * @param markers Object that maps marker name to corresponding range.
   * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.
   */
  _getCopyableMarkersFromRangeMap(markers, action = null) {
    const entries = markers instanceof Map ? Array.from(markers.entries()) : Object.entries(markers);
    return entries.map(([markerName, range]) => ({
      name: markerName,
      range
    })).filter((marker) => this._canPerformMarkerClipboardAction(marker.name, action));
  }
  /**
   * Inserts specified array of fake markers elements to document and assigns them `type` and `name` attributes.
   * Fake markers elements are used to calculate position of markers on pasted fragment that were transformed during
   * steps between copy and paste.
   *
   * @param writer An instance of the model writer.
   * @param markers Array of markers that will be inserted.
   */
  _insertFakeMarkersElements(writer, markers) {
    const mappedMarkers = {};
    const sortedMarkers = markers.flatMap((marker) => {
      const { start, end } = marker.range;
      return [
        { position: start, marker, type: "start" },
        { position: end, marker, type: "end" }
      ];
    }).sort(({ position: posA }, { position: posB }) => posA.isBefore(posB) ? 1 : -1);
    for (const { position, marker, type } of sortedMarkers) {
      const fakeMarker = writer.createElement("$marker", {
        "data-name": marker.name,
        "data-type": type
      });
      if (!mappedMarkers[marker.name]) {
        mappedMarkers[marker.name] = [];
      }
      mappedMarkers[marker.name].push(fakeMarker);
      writer.insert(fakeMarker, position);
    }
    return mappedMarkers;
  }
  /**
   * Removes all `$marker` elements from the given document fragment.
   *
   * Returns an object where keys are marker names, and values are ranges corresponding to positions
   * where `$marker` elements were inserted.
   *
   * If the document fragment had only one `$marker` element for given marker (start or end) the other boundary is set automatically
   * (to the end or start of the document fragment, respectively).
   *
   * @param writer An instance of the model writer.
   * @param rootElement The element to be checked.
   */
  _removeFakeMarkersInsideElement(writer, rootElement) {
    const fakeMarkersElements = this._getAllFakeMarkersFromElement(writer, rootElement);
    const fakeMarkersRanges = fakeMarkersElements.reduce((acc, fakeMarker) => {
      const position = fakeMarker.markerElement && writer.createPositionBefore(fakeMarker.markerElement);
      let prevFakeMarker = acc[fakeMarker.name];
      if (prevFakeMarker && prevFakeMarker.start && prevFakeMarker.end) {
        acc[this._getUniqueMarkerName(fakeMarker.name)] = acc[fakeMarker.name];
        prevFakeMarker = null;
      }
      acc[fakeMarker.name] = {
        ...prevFakeMarker,
        [fakeMarker.type]: position
      };
      if (fakeMarker.markerElement) {
        writer.remove(fakeMarker.markerElement);
      }
      return acc;
    }, {});
    return mapValues_default(fakeMarkersRanges, (range) => new Range(range.start || writer.createPositionFromPath(rootElement, [0]), range.end || writer.createPositionAt(rootElement, "end")));
  }
  /**
   * Returns array that contains list of fake markers with corresponding `$marker` elements.
   *
   * For each marker, there can be two `$marker` elements or only one (if the document fragment contained
   * only the beginning or only the end of a marker).
   *
   * @param writer An instance of the model writer.
   * @param rootElement The element to be checked.
   */
  _getAllFakeMarkersFromElement(writer, rootElement) {
    const foundFakeMarkers = Array.from(writer.createRangeIn(rootElement)).flatMap(({ item }) => {
      if (!item.is("element", "$marker")) {
        return [];
      }
      const name = item.getAttribute("data-name");
      const type = item.getAttribute("data-type");
      return [
        {
          markerElement: item,
          name,
          type
        }
      ];
    });
    const prependFakeMarkers = [];
    const appendFakeMarkers = [];
    for (const fakeMarker of foundFakeMarkers) {
      if (fakeMarker.type === "end") {
        const hasMatchingStartMarker = foundFakeMarkers.some((otherFakeMarker) => otherFakeMarker.name === fakeMarker.name && otherFakeMarker.type === "start");
        if (!hasMatchingStartMarker) {
          prependFakeMarkers.push({
            markerElement: null,
            name: fakeMarker.name,
            type: "start"
          });
        }
      }
      if (fakeMarker.type === "start") {
        const hasMatchingEndMarker = foundFakeMarkers.some((otherFakeMarker) => otherFakeMarker.name === fakeMarker.name && otherFakeMarker.type === "end");
        if (!hasMatchingEndMarker) {
          appendFakeMarkers.unshift({
            markerElement: null,
            name: fakeMarker.name,
            type: "end"
          });
        }
      }
    }
    return [
      ...prependFakeMarkers,
      ...foundFakeMarkers,
      ...appendFakeMarkers
    ];
  }
  /**
   * When copy of markers occurs we have to make sure that pasted markers have different names
   * than source markers. This functions helps with assigning unique part to marker name to
   * prevent duplicated markers error.
   *
   * @param name Name of marker
   */
  _getUniqueMarkerName(name) {
    const parts = name.split(":");
    const newId = uid().substring(1, 6);
    if (parts.length === 3) {
      return `${parts.slice(0, 2).join(":")}:${newId}`;
    }
    return `${parts.join(":")}:${newId}`;
  }
};

// node_modules/ckeditor5/node_modules/@ckeditor/ckeditor5-clipboard/src/clipboardpipeline.js
var ClipboardPipeline = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ClipboardPipeline";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ClipboardMarkersUtils];
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const view = editor.editing.view;
    view.addObserver(ClipboardObserver);
    this._setupPasteDrop();
    this._setupCopyCut();
  }
  /**
   * Fires Clipboard `'outputTransformation'` event for given parameters.
   *
   * @internal
   */
  _fireOutputTransformationEvent(dataTransfer, selection, method) {
    const clipboardMarkersUtils = this.editor.plugins.get("ClipboardMarkersUtils");
    const documentFragment = clipboardMarkersUtils._copySelectedFragmentWithMarkers(method, selection);
    this.fire("outputTransformation", {
      dataTransfer,
      content: documentFragment,
      method
    });
  }
  /**
   * The clipboard paste pipeline.
   */
  _setupPasteDrop() {
    const editor = this.editor;
    const model = editor.model;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const clipboardMarkersUtils = this.editor.plugins.get("ClipboardMarkersUtils");
    this.listenTo(viewDocument, "clipboardInput", (evt, data) => {
      if (data.method == "paste" && !editor.model.canEditAt(editor.model.document.selection)) {
        evt.stop();
      }
    }, { priority: "highest" });
    this.listenTo(viewDocument, "clipboardInput", (evt, data) => {
      const dataTransfer = data.dataTransfer;
      let content;
      if (data.content) {
        content = data.content;
      } else {
        let contentData = "";
        if (dataTransfer.getData("text/html")) {
          contentData = normalizeClipboardData(dataTransfer.getData("text/html"));
        } else if (dataTransfer.getData("text/plain")) {
          contentData = plainTextToHtml(dataTransfer.getData("text/plain"));
        }
        content = this.editor.data.htmlProcessor.toView(contentData);
      }
      const eventInfo = new EventInfo(this, "inputTransformation");
      this.fire(eventInfo, {
        content,
        dataTransfer,
        targetRanges: data.targetRanges,
        method: data.method
      });
      if (eventInfo.stop.called) {
        evt.stop();
      }
      view.scrollToTheSelection();
    }, { priority: "low" });
    this.listenTo(this, "inputTransformation", (evt, data) => {
      if (data.content.isEmpty) {
        return;
      }
      const dataController = this.editor.data;
      const modelFragment = dataController.toModel(data.content, "$clipboardHolder");
      if (modelFragment.childCount == 0) {
        return;
      }
      evt.stop();
      model.change(() => {
        this.fire("contentInsertion", {
          content: modelFragment,
          method: data.method,
          dataTransfer: data.dataTransfer,
          targetRanges: data.targetRanges
        });
      });
    }, { priority: "low" });
    this.listenTo(this, "contentInsertion", (evt, data) => {
      clipboardMarkersUtils._setUniqueMarkerNamesInFragment(data.content);
    }, { priority: "highest" });
    this.listenTo(this, "contentInsertion", (evt, data) => {
      data.resultRange = model.insertContent(data.content);
    }, { priority: "low" });
  }
  /**
   * The clipboard copy/cut pipeline.
   */
  _setupCopyCut() {
    const editor = this.editor;
    const modelDocument = editor.model.document;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const onCopyCut = (evt, data) => {
      const dataTransfer = data.dataTransfer;
      data.preventDefault();
      this._fireOutputTransformationEvent(dataTransfer, modelDocument.selection, evt.name);
    };
    this.listenTo(viewDocument, "copy", onCopyCut, { priority: "low" });
    this.listenTo(viewDocument, "cut", (evt, data) => {
      if (!editor.model.canEditAt(editor.model.document.selection)) {
        data.preventDefault();
      } else {
        onCopyCut(evt, data);
      }
    }, { priority: "low" });
    this.listenTo(this, "outputTransformation", (evt, data) => {
      const content = editor.data.toView(data.content);
      viewDocument.fire("clipboardOutput", {
        dataTransfer: data.dataTransfer,
        content,
        method: data.method
      });
    }, { priority: "low" });
    this.listenTo(viewDocument, "clipboardOutput", (evt, data) => {
      if (!data.content.isEmpty) {
        data.dataTransfer.setData("text/html", this.editor.data.htmlProcessor.toData(data.content));
        data.dataTransfer.setData("text/plain", viewToPlainText(data.content));
      }
      if (data.method == "cut") {
        editor.model.deleteContent(modelDocument.selection);
      }
    }, { priority: "low" });
  }
};

// node_modules/ckeditor5/node_modules/@ckeditor/ckeditor5-clipboard/src/lineview.js
var toPx = toUnit("px");

// node_modules/ckeditor5/node_modules/@ckeditor/ckeditor5-clipboard/src/dragdrop.js
import "/var/www/html/manorama/node_modules/ckeditor5/node_modules/@ckeditor/ckeditor5-clipboard/theme/clipboard.css";

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/list.js
function transformListItemLikeElementsIntoLists(documentFragment, stylesString) {
  if (!documentFragment.childCount) {
    return;
  }
  const writer = new UpcastWriter(documentFragment.document);
  const itemLikeElements = findAllItemLikeElements(documentFragment, writer);
  if (!itemLikeElements.length) {
    return;
  }
  let currentList = null;
  let currentIndentation = 1;
  itemLikeElements.forEach((itemLikeElement, i) => {
    const isDifferentList = isNewListNeeded(itemLikeElements[i - 1], itemLikeElement);
    const previousItemLikeElement = isDifferentList ? null : itemLikeElements[i - 1];
    const indentationDifference = getIndentationDifference(previousItemLikeElement, itemLikeElement);
    if (isDifferentList) {
      currentList = null;
      currentIndentation = 1;
    }
    if (!currentList || indentationDifference !== 0) {
      const listStyle = detectListStyle(itemLikeElement, stylesString);
      if (!currentList) {
        currentList = insertNewEmptyList(listStyle, itemLikeElement.element, writer);
      } else if (itemLikeElement.indent > currentIndentation) {
        const lastListItem = currentList.getChild(currentList.childCount - 1);
        const lastListItemChild = lastListItem.getChild(lastListItem.childCount - 1);
        currentList = insertNewEmptyList(listStyle, lastListItemChild, writer);
        currentIndentation += 1;
      } else if (itemLikeElement.indent < currentIndentation) {
        const differentIndentation = currentIndentation - itemLikeElement.indent;
        currentList = findParentListAtLevel(currentList, differentIndentation);
        currentIndentation = itemLikeElement.indent;
      }
      if (itemLikeElement.indent <= currentIndentation) {
        if (!currentList.is("element", listStyle.type)) {
          currentList = writer.rename(listStyle.type, currentList);
        }
      }
    }
    const listItem = transformElementIntoListItem(itemLikeElement.element, writer);
    writer.appendChild(listItem, currentList);
  });
}
function unwrapParagraphInListItem(documentFragment, writer) {
  for (const value of writer.createRangeIn(documentFragment)) {
    const element = value.item;
    if (element.is("element", "li")) {
      const firstChild = element.getChild(0);
      if (firstChild && firstChild.is("element", "p")) {
        writer.unwrapElement(firstChild);
      }
    }
  }
}
function findAllItemLikeElements(documentFragment, writer) {
  const range = writer.createRangeIn(documentFragment);
  const itemLikeElementsMatcher = new Matcher({
    name: /^p|h\d+$/,
    styles: {
      "mso-list": /.*/
    }
  });
  const itemLikeElements = [];
  for (const value of range) {
    if (value.type === "elementStart" && itemLikeElementsMatcher.match(value.item)) {
      const itemData = getListItemData(value.item);
      itemLikeElements.push({
        element: value.item,
        id: itemData.id,
        order: itemData.order,
        indent: itemData.indent
      });
    }
  }
  return itemLikeElements;
}
function detectListStyle(listLikeItem, stylesString) {
  const listStyleRegexp = new RegExp(`@list l${listLikeItem.id}:level${listLikeItem.indent}\\s*({[^}]*)`, "gi");
  const listStyleTypeRegex = /mso-level-number-format:([^;]{0,100});/gi;
  const listStartIndexRegex = /mso-level-start-at:\s{0,100}([0-9]{0,10})\s{0,100};/gi;
  const listStyleMatch = listStyleRegexp.exec(stylesString);
  let listStyleType = "decimal";
  let type = "ol";
  let startIndex = null;
  if (listStyleMatch && listStyleMatch[1]) {
    const listStyleTypeMatch = listStyleTypeRegex.exec(listStyleMatch[1]);
    if (listStyleTypeMatch && listStyleTypeMatch[1]) {
      listStyleType = listStyleTypeMatch[1].trim();
      type = listStyleType !== "bullet" && listStyleType !== "image" ? "ol" : "ul";
    }
    if (listStyleType === "bullet") {
      const bulletedStyle = findBulletedListStyle(listLikeItem.element);
      if (bulletedStyle) {
        listStyleType = bulletedStyle;
      }
    } else {
      const listStartIndexMatch = listStartIndexRegex.exec(listStyleMatch[1]);
      if (listStartIndexMatch && listStartIndexMatch[1]) {
        startIndex = parseInt(listStartIndexMatch[1]);
      }
    }
  }
  return {
    type,
    startIndex,
    style: mapListStyleDefinition(listStyleType)
  };
}
function findBulletedListStyle(element) {
  const listMarkerElement = findListMarkerNode(element);
  if (!listMarkerElement) {
    return null;
  }
  const listMarker = listMarkerElement._data;
  if (listMarker === "o") {
    return "circle";
  } else if (listMarker === "·") {
    return "disc";
  } else if (listMarker === "§") {
    return "square";
  }
  return null;
}
function findListMarkerNode(element) {
  if (element.getChild(0).is("$text")) {
    return null;
  }
  for (const childNode of element.getChildren()) {
    if (!childNode.is("element", "span")) {
      continue;
    }
    const textNodeOrElement = childNode.getChild(0);
    if (!textNodeOrElement) {
      continue;
    }
    if (textNodeOrElement.is("$text")) {
      return textNodeOrElement;
    }
    return textNodeOrElement.getChild(0);
  }
  return null;
}
function mapListStyleDefinition(value) {
  if (value.startsWith("arabic-leading-zero")) {
    return "decimal-leading-zero";
  }
  switch (value) {
    case "alpha-upper":
      return "upper-alpha";
    case "alpha-lower":
      return "lower-alpha";
    case "roman-upper":
      return "upper-roman";
    case "roman-lower":
      return "lower-roman";
    case "circle":
    case "disc":
    case "square":
      return value;
    default:
      return null;
  }
}
function insertNewEmptyList(listStyle, element, writer) {
  const parent = element.parent;
  const list = writer.createElement(listStyle.type);
  const position = parent.getChildIndex(element) + 1;
  writer.insertChild(position, list, parent);
  if (listStyle.style) {
    writer.setStyle("list-style-type", listStyle.style, list);
  }
  if (listStyle.startIndex && listStyle.startIndex > 1) {
    writer.setAttribute("start", listStyle.startIndex, list);
  }
  return list;
}
function transformElementIntoListItem(element, writer) {
  removeBulletElement(element, writer);
  writer.removeStyle("text-indent", element);
  return writer.rename("li", element);
}
function getListItemData(element) {
  const data = {};
  const listStyle = element.getStyle("mso-list");
  if (listStyle) {
    const idMatch = listStyle.match(/(^|\s{1,100})l(\d+)/i);
    const orderMatch = listStyle.match(/\s{0,100}lfo(\d+)/i);
    const indentMatch = listStyle.match(/\s{0,100}level(\d+)/i);
    if (idMatch && orderMatch && indentMatch) {
      data.id = idMatch[2];
      data.order = orderMatch[1];
      data.indent = parseInt(indentMatch[1]);
    }
  }
  return data;
}
function removeBulletElement(element, writer) {
  const bulletMatcher = new Matcher({
    name: "span",
    styles: {
      "mso-list": "Ignore"
    }
  });
  const range = writer.createRangeIn(element);
  for (const value of range) {
    if (value.type === "elementStart" && bulletMatcher.match(value.item)) {
      writer.remove(value.item);
    }
  }
}
function isNewListNeeded(previousItem, currentItem) {
  if (!previousItem) {
    return true;
  }
  if (previousItem.id !== currentItem.id) {
    if (currentItem.indent - previousItem.indent === 1) {
      return false;
    }
    return true;
  }
  const previousSibling = currentItem.element.previousSibling;
  if (!previousSibling) {
    return true;
  }
  return !isList(previousSibling);
}
function isList(element) {
  return element.is("element", "ol") || element.is("element", "ul");
}
function getIndentationDifference(previousItem, currentItem) {
  return previousItem ? currentItem.indent - previousItem.indent : currentItem.indent - 1;
}
function findParentListAtLevel(listElement, indentationDifference) {
  const ancestors = listElement.getAncestors({ parentFirst: true });
  let parentList = null;
  let levelChange = 0;
  for (const ancestor of ancestors) {
    if (ancestor.is("element", "ul") || ancestor.is("element", "ol")) {
      levelChange++;
    }
    if (levelChange === indentationDifference) {
      parentList = ancestor;
      break;
    }
  }
  return parentList;
}

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/image.js
function replaceImagesSourceWithBase64(documentFragment, rtfData) {
  if (!documentFragment.childCount) {
    return;
  }
  const upcastWriter = new UpcastWriter(documentFragment.document);
  const shapesIds = findAllShapesIds(documentFragment, upcastWriter);
  removeAllImgElementsRepresentingShapes(shapesIds, documentFragment, upcastWriter);
  insertMissingImgs(shapesIds, documentFragment, upcastWriter);
  removeAllShapeElements(documentFragment, upcastWriter);
  const images = findAllImageElementsWithLocalSource(documentFragment, upcastWriter);
  if (images.length) {
    replaceImagesFileSourceWithInlineRepresentation(images, extractImageDataFromRtf(rtfData), upcastWriter);
  }
}
function _convertHexToBase64(hexString) {
  return btoa(hexString.match(/\w{2}/g).map((char) => {
    return String.fromCharCode(parseInt(char, 16));
  }).join(""));
}
function findAllShapesIds(documentFragment, writer) {
  const range = writer.createRangeIn(documentFragment);
  const shapeElementsMatcher = new Matcher({
    name: /v:(.+)/
  });
  const shapesIds = [];
  for (const value of range) {
    if (value.type != "elementStart") {
      continue;
    }
    const el = value.item;
    const previousSibling = el.previousSibling;
    const prevSiblingName = previousSibling && previousSibling.is("element") ? previousSibling.name : null;
    const exceptionIds = ["Chart"];
    const isElementAShape = shapeElementsMatcher.match(el);
    const hasElementGfxdataAttribute = el.getAttribute("o:gfxdata");
    const isPreviousSiblingAShapeType = prevSiblingName === "v:shapetype";
    const isElementIdInExceptionsArray = hasElementGfxdataAttribute && exceptionIds.some((item) => el.getAttribute("id").includes(item));
    if (isElementAShape && hasElementGfxdataAttribute && !isPreviousSiblingAShapeType && !isElementIdInExceptionsArray) {
      shapesIds.push(value.item.getAttribute("id"));
    }
  }
  return shapesIds;
}
function removeAllImgElementsRepresentingShapes(shapesIds, documentFragment, writer) {
  const range = writer.createRangeIn(documentFragment);
  const imageElementsMatcher = new Matcher({
    name: "img"
  });
  const imgs = [];
  for (const value of range) {
    if (value.item.is("element") && imageElementsMatcher.match(value.item)) {
      const el = value.item;
      const shapes = el.getAttribute("v:shapes") ? el.getAttribute("v:shapes").split(" ") : [];
      if (shapes.length && shapes.every((shape) => shapesIds.indexOf(shape) > -1)) {
        imgs.push(el);
      } else if (!el.getAttribute("src")) {
        imgs.push(el);
      }
    }
  }
  for (const img of imgs) {
    writer.remove(img);
  }
}
function removeAllShapeElements(documentFragment, writer) {
  const range = writer.createRangeIn(documentFragment);
  const shapeElementsMatcher = new Matcher({
    name: /v:(.+)/
  });
  const shapes = [];
  for (const value of range) {
    if (value.type == "elementStart" && shapeElementsMatcher.match(value.item)) {
      shapes.push(value.item);
    }
  }
  for (const shape of shapes) {
    writer.remove(shape);
  }
}
function insertMissingImgs(shapeIds, documentFragment, writer) {
  const range = writer.createRangeIn(documentFragment);
  const shapes = [];
  for (const value of range) {
    if (value.type == "elementStart" && value.item.is("element", "v:shape")) {
      const id = value.item.getAttribute("id");
      if (shapeIds.includes(id)) {
        continue;
      }
      if (!containsMatchingImg(value.item.parent.getChildren(), id)) {
        shapes.push(value.item);
      }
    }
  }
  for (const shape of shapes) {
    const attrs = {
      src: findSrc(shape)
    };
    if (shape.hasAttribute("alt")) {
      attrs.alt = shape.getAttribute("alt");
    }
    const img = writer.createElement("img", attrs);
    writer.insertChild(shape.index + 1, img, shape.parent);
  }
  function containsMatchingImg(nodes, id) {
    for (const node of nodes) {
      if (node.is("element")) {
        if (node.name == "img" && node.getAttribute("v:shapes") == id) {
          return true;
        }
        if (containsMatchingImg(node.getChildren(), id)) {
          return true;
        }
      }
    }
    return false;
  }
  function findSrc(shape) {
    for (const child of shape.getChildren()) {
      if (child.is("element") && child.getAttribute("src")) {
        return child.getAttribute("src");
      }
    }
  }
}
function findAllImageElementsWithLocalSource(documentFragment, writer) {
  const range = writer.createRangeIn(documentFragment);
  const imageElementsMatcher = new Matcher({
    name: "img"
  });
  const imgs = [];
  for (const value of range) {
    if (value.item.is("element") && imageElementsMatcher.match(value.item)) {
      if (value.item.getAttribute("src").startsWith("file://")) {
        imgs.push(value.item);
      }
    }
  }
  return imgs;
}
function extractImageDataFromRtf(rtfData) {
  if (!rtfData) {
    return [];
  }
  const regexPictureHeader = /{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/;
  const regexPicture = new RegExp("(?:(" + regexPictureHeader.source + "))([\\da-fA-F\\s]+)\\}", "g");
  const images = rtfData.match(regexPicture);
  const result = [];
  if (images) {
    for (const image of images) {
      let imageType = false;
      if (image.includes("\\pngblip")) {
        imageType = "image/png";
      } else if (image.includes("\\jpegblip")) {
        imageType = "image/jpeg";
      }
      if (imageType) {
        result.push({
          hex: image.replace(regexPictureHeader, "").replace(/[^\da-fA-F]/g, ""),
          type: imageType
        });
      }
    }
  }
  return result;
}
function replaceImagesFileSourceWithInlineRepresentation(imageElements, imagesHexSources, writer) {
  if (imageElements.length === imagesHexSources.length) {
    for (let i = 0; i < imageElements.length; i++) {
      const newSrc = `data:${imagesHexSources[i].type};base64,${_convertHexToBase64(imagesHexSources[i].hex)}`;
      writer.setAttribute("src", newSrc, imageElements[i]);
    }
  }
}

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/removemsattributes.js
function removeMSAttributes(documentFragment) {
  const elementsToUnwrap = [];
  const writer = new UpcastWriter(documentFragment.document);
  for (const { item } of writer.createRangeIn(documentFragment)) {
    if (!item.is("element")) {
      continue;
    }
    for (const className of item.getClassNames()) {
      if (/\bmso/gi.exec(className)) {
        writer.removeClass(className, item);
      }
    }
    for (const styleName of item.getStyleNames()) {
      if (/\bmso/gi.exec(styleName)) {
        writer.removeStyle(styleName, item);
      }
    }
    if (item.is("element", "w:sdt")) {
      elementsToUnwrap.push(item);
    }
  }
  for (const item of elementsToUnwrap) {
    const itemParent = item.parent;
    const childIndex = itemParent.getChildIndex(item);
    writer.insertChild(childIndex, item.getChildren(), itemParent);
    writer.remove(item);
  }
}

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/normalizers/mswordnormalizer.js
var msWordMatch1 = /<meta\s*name="?generator"?\s*content="?microsoft\s*word\s*\d+"?\/?>/i;
var msWordMatch2 = /xmlns:o="urn:schemas-microsoft-com/i;
var MSWordNormalizer = class {
  /**
   * Creates a new `MSWordNormalizer` instance.
   *
   * @param document View document.
   */
  constructor(document2) {
    this.document = document2;
  }
  /**
   * @inheritDoc
   */
  isActive(htmlString) {
    return msWordMatch1.test(htmlString) || msWordMatch2.test(htmlString);
  }
  /**
   * @inheritDoc
   */
  execute(data) {
    const { body: documentFragment, stylesString } = data._parsedData;
    transformListItemLikeElementsIntoLists(documentFragment, stylesString);
    replaceImagesSourceWithBase64(documentFragment, data.dataTransfer.getData("text/rtf"));
    removeMSAttributes(documentFragment);
    data.content = documentFragment;
  }
};

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/removeboldwrapper.js
function removeBoldWrapper(documentFragment, writer) {
  for (const child of documentFragment.getChildren()) {
    if (child.is("element", "b") && child.getStyle("font-weight") === "normal") {
      const childIndex = documentFragment.getChildIndex(child);
      writer.remove(child);
      writer.insertChild(childIndex, child.getChildren(), documentFragment);
    }
  }
}

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/br.js
function transformBlockBrsToParagraphs(documentFragment, writer) {
  const viewDocument = new Document(writer.document.stylesProcessor);
  const domConverter = new DomConverter(viewDocument, { renderingMode: "data" });
  const blockElements = domConverter.blockElements;
  const inlineObjectElements = domConverter.inlineObjectElements;
  const elementsToReplace = [];
  for (const value of writer.createRangeIn(documentFragment)) {
    const element = value.item;
    if (element.is("element", "br")) {
      const nextSibling = findSibling(element, "forward", writer, { blockElements, inlineObjectElements });
      const previousSibling = findSibling(element, "backward", writer, { blockElements, inlineObjectElements });
      const nextSiblingIsBlock = isBlockViewElement(nextSibling, blockElements);
      const previousSiblingIsBlock = isBlockViewElement(previousSibling, blockElements);
      if (previousSiblingIsBlock || nextSiblingIsBlock) {
        elementsToReplace.push(element);
      }
    }
  }
  for (const element of elementsToReplace) {
    if (element.hasClass("Apple-interchange-newline")) {
      writer.remove(element);
    } else {
      writer.replace(element, writer.createElement("p"));
    }
  }
}
function findSibling(viewElement, direction, writer, { blockElements, inlineObjectElements }) {
  let position = writer.createPositionAt(viewElement, direction == "forward" ? "after" : "before");
  position = position.getLastMatchingPosition(({ item }) => item.is("element") && !blockElements.includes(item.name) && !inlineObjectElements.includes(item.name), { direction });
  return direction == "forward" ? position.nodeAfter : position.nodeBefore;
}
function isBlockViewElement(node, blockElements) {
  return !!node && node.is("element") && blockElements.includes(node.name);
}

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/normalizers/googledocsnormalizer.js
var googleDocsMatch = /id=("|')docs-internal-guid-[-0-9a-f]+("|')/i;
var GoogleDocsNormalizer = class {
  /**
   * Creates a new `GoogleDocsNormalizer` instance.
   *
   * @param document View document.
   */
  constructor(document2) {
    this.document = document2;
  }
  /**
   * @inheritDoc
   */
  isActive(htmlString) {
    return googleDocsMatch.test(htmlString);
  }
  /**
   * @inheritDoc
   */
  execute(data) {
    const writer = new UpcastWriter(this.document);
    const { body: documentFragment } = data._parsedData;
    removeBoldWrapper(documentFragment, writer);
    unwrapParagraphInListItem(documentFragment, writer);
    transformBlockBrsToParagraphs(documentFragment, writer);
    data.content = documentFragment;
  }
};

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/removexmlns.js
function removeXmlns(documentFragment, writer) {
  for (const child of documentFragment.getChildren()) {
    if (child.is("element", "table") && child.hasAttribute("xmlns")) {
      writer.removeAttribute("xmlns", child);
    }
  }
}

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/removegooglesheetstag.js
function removeGoogleSheetsTag(documentFragment, writer) {
  for (const child of documentFragment.getChildren()) {
    if (child.is("element", "google-sheets-html-origin")) {
      const childIndex = documentFragment.getChildIndex(child);
      writer.remove(child);
      writer.insertChild(childIndex, child.getChildren(), documentFragment);
    }
  }
}

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/removeinvalidtablewidth.js
function removeInvalidTableWidth(documentFragment, writer) {
  for (const child of documentFragment.getChildren()) {
    if (child.is("element", "table") && child.getStyle("width") === "0px") {
      writer.removeStyle("width", child);
    }
  }
}

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/removestyleblock.js
function removeStyleBlock(documentFragment, writer) {
  for (const child of Array.from(documentFragment.getChildren())) {
    if (child.is("element", "style")) {
      writer.remove(child);
    }
  }
}

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/normalizers/googlesheetsnormalizer.js
var googleSheetsMatch = /<google-sheets-html-origin/i;
var GoogleSheetsNormalizer = class {
  /**
   * Creates a new `GoogleSheetsNormalizer` instance.
   *
   * @param document View document.
   */
  constructor(document2) {
    this.document = document2;
  }
  /**
   * @inheritDoc
   */
  isActive(htmlString) {
    return googleSheetsMatch.test(htmlString);
  }
  /**
   * @inheritDoc
   */
  execute(data) {
    const writer = new UpcastWriter(this.document);
    const { body: documentFragment } = data._parsedData;
    removeGoogleSheetsTag(documentFragment, writer);
    removeXmlns(documentFragment, writer);
    removeInvalidTableWidth(documentFragment, writer);
    removeStyleBlock(documentFragment, writer);
    data.content = documentFragment;
  }
};

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/space.js
function normalizeSpacing(htmlString) {
  return normalizeSafariSpaceSpans(normalizeSafariSpaceSpans(htmlString)).replace(/(<span\s+style=['"]mso-spacerun:yes['"]>[^\S\r\n]*?)[\r\n]+([^\S\r\n]*<\/span>)/g, "$1$2").replace(/<span\s+style=['"]mso-spacerun:yes['"]><\/span>/g, "").replace(/(<span\s+style=['"]letter-spacing:[^'"]+?['"]>)[\r\n]+(<\/span>)/g, "$1 $2").replace(/ <\//g, " </").replace(/ <o:p><\/o:p>/g, " <o:p></o:p>").replace(/<o:p>(&nbsp;|\u00A0)<\/o:p>/g, "").replace(/>([^\S\r\n]*[\r\n]\s*)</g, "><");
}
function normalizeSpacerunSpans(htmlDocument) {
  htmlDocument.querySelectorAll("span[style*=spacerun]").forEach((el) => {
    const htmlElement = el;
    const innerTextLength = htmlElement.innerText.length || 0;
    htmlElement.innerText = Array(innerTextLength + 1).join("  ").substr(0, innerTextLength);
  });
}
function normalizeSafariSpaceSpans(htmlString) {
  return htmlString.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (fullMatch, spaces) => {
    return spaces.length === 1 ? " " : Array(spaces.length + 1).join("  ").substr(0, spaces.length);
  });
}

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/parse.js
function parseHtml(htmlString, stylesProcessor) {
  const domParser = new DOMParser();
  htmlString = htmlString.replace(/<!--\[if gte vml 1]>/g, "");
  htmlString = htmlString.replace(/<o:SmartTagType(?:\s+[^\s>=]+(?:="[^"]*")?)*\s*\/?>/gi, "");
  const normalizedHtml = normalizeSpacing(cleanContentAfterBody(htmlString));
  const htmlDocument = domParser.parseFromString(normalizedHtml, "text/html");
  normalizeSpacerunSpans(htmlDocument);
  const bodyString = htmlDocument.body.innerHTML;
  const bodyView = documentToView(htmlDocument, stylesProcessor);
  const stylesObject = extractStyles(htmlDocument);
  return {
    body: bodyView,
    bodyString,
    styles: stylesObject.styles,
    stylesString: stylesObject.stylesString
  };
}
function documentToView(htmlDocument, stylesProcessor) {
  const viewDocument = new Document(stylesProcessor);
  const domConverter = new DomConverter(viewDocument, { renderingMode: "data" });
  const fragment = htmlDocument.createDocumentFragment();
  const nodes = htmlDocument.body.childNodes;
  while (nodes.length > 0) {
    fragment.appendChild(nodes[0]);
  }
  return domConverter.domToView(fragment, { skipComments: true });
}
function extractStyles(htmlDocument) {
  const styles = [];
  const stylesString = [];
  const styleTags = Array.from(htmlDocument.getElementsByTagName("style"));
  for (const style of styleTags) {
    if (style.sheet && style.sheet.cssRules && style.sheet.cssRules.length) {
      styles.push(style.sheet);
      stylesString.push(style.innerHTML);
    }
  }
  return {
    styles,
    stylesString: stylesString.join(" ")
  };
}
function cleanContentAfterBody(htmlString) {
  const bodyCloseTag = "</body>";
  const htmlCloseTag = "</html>";
  const bodyCloseIndex = htmlString.indexOf(bodyCloseTag);
  if (bodyCloseIndex < 0) {
    return htmlString;
  }
  const htmlCloseIndex = htmlString.indexOf(htmlCloseTag, bodyCloseIndex + bodyCloseTag.length);
  return htmlString.substring(0, bodyCloseIndex + bodyCloseTag.length) + (htmlCloseIndex >= 0 ? htmlString.substring(htmlCloseIndex) : "");
}

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/pastefromoffice.js
var PasteFromOffice = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "PasteFromOffice";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ClipboardPipeline];
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const clipboardPipeline = editor.plugins.get("ClipboardPipeline");
    const viewDocument = editor.editing.view.document;
    const normalizers = [];
    normalizers.push(new MSWordNormalizer(viewDocument));
    normalizers.push(new GoogleDocsNormalizer(viewDocument));
    normalizers.push(new GoogleSheetsNormalizer(viewDocument));
    clipboardPipeline.on("inputTransformation", (evt, data) => {
      if (data._isTransformedWithPasteFromOffice) {
        return;
      }
      const codeBlock = editor.model.document.selection.getFirstPosition().parent;
      if (codeBlock.is("element", "codeBlock")) {
        return;
      }
      const htmlString = data.dataTransfer.getData("text/html");
      const activeNormalizer = normalizers.find((normalizer) => normalizer.isActive(htmlString));
      if (activeNormalizer) {
        if (!data._parsedData) {
          data._parsedData = parseHtml(htmlString, viewDocument.stylesProcessor);
        }
        activeNormalizer.execute(data);
        data._isTransformedWithPasteFromOffice = true;
      }
    }, { priority: "high" });
  }
};
export {
  MSWordNormalizer,
  PasteFromOffice,
  parseHtml
};
/*! Bundled license information:

@ckeditor/ckeditor5-clipboard/src/clipboardobserver.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/utils/plaintexttohtml.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/utils/normalizeclipboarddata.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/utils/viewtoplaintext.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/clipboardmarkersutils.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/clipboardpipeline.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/lineview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore file -- @preserve *)

@ckeditor/ckeditor5-clipboard/src/dragdroptarget.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/dragdropblocktoolbar.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/dragdrop.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/pasteplaintext.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/clipboard.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

ckeditor5/src/clipboard.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/filters/list.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-paste-from-office/src/filters/image.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore else -- @preserve *)

@ckeditor/ckeditor5-paste-from-office/src/filters/removemsattributes.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/normalizers/mswordnormalizer.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/filters/removeboldwrapper.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/filters/br.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/normalizers/googledocsnormalizer.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/filters/removexmlns.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/filters/removegooglesheetstag.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/filters/removeinvalidtablewidth.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/filters/removestyleblock.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/normalizers/googlesheetsnormalizer.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/filters/space.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/filters/parse.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/pastefromoffice.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=@ckeditor_ckeditor5-paste-from-office.js.map
