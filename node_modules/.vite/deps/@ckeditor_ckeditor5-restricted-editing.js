import "./chunk-NICE7ARI.js";
import {
  Matcher
} from "./chunk-X5QTGNDD.js";
import "./chunk-U5S3T6FN.js";
import {
  ButtonView,
  Model,
  addListToDropdown,
  createDropdown
} from "./chunk-2UXKTWKP.js";
import "./chunk-GJCFV3G2.js";
import {
  Collection
} from "./chunk-MFEZX3FO.js";
import {
  Command,
  Plugin
} from "./chunk-YB4X7RFQ.js";
import "./chunk-VMNDBVXW.js";
import "./chunk-LQD6FQVM.js";
import "./chunk-ROME4SDB.js";

// node_modules/@ckeditor/ckeditor5-restricted-editing/src/restrictededitingmodenavigationcommand.js
var RestrictedEditingModeNavigationCommand = class extends Command {
  /**
   * Creates an instance of the command.
   *
   * @param editor The editor instance.
   * @param direction The direction that the command works.
   */
  constructor(editor, direction) {
    super(editor);
    this.affectsData = false;
    this._direction = direction;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    this.isEnabled = this._checkEnabled();
  }
  /**
   * Executes the command.
   *
   * @fires execute
   */
  execute() {
    const position = getNearestExceptionRange(this.editor.model, this._direction);
    if (!position) {
      return;
    }
    this.editor.model.change((writer) => {
      writer.setSelection(position);
    });
  }
  /**
   * Checks whether the command can be enabled in the current context.
   *
   * @returns Whether the command should be enabled.
   */
  _checkEnabled() {
    return !!getNearestExceptionRange(this.editor.model, this._direction);
  }
};
function getNearestExceptionRange(model, direction) {
  const selection = model.document.selection;
  const selectionPosition = selection.getFirstPosition();
  const markerRanges = [];
  for (const marker of model.markers.getMarkersGroup("restrictedEditingException")) {
    const markerRange = marker.getRange();
    const isMarkerRangeTouching = selectionPosition.isTouching(markerRange.start) && selectionPosition.hasSameParentAs(markerRange.start) || selectionPosition.isTouching(markerRange.end) && selectionPosition.hasSameParentAs(markerRange.end);
    if (markerRange.containsPosition(selectionPosition) || isMarkerRangeTouching) {
      continue;
    }
    if (direction === "forward" && markerRange.start.isAfter(selectionPosition)) {
      markerRanges.push(markerRange);
    } else if (direction === "backward" && markerRange.end.isBefore(selectionPosition)) {
      markerRanges.push(markerRange);
    }
  }
  if (!markerRanges.length) {
    return;
  }
  return markerRanges.sort((rangeA, rangeB) => {
    if (direction === "forward") {
      return rangeA.start.isAfter(rangeB.start) ? 1 : -1;
    } else {
      return rangeA.start.isBefore(rangeB.start) ? 1 : -1;
    }
  }).shift();
}

// node_modules/@ckeditor/ckeditor5-restricted-editing/src/restrictededitingmode/utils.js
function getMarkerAtPosition(editor, position) {
  for (const marker of editor.model.markers) {
    const markerRange = marker.getRange();
    if (isPositionInRangeBoundaries(markerRange, position)) {
      if (marker.name.startsWith("restrictedEditingException:")) {
        return marker;
      }
    }
  }
}
function isPositionInRangeBoundaries(range, position) {
  return range.containsPosition(position) || range.end.isEqual(position) || range.start.isEqual(position);
}
function isSelectionInMarker(selection, marker) {
  if (!marker) {
    return false;
  }
  const markerRange = marker.getRange();
  if (selection.isCollapsed) {
    return isPositionInRangeBoundaries(markerRange, selection.focus);
  }
  return markerRange.containsRange(selection.getFirstRange(), true);
}

// node_modules/@ckeditor/ckeditor5-restricted-editing/src/restrictededitingmode/converters.js
var HIGHLIGHT_CLASS = "restricted-editing-exception_selected";
function setupExceptionHighlighting(editor) {
  const view = editor.editing.view;
  const model = editor.model;
  const highlightedMarkers = /* @__PURE__ */ new Set();
  view.document.registerPostFixer((writer) => {
    const modelSelection = model.document.selection;
    const marker = getMarkerAtPosition(editor, modelSelection.anchor);
    if (!marker) {
      return false;
    }
    for (const viewElement of editor.editing.mapper.markerNameToElements(marker.name)) {
      writer.addClass(HIGHLIGHT_CLASS, viewElement);
      highlightedMarkers.add(viewElement);
    }
    return false;
  });
  editor.conversion.for("editingDowncast").add((dispatcher) => {
    dispatcher.on("insert", removeHighlight, { priority: "highest" });
    dispatcher.on("remove", removeHighlight, { priority: "highest" });
    dispatcher.on("attribute", removeHighlight, { priority: "highest" });
    dispatcher.on("cleanSelection", removeHighlight);
    function removeHighlight() {
      view.change((writer) => {
        for (const item of highlightedMarkers.values()) {
          writer.removeClass(HIGHLIGHT_CLASS, item);
          highlightedMarkers.delete(item);
        }
      });
    }
  });
}
function resurrectCollapsedMarkerPostFixer(editor) {
  return (writer) => {
    let changeApplied = false;
    for (const { name, data } of editor.model.document.differ.getChangedMarkers()) {
      if (name.startsWith("restrictedEditingException") && data.newRange && data.newRange.root.rootName == "$graveyard") {
        writer.updateMarker(name, {
          range: writer.createRange(writer.createPositionAt(data.oldRange.start))
        });
        changeApplied = true;
      }
    }
    return changeApplied;
  };
}
function extendMarkerOnTypingPostFixer(editor) {
  return (writer) => {
    let changeApplied = false;
    for (const change of editor.model.document.differ.getChanges()) {
      if (change.type == "insert" && change.name == "$text") {
        changeApplied = _tryExtendMarkerStart(editor, change.position, change.length, writer) || changeApplied;
        changeApplied = _tryExtendMarkedEnd(editor, change.position, change.length, writer) || changeApplied;
      }
    }
    return changeApplied;
  };
}
function upcastHighlightToMarker(config) {
  return (dispatcher) => dispatcher.on("element:span", (evt, data, conversionApi) => {
    const { writer } = conversionApi;
    const matcher = new Matcher(config.view);
    const matcherResult = matcher.match(data.viewItem);
    if (!matcherResult) {
      return;
    }
    const match = matcherResult.match;
    match.name = true;
    const { modelRange: convertedChildrenRange } = conversionApi.convertChildren(data.viewItem, data.modelCursor);
    conversionApi.consumable.consume(data.viewItem, match);
    const markerName = config.model();
    const fakeMarkerStart = writer.createElement("$marker", { "data-name": markerName });
    const fakeMarkerEnd = writer.createElement("$marker", { "data-name": markerName });
    writer.insert(fakeMarkerEnd, convertedChildrenRange.end);
    writer.insert(fakeMarkerStart, convertedChildrenRange.start);
    data.modelRange = writer.createRange(writer.createPositionBefore(fakeMarkerStart), writer.createPositionAfter(fakeMarkerEnd));
    data.modelCursor = data.modelRange.end;
  });
}
function _tryExtendMarkerStart(editor, position, length, writer) {
  const markerAtStart = getMarkerAtPosition(editor, position.getShiftedBy(length));
  if (markerAtStart && markerAtStart.getStart().isEqual(position.getShiftedBy(length))) {
    writer.updateMarker(markerAtStart, {
      range: writer.createRange(markerAtStart.getStart().getShiftedBy(-length), markerAtStart.getEnd())
    });
    return true;
  }
  return false;
}
function _tryExtendMarkedEnd(editor, position, length, writer) {
  const markerAtEnd = getMarkerAtPosition(editor, position);
  if (markerAtEnd && markerAtEnd.getEnd().isEqual(position)) {
    writer.updateMarker(markerAtEnd, {
      range: writer.createRange(markerAtEnd.getStart(), markerAtEnd.getEnd().getShiftedBy(length))
    });
    return true;
  }
  return false;
}

// node_modules/@ckeditor/ckeditor5-restricted-editing/src/restrictededitingmodeediting.js
var COMMAND_FORCE_DISABLE_ID = "RestrictedEditingMode";
var RestrictedEditingModeEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "RestrictedEditingModeEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    editor.config.define("restrictedEditing", {
      allowedCommands: ["bold", "italic", "link", "unlink"],
      allowedAttributes: ["bold", "italic", "linkHref"]
    });
    this._alwaysEnabled = /* @__PURE__ */ new Set(["undo", "redo"]);
    this._allowedInException = /* @__PURE__ */ new Set(["input", "insertText", "delete", "deleteForward"]);
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    const allowedCommands = editor.config.get("restrictedEditing.allowedCommands");
    allowedCommands.forEach((commandName) => this._allowedInException.add(commandName));
    this._setupConversion();
    this._setupCommandsToggling();
    this._setupRestrictions();
    editor.commands.add("goToPreviousRestrictedEditingException", new RestrictedEditingModeNavigationCommand(editor, "backward"));
    editor.commands.add("goToNextRestrictedEditingException", new RestrictedEditingModeNavigationCommand(editor, "forward"));
    editor.keystrokes.set("Tab", getCommandExecuter(editor, "goToNextRestrictedEditingException"));
    editor.keystrokes.set("Shift+Tab", getCommandExecuter(editor, "goToPreviousRestrictedEditingException"));
    editor.keystrokes.set("Ctrl+A", getSelectAllHandler(editor));
    editingView.change((writer) => {
      for (const root of editingView.document.roots) {
        writer.addClass("ck-restricted-editing_mode_restricted", root);
      }
    });
  }
  /**
   * Makes the given command always enabled in the restricted editing mode (regardless
   * of selection location).
   *
   * To enable some commands in non-restricted areas of the content use
   * {@link module:restricted-editing/restrictededitingconfig~RestrictedEditingConfig#allowedCommands} configuration option.
   *
   * @param commandName Name of the command to enable.
   */
  enableCommand(commandName) {
    const command = this.editor.commands.get(commandName);
    command.clearForceDisabled(COMMAND_FORCE_DISABLE_ID);
    this._alwaysEnabled.add(commandName);
  }
  /**
   * Sets up the restricted mode editing conversion:
   *
   * * ucpast & downcast converters,
   * * marker highlighting in the edting area,
   * * marker post-fixers.
   */
  _setupConversion() {
    const editor = this.editor;
    const model = editor.model;
    const doc = model.document;
    let markerNumber = 0;
    editor.conversion.for("upcast").add(upcastHighlightToMarker({
      view: {
        name: "span",
        classes: "restricted-editing-exception"
      },
      model: () => {
        markerNumber++;
        return `restrictedEditingException:${markerNumber}`;
      }
    }));
    editor.conversion.for("downcast").markerToHighlight({
      model: "restrictedEditingException",
      // Use callback to return new object every time new marker instance is created - otherwise it will be seen as the same marker.
      view: () => {
        return {
          name: "span",
          classes: "restricted-editing-exception",
          priority: -10
        };
      }
    });
    editor.conversion.for("editingDowncast").markerToElement({
      model: "restrictedEditingException",
      view: (markerData, { writer }) => {
        return writer.createUIElement("span", {
          class: "restricted-editing-exception restricted-editing-exception_collapsed"
        });
      }
    });
    editor.conversion.for("dataDowncast").markerToElement({
      model: "restrictedEditingException",
      view: (markerData, { writer }) => {
        return writer.createEmptyElement("span", {
          class: "restricted-editing-exception"
        });
      }
    });
    doc.registerPostFixer(extendMarkerOnTypingPostFixer(editor));
    doc.registerPostFixer(resurrectCollapsedMarkerPostFixer(editor));
    doc.registerPostFixer(ensureNewMarkerIsFlatPostFixer(editor));
    setupExceptionHighlighting(editor);
  }
  /**
   * Setups additional editing restrictions beyond command toggling:
   *
   * * delete content range trimming
   * * disabling input command outside exception marker
   * * restricting clipboard holder to text only
   * * restricting text attributes in content
   */
  _setupRestrictions() {
    const editor = this.editor;
    const model = editor.model;
    const selection = model.document.selection;
    const viewDoc = editor.editing.view.document;
    const clipboard = editor.plugins.get("ClipboardPipeline");
    this.listenTo(model, "deleteContent", restrictDeleteContent(editor), { priority: "high" });
    const insertTextCommand = editor.commands.get("insertText");
    if (insertTextCommand) {
      this.listenTo(insertTextCommand, "execute", disallowInputExecForWrongRange(editor), { priority: "high" });
    }
    this.listenTo(clipboard, "contentInsertion", (evt) => {
      if (!isRangeInsideSingleMarker(editor, selection.getFirstRange())) {
        evt.stop();
      }
    });
    this.listenTo(viewDoc, "clipboardOutput", (evt, data) => {
      if (data.method == "cut" && !isRangeInsideSingleMarker(editor, selection.getFirstRange())) {
        evt.stop();
      }
    }, { priority: "high" });
    const allowedAttributes = editor.config.get("restrictedEditing.allowedAttributes");
    model.schema.addAttributeCheck(onlyAllowAttributesFromList(allowedAttributes));
    model.schema.addChildCheck(allowTextOnlyInClipboardHolder());
  }
  /**
   * Sets up the command toggling which enables or disables commands based on the user selection.
   */
  _setupCommandsToggling() {
    const editor = this.editor;
    const model = editor.model;
    const doc = model.document;
    this._disableCommands();
    this.listenTo(doc.selection, "change", this._checkCommands.bind(this));
    this.listenTo(doc, "change:data", this._checkCommands.bind(this));
  }
  /**
   * Checks if commands should be enabled or disabled based on the current selection.
   */
  _checkCommands() {
    const editor = this.editor;
    const selection = editor.model.document.selection;
    if (selection.rangeCount > 1) {
      this._disableCommands();
      return;
    }
    const marker = getMarkerAtPosition(editor, selection.focus);
    this._disableCommands();
    if (isSelectionInMarker(selection, marker)) {
      this._enableCommands(marker);
    }
  }
  /**
   * Enables commands in non-restricted regions.
   */
  _enableCommands(marker) {
    const editor = this.editor;
    for (const [commandName, command] of editor.commands) {
      if (!command.affectsData || this._alwaysEnabled.has(commandName)) {
        continue;
      }
      if (!this._allowedInException.has(commandName)) {
        continue;
      }
      if (isDeleteCommandOnMarkerBoundaries(commandName, editor.model.document.selection, marker.getRange())) {
        continue;
      }
      command.clearForceDisabled(COMMAND_FORCE_DISABLE_ID);
    }
  }
  /**
   * Disables commands outside non-restricted regions.
   */
  _disableCommands() {
    const editor = this.editor;
    for (const [commandName, command] of editor.commands) {
      if (!command.affectsData || this._alwaysEnabled.has(commandName)) {
        continue;
      }
      command.forceDisabled(COMMAND_FORCE_DISABLE_ID);
    }
  }
};
function getCommandExecuter(editor, commandName) {
  return (_, cancel) => {
    const command = editor.commands.get(commandName);
    if (command.isEnabled) {
      editor.execute(commandName);
      cancel();
    }
  };
}
function getSelectAllHandler(editor) {
  return (_, cancel) => {
    const model = editor.model;
    const selection = editor.model.document.selection;
    const marker = getMarkerAtPosition(editor, selection.focus);
    if (!marker) {
      return;
    }
    const selectionRange = selection.getFirstRange();
    const markerRange = marker.getRange();
    if (markerRange.containsRange(selectionRange, true) || selection.isCollapsed) {
      cancel();
      model.change((writer) => {
        writer.setSelection(marker.getRange());
      });
    }
  };
}
function isDeleteCommandOnMarkerBoundaries(commandName, selection, markerRange) {
  if (commandName == "delete" && markerRange.start.isEqual(selection.focus)) {
    return true;
  }
  if (commandName == "deleteForward" && selection.isCollapsed && markerRange.end.isEqual(selection.focus)) {
    return true;
  }
  return false;
}
function restrictDeleteContent(editor) {
  return (evt, args) => {
    const [selection] = args;
    const marker = getMarkerAtPosition(editor, selection.focus) || getMarkerAtPosition(editor, selection.anchor);
    if (!marker) {
      evt.stop();
      return;
    }
    if (selection.isCollapsed) {
      return;
    }
    const allowedToDelete = marker.getRange().getIntersection(selection.getFirstRange());
    if (selection.is("documentSelection")) {
      editor.model.change((writer) => {
        writer.setSelection(allowedToDelete);
      });
    } else {
      selection.setTo(allowedToDelete);
    }
  };
}
function disallowInputExecForWrongRange(editor) {
  return (evt, args) => {
    const [options] = args;
    const { range } = options;
    if (!range) {
      return;
    }
    if (!isRangeInsideSingleMarker(editor, range)) {
      evt.stop();
    }
  };
}
function isRangeInsideSingleMarker(editor, range) {
  const markerAtStart = getMarkerAtPosition(editor, range.start);
  const markerAtEnd = getMarkerAtPosition(editor, range.end);
  return markerAtStart && markerAtEnd && markerAtEnd === markerAtStart;
}
function ensureNewMarkerIsFlatPostFixer(editor) {
  return (writer) => {
    let changeApplied = false;
    const changedMarkers = editor.model.document.differ.getChangedMarkers();
    for (const { data, name } of changedMarkers) {
      if (!name.startsWith("restrictedEditingException")) {
        continue;
      }
      const newRange = data.newRange;
      if (!data.oldRange && !newRange.isFlat) {
        const start = newRange.start;
        const end = newRange.end;
        const startIsHigherInTree = start.path.length > end.path.length;
        const fixedStart = startIsHigherInTree ? newRange.start : writer.createPositionAt(end.parent, 0);
        const fixedEnd = startIsHigherInTree ? writer.createPositionAt(start.parent, "end") : newRange.end;
        writer.updateMarker(name, {
          range: writer.createRange(fixedStart, fixedEnd)
        });
        changeApplied = true;
      }
    }
    return changeApplied;
  };
}
function onlyAllowAttributesFromList(allowedAttributes) {
  return (context, attributeName) => {
    if (context.startsWith("$clipboardHolder")) {
      return allowedAttributes.includes(attributeName);
    }
  };
}
function allowTextOnlyInClipboardHolder() {
  return (context, childDefinition) => {
    if (context.startsWith("$clipboardHolder")) {
      return childDefinition.name === "$text";
    }
  };
}

// node_modules/@ckeditor/ckeditor5-restricted-editing/src/restrictededitingmodeui.js
import lockIcon from "/var/www/html/manorama/node_modules/@ckeditor/ckeditor5-restricted-editing/theme/icons/contentlock.svg";
var RestrictedEditingModeUI = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "RestrictedEditingModeUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const t = editor.t;
    editor.ui.componentFactory.add("restrictedEditing", (locale) => {
      const dropdownView = createDropdown(locale);
      const listItems = new Collection();
      listItems.add(this._getButtonDefinition("goToPreviousRestrictedEditingException", t("Previous editable region"), "Shift+Tab"));
      listItems.add(this._getButtonDefinition("goToNextRestrictedEditingException", t("Next editable region"), "Tab"));
      addListToDropdown(dropdownView, listItems);
      dropdownView.buttonView.set({
        label: t("Navigate editable regions"),
        icon: lockIcon,
        tooltip: true,
        isEnabled: true,
        isOn: false
      });
      this.listenTo(dropdownView, "execute", (evt) => {
        const { _commandName } = evt.source;
        editor.execute(_commandName);
        editor.editing.view.focus();
      });
      return dropdownView;
    });
  }
  /**
       * Returns a definition of the navigation button to be used in the dropdown.
  
       * @param commandName The name of the command that the button represents.
       * @param label The translated label of the button.
       * @param keystroke The button keystroke.
       */
  _getButtonDefinition(commandName, label, keystroke) {
    const editor = this.editor;
    const command = editor.commands.get(commandName);
    const definition = {
      type: "button",
      model: new Model({
        label,
        withText: true,
        keystroke,
        withKeystroke: true,
        _commandName: commandName
      })
    };
    definition.model.bind("isEnabled").to(command, "isEnabled");
    return definition;
  }
};

// node_modules/@ckeditor/ckeditor5-restricted-editing/src/restrictededitingmode.js
import "/var/www/html/manorama/node_modules/@ckeditor/ckeditor5-restricted-editing/theme/restrictedediting.css";
var RestrictedEditingMode = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "RestrictedEditingMode";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [RestrictedEditingModeEditing, RestrictedEditingModeUI];
  }
};

// node_modules/@ckeditor/ckeditor5-restricted-editing/src/restrictededitingexceptioncommand.js
var RestrictedEditingExceptionCommand = class extends Command {
  /**
   * @inheritDoc
   */
  refresh() {
    const model = this.editor.model;
    const doc = model.document;
    this.value = !!doc.selection.getAttribute("restrictedEditingException");
    this.isEnabled = model.schema.checkAttributeInSelection(doc.selection, "restrictedEditingException");
  }
  /**
   * @inheritDoc
   */
  execute(options = {}) {
    const model = this.editor.model;
    const document = model.document;
    const selection = document.selection;
    const valueToSet = options.forceValue === void 0 ? !this.value : options.forceValue;
    model.change((writer) => {
      const ranges = model.schema.getValidRanges(selection.getRanges(), "restrictedEditingException");
      if (selection.isCollapsed) {
        if (valueToSet) {
          writer.setSelectionAttribute("restrictedEditingException", valueToSet);
        } else {
          const isSameException = (value) => {
            return value.item.getAttribute("restrictedEditingException") === this.value;
          };
          const focus = selection.focus;
          const exceptionStart = focus.getLastMatchingPosition(isSameException, { direction: "backward" });
          const exceptionEnd = focus.getLastMatchingPosition(isSameException);
          writer.removeSelectionAttribute("restrictedEditingException");
          if (!(focus.isEqual(exceptionStart) || focus.isEqual(exceptionEnd))) {
            writer.removeAttribute("restrictedEditingException", writer.createRange(exceptionStart, exceptionEnd));
          }
        }
      } else {
        for (const range of ranges) {
          if (valueToSet) {
            writer.setAttribute("restrictedEditingException", valueToSet, range);
          } else {
            writer.removeAttribute("restrictedEditingException", range);
          }
        }
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-restricted-editing/src/standardeditingmodeediting.js
var StandardEditingModeEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "StandardEditingModeEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    editor.model.schema.extend("$text", { allowAttributes: ["restrictedEditingException"] });
    editor.conversion.for("upcast").elementToAttribute({
      model: "restrictedEditingException",
      view: {
        name: "span",
        classes: "restricted-editing-exception"
      }
    });
    editor.conversion.for("downcast").attributeToElement({
      model: "restrictedEditingException",
      view: (modelAttributeValue, { writer }) => {
        if (modelAttributeValue) {
          return writer.createAttributeElement("span", { class: "restricted-editing-exception" }, { priority: -10 });
        }
      }
    });
    editor.commands.add("restrictedEditingException", new RestrictedEditingExceptionCommand(editor));
    editor.editing.view.change((writer) => {
      for (const root of editor.editing.view.document.roots) {
        writer.addClass("ck-restricted-editing_mode_standard", root);
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-restricted-editing/src/standardeditingmodeui.js
import unlockIcon from "/var/www/html/manorama/node_modules/@ckeditor/ckeditor5-restricted-editing/theme/icons/contentunlock.svg";
var StandardEditingModeUI = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "StandardEditingModeUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const t = editor.t;
    editor.ui.componentFactory.add("restrictedEditingException", (locale) => {
      const command = editor.commands.get("restrictedEditingException");
      const view = new ButtonView(locale);
      view.set({
        icon: unlockIcon,
        tooltip: true,
        isToggleable: true
      });
      view.bind("isOn", "isEnabled").to(command, "value", "isEnabled");
      view.bind("label").to(command, "value", (value) => {
        return value ? t("Disable editing") : t("Enable editing");
      });
      this.listenTo(view, "execute", () => {
        editor.execute("restrictedEditingException");
        editor.editing.view.focus();
      });
      return view;
    });
  }
};

// node_modules/@ckeditor/ckeditor5-restricted-editing/src/standardeditingmode.js
import "/var/www/html/manorama/node_modules/@ckeditor/ckeditor5-restricted-editing/theme/restrictedediting.css";
var StandardEditingMode = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "StandardEditingMode";
  }
  static get requires() {
    return [StandardEditingModeEditing, StandardEditingModeUI];
  }
};
export {
  RestrictedEditingMode,
  RestrictedEditingModeEditing,
  RestrictedEditingModeUI,
  StandardEditingMode,
  StandardEditingModeEditing,
  StandardEditingModeUI
};
/*! Bundled license information:

@ckeditor/ckeditor5-restricted-editing/src/restrictededitingmodenavigationcommand.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-restricted-editing/src/restrictededitingmode/utils.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-restricted-editing/src/restrictededitingmode/converters.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-restricted-editing/src/restrictededitingmodeediting.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-restricted-editing/src/restrictededitingmodeui.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-restricted-editing/src/restrictededitingmode.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-restricted-editing/src/restrictededitingexceptioncommand.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-restricted-editing/src/standardeditingmodeediting.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-restricted-editing/src/standardeditingmodeui.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-restricted-editing/src/standardeditingmode.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-restricted-editing/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-restricted-editing/src/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=@ckeditor_ckeditor5-restricted-editing.js.map
