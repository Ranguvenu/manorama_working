{
  "version": 3,
  "sources": ["../../ckeditor5/node_modules/@ckeditor/ckeditor5-clipboard/src/clipboardobserver.js", "../../ckeditor5/node_modules/@ckeditor/ckeditor5-clipboard/src/utils/plaintexttohtml.js", "../../ckeditor5/node_modules/@ckeditor/ckeditor5-clipboard/src/utils/normalizeclipboarddata.js", "../../ckeditor5/node_modules/@ckeditor/ckeditor5-clipboard/src/utils/viewtoplaintext.js", "../../ckeditor5/node_modules/@ckeditor/ckeditor5-clipboard/src/clipboardmarkersutils.js", "../../ckeditor5/node_modules/@ckeditor/ckeditor5-clipboard/src/clipboardpipeline.js", "../../ckeditor5/node_modules/@ckeditor/ckeditor5-clipboard/src/lineview.js", "../../ckeditor5/node_modules/@ckeditor/ckeditor5-clipboard/src/dragdrop.js", "../../@ckeditor/ckeditor5-paste-from-office/src/filters/list.js", "../../@ckeditor/ckeditor5-paste-from-office/src/filters/image.js", "../../@ckeditor/ckeditor5-paste-from-office/src/filters/removemsattributes.js", "../../@ckeditor/ckeditor5-paste-from-office/src/normalizers/mswordnormalizer.js", "../../@ckeditor/ckeditor5-paste-from-office/src/filters/removeboldwrapper.js", "../../@ckeditor/ckeditor5-paste-from-office/src/filters/br.js", "../../@ckeditor/ckeditor5-paste-from-office/src/normalizers/googledocsnormalizer.js", "../../@ckeditor/ckeditor5-paste-from-office/src/filters/removexmlns.js", "../../@ckeditor/ckeditor5-paste-from-office/src/filters/removegooglesheetstag.js", "../../@ckeditor/ckeditor5-paste-from-office/src/filters/removeinvalidtablewidth.js", "../../@ckeditor/ckeditor5-paste-from-office/src/filters/removestyleblock.js", "../../@ckeditor/ckeditor5-paste-from-office/src/normalizers/googlesheetsnormalizer.js", "../../@ckeditor/ckeditor5-paste-from-office/src/filters/space.js", "../../@ckeditor/ckeditor5-paste-from-office/src/filters/parse.js", "../../@ckeditor/ckeditor5-paste-from-office/src/pastefromoffice.js"],
  "sourcesContent": ["/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module clipboard/clipboardobserver\n */\nimport { EventInfo } from '@ckeditor/ckeditor5-utils';\nimport { DataTransfer, DomEventObserver } from '@ckeditor/ckeditor5-engine';\n/**\n * Clipboard events observer.\n *\n * Fires the following events:\n *\n * * {@link module:engine/view/document~Document#event:clipboardInput},\n * * {@link module:engine/view/document~Document#event:paste},\n * * {@link module:engine/view/document~Document#event:copy},\n * * {@link module:engine/view/document~Document#event:cut},\n * * {@link module:engine/view/document~Document#event:drop},\n * * {@link module:engine/view/document~Document#event:dragover},\n * * {@link module:engine/view/document~Document#event:dragging},\n * * {@link module:engine/view/document~Document#event:dragstart},\n * * {@link module:engine/view/document~Document#event:dragend},\n * * {@link module:engine/view/document~Document#event:dragenter},\n * * {@link module:engine/view/document~Document#event:dragleave}.\n *\n * **Note**: This observer is not available by default (ckeditor5-engine does not add it on its own).\n * To make it available, it needs to be added to {@link module:engine/view/document~Document} by using\n * the {@link module:engine/view/view~View#addObserver `View#addObserver()`} method. Alternatively, you can load the\n * {@link module:clipboard/clipboard~Clipboard} plugin which adds this observer automatically (because it uses it).\n */\nexport default class ClipboardObserver extends DomEventObserver {\n    constructor(view) {\n        super(view);\n        this.domEventType = [\n            'paste', 'copy', 'cut', 'drop', 'dragover', 'dragstart', 'dragend', 'dragenter', 'dragleave'\n        ];\n        const viewDocument = this.document;\n        this.listenTo(viewDocument, 'paste', handleInput('clipboardInput'), { priority: 'low' });\n        this.listenTo(viewDocument, 'drop', handleInput('clipboardInput'), { priority: 'low' });\n        this.listenTo(viewDocument, 'dragover', handleInput('dragging'), { priority: 'low' });\n        function handleInput(type) {\n            return (evt, data) => {\n                data.preventDefault();\n                const targetRanges = data.dropRange ? [data.dropRange] : null;\n                const eventInfo = new EventInfo(viewDocument, type);\n                viewDocument.fire(eventInfo, {\n                    dataTransfer: data.dataTransfer,\n                    method: evt.name,\n                    targetRanges,\n                    target: data.target,\n                    domEvent: data.domEvent\n                });\n                // If CKEditor handled the input, do not bubble the original event any further.\n                // This helps external integrations recognize that fact and act accordingly.\n                // https://github.com/ckeditor/ckeditor5-upload/issues/92\n                if (eventInfo.stop.called) {\n                    data.stopPropagation();\n                }\n            };\n        }\n    }\n    onDomEvent(domEvent) {\n        const nativeDataTransfer = 'clipboardData' in domEvent ? domEvent.clipboardData : domEvent.dataTransfer;\n        const cacheFiles = domEvent.type == 'drop' || domEvent.type == 'paste';\n        const evtData = {\n            dataTransfer: new DataTransfer(nativeDataTransfer, { cacheFiles })\n        };\n        if (domEvent.type == 'drop' || domEvent.type == 'dragover') {\n            evtData.dropRange = getDropViewRange(this.view, domEvent);\n        }\n        this.fire(domEvent.type, domEvent, evtData);\n    }\n}\nfunction getDropViewRange(view, domEvent) {\n    const domDoc = domEvent.target.ownerDocument;\n    const x = domEvent.clientX;\n    const y = domEvent.clientY;\n    let domRange;\n    // Webkit & Blink.\n    if (domDoc.caretRangeFromPoint && domDoc.caretRangeFromPoint(x, y)) {\n        domRange = domDoc.caretRangeFromPoint(x, y);\n    }\n    // FF.\n    else if (domEvent.rangeParent) {\n        domRange = domDoc.createRange();\n        domRange.setStart(domEvent.rangeParent, domEvent.rangeOffset);\n        domRange.collapse(true);\n    }\n    if (domRange) {\n        return view.domConverter.domRangeToView(domRange);\n    }\n    return null;\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module clipboard/utils/plaintexttohtml\n */\n/**\n * Converts plain text to its HTML-ized version.\n *\n * @param text The plain text to convert.\n * @returns HTML generated from the plain text.\n */\nexport default function plainTextToHtml(text) {\n    text = text\n        // Encode &.\n        .replace(/&/g, '&amp;')\n        // Encode <>.\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        // Creates a paragraph for each double line break.\n        .replace(/\\r?\\n\\r?\\n/g, '</p><p>')\n        // Creates a line break for each single line break.\n        .replace(/\\r?\\n/g, '<br>')\n        // Replace tabs with four spaces.\n        .replace(/\\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;')\n        // Preserve trailing spaces (only the first and last one – the rest is handled below).\n        .replace(/^\\s/, '&nbsp;')\n        .replace(/\\s$/, '&nbsp;')\n        // Preserve other subsequent spaces now.\n        .replace(/\\s\\s/g, ' &nbsp;');\n    if (text.includes('</p><p>') || text.includes('<br>')) {\n        // If we created paragraphs above, add the trailing ones.\n        text = `<p>${text}</p>`;\n    }\n    // TODO:\n    // * What about '\\nfoo' vs ' foo'?\n    return text;\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module clipboard/utils/normalizeclipboarddata\n */\n/**\n * Removes some popular browser quirks out of the clipboard data (HTML).\n * Removes all HTML comments. These are considered an internal thing and it makes little sense if they leak into the editor data.\n *\n * @param data The HTML data to normalize.\n * @returns Normalized HTML.\n */\nexport default function normalizeClipboardData(data) {\n    return data\n        .replace(/<span(?: class=\"Apple-converted-space\"|)>(\\s+)<\\/span>/g, (fullMatch, spaces) => {\n        // Handle the most popular and problematic case when even a single space becomes an nbsp;.\n        // Decode those to normal spaces. Read more in https://github.com/ckeditor/ckeditor5-clipboard/issues/2.\n        if (spaces.length == 1) {\n            return ' ';\n        }\n        return spaces;\n    })\n        // Remove all HTML comments.\n        .replace(/<!--[\\s\\S]*?-->/g, '');\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n// Elements which should not have empty-line padding.\n// Most `view.ContainerElement` want to be separate by new-line, but some are creating one structure\n// together (like `<li>`) so it is better to separate them by only one \"\\n\".\nconst smallPaddingElements = ['figcaption', 'li'];\nconst listElements = ['ol', 'ul'];\n/**\n * Converts {@link module:engine/view/item~Item view item} and all of its children to plain text.\n *\n * @param viewItem View item to convert.\n * @returns Plain text representation of `viewItem`.\n */\nexport default function viewToPlainText(viewItem) {\n    if (viewItem.is('$text') || viewItem.is('$textProxy')) {\n        return viewItem.data;\n    }\n    if (viewItem.is('element', 'img') && viewItem.hasAttribute('alt')) {\n        return viewItem.getAttribute('alt');\n    }\n    if (viewItem.is('element', 'br')) {\n        return '\\n'; // Convert soft breaks to single line break (#8045).\n    }\n    /**\n     * Item is a document fragment, attribute element or container element. It doesn't\n     * have it's own text value, so we need to convert its children elements.\n     */\n    let text = '';\n    let prev = null;\n    for (const child of viewItem.getChildren()) {\n        text += newLinePadding(child, prev) + viewToPlainText(child);\n        prev = child;\n    }\n    return text;\n}\n/**\n * Returns new line padding to prefix the given elements with.\n */\nfunction newLinePadding(element, previous) {\n    if (!previous) {\n        // Don't add padding to first elements in a level.\n        return '';\n    }\n    if (element.is('element', 'li') && !element.isEmpty && element.getChild(0).is('containerElement')) {\n        // Separate document list items with empty lines.\n        return '\\n\\n';\n    }\n    if (listElements.includes(element.name) && listElements.includes(previous.name)) {\n        /**\n         * Because `<ul>` and `<ol>` are AttributeElements, two consecutive lists will not have any padding between\n         * them (see the `if` statement below). To fix this, we need to make an exception for this case.\n         */\n        return '\\n\\n';\n    }\n    if (!element.is('containerElement') && !previous.is('containerElement')) {\n        // Don't add padding between non-container elements.\n        return '';\n    }\n    if (smallPaddingElements.includes(element.name) || smallPaddingElements.includes(previous.name)) {\n        // Add small padding between selected container elements.\n        return '\\n';\n    }\n    // Add empty lines between container elements.\n    return '\\n\\n';\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module clipboard/clipboardmarkersutils\n */\nimport { mapValues } from 'lodash-es';\nimport { uid } from '@ckeditor/ckeditor5-utils';\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport { Range } from '@ckeditor/ckeditor5-engine';\n/**\n * Part of the clipboard logic. Responsible for collecting markers from selected fragments\n * and restoring them with proper positions in pasted elements.\n *\n * @internal\n */\nexport default class ClipboardMarkersUtils extends Plugin {\n    constructor() {\n        super(...arguments);\n        /**\n         * Map of marker names that can be copied.\n         *\n         * @internal\n         */\n        this._markersToCopy = new Map();\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'ClipboardMarkersUtils';\n    }\n    /**\n     * Registers marker name as copyable in clipboard pipeline.\n     *\n     * @param markerName Name of marker that can be copied.\n     * @param restrictions Preset or specified array of actions that can be performed on specified marker name.\n     * @internal\n     */\n    _registerMarkerToCopy(markerName, restrictions) {\n        const allowedActions = Array.isArray(restrictions) ? restrictions : this._mapRestrictionPresetToActions(restrictions);\n        if (allowedActions.length) {\n            this._markersToCopy.set(markerName, allowedActions);\n        }\n    }\n    /**\n     * Maps preset into array of clipboard operations to be allowed on marker.\n     *\n     * @param preset Restrictions preset to be mapped to actions\n     * @internal\n     */\n    _mapRestrictionPresetToActions(preset) {\n        switch (preset) {\n            case 'always':\n                return ['copy', 'cut', 'dragstart'];\n            case 'default':\n                return ['cut', 'dragstart'];\n            case 'never':\n                return [];\n            default: {\n                // Skip unrecognized type.\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const unreachable = preset;\n                return [];\n            }\n        }\n    }\n    /**\n     * Performs copy markers on provided selection and paste it to fragment returned from `getCopiedFragment`.\n     *\n     * \t1. Picks all markers in provided selection.\n     * \t2. Inserts fake markers to document.\n     * \t3. Gets copied selection fragment from document.\n     * \t4. Removes fake elements from fragment and document.\n     * \t5. Inserts markers in the place of removed fake markers.\n     *\n     * Due to selection modification, when inserting items, `getCopiedFragment` must *always* operate on `writer.model.document.selection'.\n     * Do not use any other custom selection object within callback, as this will lead to out-of-bounds exceptions in rare scenarios.\n     *\n     * @param action Type of clipboard action.\n     * @param writer An instance of the model writer.\n     * @param selection Selection to be checked.\n     * @param getCopiedFragment\tCallback that performs copy of selection and returns it as fragment.\n     * @internal\n     */\n    _copySelectedFragmentWithMarkers(action, selection, getCopiedFragment = writer => writer.model.getSelectedContent(writer.model.document.selection)) {\n        return this.editor.model.change(writer => {\n            const oldSelection = writer.model.document.selection;\n            // In some scenarios, such like in drag & drop, passed `selection` parameter is not actually\n            // the same `selection` as the `writer.model.document.selection` which means that `_insertFakeMarkersToSelection`\n            // is not affecting passed `selection` `start` and `end` positions but rather modifies `writer.model.document.selection`.\n            //\n            // It is critical due to fact that when we have selection that starts [ 0, 0 ] and ends at [ 1, 0 ]\n            // and after inserting fake marker it will point to such marker instead of new widget position at start: [ 1, 0 ] end: [2, 0 ].\n            // `writer.insert` modifies only original `writer.model.document.selection`.\n            writer.setSelection(selection);\n            const sourceSelectionInsertedMarkers = this._insertFakeMarkersIntoSelection(writer, writer.model.document.selection, action);\n            const fragment = getCopiedFragment(writer);\n            const fakeMarkersRangesInsideRange = this._removeFakeMarkersInsideElement(writer, fragment);\n            // <fake-marker> [Foo] Bar</fake-marker>\n            //      ^                    ^\n            // In `_insertFakeMarkersIntoSelection` call we inserted fake marker just before first element.\n            // The problem is that the first element can be start position of selection so insertion fake-marker\n            // before such element shifts selection (so selection that was at [0, 0] now is at [0, 1]).\n            // It means that inserted fake-marker is no longer present inside such selection and is orphaned.\n            // This function checks special case of such problem. Markers that are orphaned at the start position\n            // and end position in the same time. Basically it means that they overlaps whole element.\n            for (const [markerName, elements] of Object.entries(sourceSelectionInsertedMarkers)) {\n                fakeMarkersRangesInsideRange[markerName] || (fakeMarkersRangesInsideRange[markerName] = writer.createRangeIn(fragment));\n                for (const element of elements) {\n                    writer.remove(element);\n                }\n            }\n            fragment.markers.clear();\n            for (const [markerName, range] of Object.entries(fakeMarkersRangesInsideRange)) {\n                fragment.markers.set(markerName, range);\n            }\n            // Revert back selection to previous one.\n            writer.setSelection(oldSelection);\n            return fragment;\n        });\n    }\n    /**\n     * Performs paste of markers on already pasted element.\n     *\n     * \t1. Inserts fake markers that are present in fragment element (such fragment will be processed in `getPastedDocumentElement`).\n     * \t2. Calls `getPastedDocumentElement` and gets element that is inserted into root model.\n     * \t3. Removes all fake markers present in transformed element.\n     * \t4. Inserts new markers with removed fake markers ranges into pasted fragment.\n     *\n     * There are multiple edge cases that have to be considered before calling this function:\n     *\n     * \t* `markers` are inserted into the same element that must be later transformed inside `getPastedDocumentElement`.\n     * \t* Fake marker elements inside `getPastedDocumentElement` can be cloned, but their ranges cannot overlap.\n     *\n     * @param action Type of clipboard action.\n     * @param markers Object that maps marker name to corresponding range.\n     * @param getPastedDocumentElement Getter used to get target markers element.\n     * @internal\n     */\n    _pasteMarkersIntoTransformedElement(markers, getPastedDocumentElement) {\n        const copyableMarkers = this._getCopyableMarkersFromRangeMap(markers);\n        return this.editor.model.change(writer => {\n            const sourceFragmentFakeMarkers = this._insertFakeMarkersElements(writer, copyableMarkers);\n            const transformedElement = getPastedDocumentElement(writer);\n            const removedFakeMarkers = this._removeFakeMarkersInsideElement(writer, transformedElement);\n            // Cleanup fake markers inserted into transformed element.\n            for (const element of Object.values(sourceFragmentFakeMarkers).flat()) {\n                writer.remove(element);\n            }\n            for (const [markerName, range] of Object.entries(removedFakeMarkers)) {\n                const uniqueName = writer.model.markers.has(markerName) ? this._getUniqueMarkerName(markerName) : markerName;\n                writer.addMarker(uniqueName, {\n                    usingOperation: true,\n                    affectsData: true,\n                    range\n                });\n            }\n            return transformedElement;\n        });\n    }\n    /**\n     * In some situations we have to perform copy on selected fragment with certain markers. This function allows to temporarily bypass\n     * restrictions on markers that we want to copy.\n     *\n     * This function executes `executor()` callback. For the duration of the callback, if the clipboard pipeline is used to copy\n     * content, markers with the specified name will be copied to the clipboard as well.\n     *\n     * @param markerName Which markers should be copied.\n     * @param executor Callback executed.\n     * @internal\n     */\n    _forceMarkersCopy(markerName, executor) {\n        const before = this._markersToCopy.get(markerName);\n        this._markersToCopy.set(markerName, this._mapRestrictionPresetToActions('always'));\n        executor();\n        if (before) {\n            this._markersToCopy.set(markerName, before);\n        }\n        else {\n            this._markersToCopy.delete(markerName);\n        }\n    }\n    /**\n     * Checks if marker can be copied.\n     *\n     * @param markerName Name of checked marker.\n     * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.\n     * @internal\n     */\n    _canPerformMarkerClipboardAction(markerName, action) {\n        const [markerNamePrefix] = markerName.split(':');\n        if (!action) {\n            return this._markersToCopy.has(markerNamePrefix);\n        }\n        const possibleActions = this._markersToCopy.get(markerNamePrefix) || [];\n        return possibleActions.includes(action);\n    }\n    /**\n     * Changes marker names for markers stored in given document fragment so that they are unique.\n     *\n     * @param fragment\n     * @internal\n     */\n    _setUniqueMarkerNamesInFragment(fragment) {\n        const markers = Array.from(fragment.markers);\n        fragment.markers.clear();\n        for (const [name, range] of markers) {\n            const newName = this._canPerformMarkerClipboardAction(name, null) ? this._getUniqueMarkerName(name) : name;\n            fragment.markers.set(newName, range);\n        }\n    }\n    /**\n     * First step of copying markers. It looks for markers intersecting with given selection and inserts `$marker` elements\n     * at positions where document markers start or end. This way `$marker` elements can be easily copied together with\n     * the rest of the content of the selection.\n     *\n     * @param writer An instance of the model writer.\n     * @param selection Selection to be checked.\n     * @param action Type of clipboard action.\n     */\n    _insertFakeMarkersIntoSelection(writer, selection, action) {\n        const copyableMarkers = this._getCopyableMarkersFromSelection(writer, selection, action);\n        return this._insertFakeMarkersElements(writer, copyableMarkers);\n    }\n    /**\n     * Returns array of markers that can be copied in specified selection.\n     *\n     * @param writer An instance of the model writer.\n     * @param selection  Selection which will be checked.\n     * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.\n     */\n    _getCopyableMarkersFromSelection(writer, selection, action) {\n        return Array\n            .from(selection.getRanges())\n            .flatMap(selectionRange => Array.from(writer.model.markers.getMarkersIntersectingRange(selectionRange)))\n            .filter(marker => this._canPerformMarkerClipboardAction(marker.name, action))\n            .map((marker) => ({\n            name: marker.name,\n            range: marker.getRange()\n        }));\n    }\n    /**\n     * Picks all markers from markers map that can be copied.\n     *\n     * @param markers Object that maps marker name to corresponding range.\n     * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.\n     */\n    _getCopyableMarkersFromRangeMap(markers, action = null) {\n        const entries = markers instanceof Map ? Array.from(markers.entries()) : Object.entries(markers);\n        return entries\n            .map(([markerName, range]) => ({\n            name: markerName,\n            range\n        }))\n            .filter(marker => this._canPerformMarkerClipboardAction(marker.name, action));\n    }\n    /**\n     * Inserts specified array of fake markers elements to document and assigns them `type` and `name` attributes.\n     * Fake markers elements are used to calculate position of markers on pasted fragment that were transformed during\n     * steps between copy and paste.\n     *\n     * @param writer An instance of the model writer.\n     * @param markers Array of markers that will be inserted.\n     */\n    _insertFakeMarkersElements(writer, markers) {\n        const mappedMarkers = {};\n        const sortedMarkers = markers\n            .flatMap(marker => {\n            const { start, end } = marker.range;\n            return [\n                { position: start, marker, type: 'start' },\n                { position: end, marker, type: 'end' }\n            ];\n        })\n            // Markers position is sorted backwards to ensure that the insertion of fake markers will not change\n            // the position of the next markers.\n            .sort(({ position: posA }, { position: posB }) => posA.isBefore(posB) ? 1 : -1);\n        for (const { position, marker, type } of sortedMarkers) {\n            const fakeMarker = writer.createElement('$marker', {\n                'data-name': marker.name,\n                'data-type': type\n            });\n            if (!mappedMarkers[marker.name]) {\n                mappedMarkers[marker.name] = [];\n            }\n            mappedMarkers[marker.name].push(fakeMarker);\n            writer.insert(fakeMarker, position);\n        }\n        return mappedMarkers;\n    }\n    /**\n     * Removes all `$marker` elements from the given document fragment.\n     *\n     * Returns an object where keys are marker names, and values are ranges corresponding to positions\n     * where `$marker` elements were inserted.\n     *\n     * If the document fragment had only one `$marker` element for given marker (start or end) the other boundary is set automatically\n     * (to the end or start of the document fragment, respectively).\n     *\n     * @param writer An instance of the model writer.\n     * @param rootElement The element to be checked.\n     */\n    _removeFakeMarkersInsideElement(writer, rootElement) {\n        const fakeMarkersElements = this._getAllFakeMarkersFromElement(writer, rootElement);\n        const fakeMarkersRanges = fakeMarkersElements.reduce((acc, fakeMarker) => {\n            const position = fakeMarker.markerElement && writer.createPositionBefore(fakeMarker.markerElement);\n            let prevFakeMarker = acc[fakeMarker.name];\n            // Handle scenario when tables clone cells with the same fake node. Example:\n            //\n            // <cell><fake-marker-a></cell> <cell><fake-marker-a></cell> <cell><fake-marker-a></cell>\n            //                                          ^ cloned                    ^ cloned\n            //\n            // The easiest way to bypass this issue is to rename already existing in map nodes and\n            // set them new unique name.\n            if (prevFakeMarker && prevFakeMarker.start && prevFakeMarker.end) {\n                acc[this._getUniqueMarkerName(fakeMarker.name)] = acc[fakeMarker.name];\n                prevFakeMarker = null;\n            }\n            acc[fakeMarker.name] = {\n                ...prevFakeMarker,\n                [fakeMarker.type]: position\n            };\n            if (fakeMarker.markerElement) {\n                writer.remove(fakeMarker.markerElement);\n            }\n            return acc;\n        }, {});\n        // We cannot construct ranges directly in previous reduce because element ranges can overlap.\n        // In other words lets assume we have such scenario:\n        // <fake-marker-start /> <paragraph /> <fake-marker-2-start /> <fake-marker-end /> <fake-marker-2-end />\n        //\n        // We have to remove `fake-marker-start` firstly and then remove `fake-marker-2-start`.\n        // Removal of `fake-marker-2-start` affects `fake-marker-end` position so we cannot create\n        // connection between `fake-marker-start` and `fake-marker-end` without iterating whole set firstly.\n        return mapValues(fakeMarkersRanges, range => new Range(range.start || writer.createPositionFromPath(rootElement, [0]), range.end || writer.createPositionAt(rootElement, 'end')));\n    }\n    /**\n     * Returns array that contains list of fake markers with corresponding `$marker` elements.\n     *\n     * For each marker, there can be two `$marker` elements or only one (if the document fragment contained\n     * only the beginning or only the end of a marker).\n     *\n     * @param writer An instance of the model writer.\n     * @param rootElement The element to be checked.\n     */\n    _getAllFakeMarkersFromElement(writer, rootElement) {\n        const foundFakeMarkers = Array\n            .from(writer.createRangeIn(rootElement))\n            .flatMap(({ item }) => {\n            if (!item.is('element', '$marker')) {\n                return [];\n            }\n            const name = item.getAttribute('data-name');\n            const type = item.getAttribute('data-type');\n            return [\n                {\n                    markerElement: item,\n                    name,\n                    type\n                }\n            ];\n        });\n        const prependFakeMarkers = [];\n        const appendFakeMarkers = [];\n        for (const fakeMarker of foundFakeMarkers) {\n            if (fakeMarker.type === 'end') {\n                // <fake-marker> [ phrase</fake-marker> phrase ]\n                //   ^\n                // Handle case when marker is just before start of selection.\n                // Only end marker is inside selection.\n                const hasMatchingStartMarker = foundFakeMarkers.some(otherFakeMarker => otherFakeMarker.name === fakeMarker.name && otherFakeMarker.type === 'start');\n                if (!hasMatchingStartMarker) {\n                    prependFakeMarkers.push({\n                        markerElement: null,\n                        name: fakeMarker.name,\n                        type: 'start'\n                    });\n                }\n            }\n            if (fakeMarker.type === 'start') {\n                // [<fake-marker>phrase]</fake-marker>\n                //                           ^\n                // Handle case when fake marker is after selection.\n                // Only start marker is inside selection.\n                const hasMatchingEndMarker = foundFakeMarkers.some(otherFakeMarker => otherFakeMarker.name === fakeMarker.name && otherFakeMarker.type === 'end');\n                if (!hasMatchingEndMarker) {\n                    appendFakeMarkers.unshift({\n                        markerElement: null,\n                        name: fakeMarker.name,\n                        type: 'end'\n                    });\n                }\n            }\n        }\n        return [\n            ...prependFakeMarkers,\n            ...foundFakeMarkers,\n            ...appendFakeMarkers\n        ];\n    }\n    /**\n     * When copy of markers occurs we have to make sure that pasted markers have different names\n     * than source markers. This functions helps with assigning unique part to marker name to\n     * prevent duplicated markers error.\n     *\n     * @param name Name of marker\n     */\n    _getUniqueMarkerName(name) {\n        const parts = name.split(':');\n        const newId = uid().substring(1, 6);\n        // It looks like the marker already is UID marker so in this scenario just swap\n        // last part of marker name and assign new UID.\n        //\n        // example: comment:{ threadId }:{ id } => comment:{ threadId }:{ newId }\n        if (parts.length === 3) {\n            return `${parts.slice(0, 2).join(':')}:${newId}`;\n        }\n        // Assign new segment to marker name with id.\n        //\n        // example: comment => comment:{ newId }\n        return `${parts.join(':')}:${newId}`;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module clipboard/clipboardpipeline\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport { EventInfo } from '@ckeditor/ckeditor5-utils';\nimport ClipboardObserver from './clipboardobserver.js';\nimport plainTextToHtml from './utils/plaintexttohtml.js';\nimport normalizeClipboardHtml from './utils/normalizeclipboarddata.js';\nimport viewToPlainText from './utils/viewtoplaintext.js';\nimport ClipboardMarkersUtils from './clipboardmarkersutils.js';\n// Input pipeline events overview:\n//\n//              ┌──────────────────────┐          ┌──────────────────────┐\n//              │     view.Document    │          │     view.Document    │\n//              │         paste        │          │         drop         │\n//              └───────────┬──────────┘          └───────────┬──────────┘\n//                          │                                 │\n//                          └────────────────┌────────────────┘\n//                                           │\n//                                 ┌─────────V────────┐\n//                                 │   view.Document  │   Retrieves text/html or text/plain from data.dataTransfer\n//                                 │  clipboardInput  │   and processes it to view.DocumentFragment.\n//                                 └─────────┬────────┘\n//                                           │\n//                               ┌───────────V───────────┐\n//                               │   ClipboardPipeline   │   Converts view.DocumentFragment to model.DocumentFragment.\n//                               │  inputTransformation  │\n//                               └───────────┬───────────┘\n//                                           │\n//                                ┌──────────V──────────┐\n//                                │  ClipboardPipeline  │   Calls model.insertContent().\n//                                │   contentInsertion  │\n//                                └─────────────────────┘\n//\n//\n// Output pipeline events overview:\n//\n//              ┌──────────────────────┐          ┌──────────────────────┐\n//              │     view.Document    │          │     view.Document    │   Retrieves the selected model.DocumentFragment\n//              │         copy         │          │          cut         │   and fires the `outputTransformation` event.\n//              └───────────┬──────────┘          └───────────┬──────────┘\n//                          │                                 │\n//                          └────────────────┌────────────────┘\n//                                           │\n//                               ┌───────────V───────────┐\n//                               │   ClipboardPipeline   │   Processes model.DocumentFragment and converts it to\n//                               │  outputTransformation │   view.DocumentFragment.\n//                               └───────────┬───────────┘\n//                                           │\n//                                 ┌─────────V────────┐\n//                                 │   view.Document  │   Processes view.DocumentFragment to text/html and text/plain\n//                                 │  clipboardOutput │   and stores the results in data.dataTransfer.\n//                                 └──────────────────┘\n//\n/**\n * The clipboard pipeline feature. It is responsible for intercepting the `paste` and `drop` events and\n * passing the pasted content through a series of events in order to insert it into the editor's content.\n * It also handles the `cut` and `copy` events to fill the native clipboard with the serialized editor's data.\n *\n * # Input pipeline\n *\n * The behavior of the default handlers (all at a `low` priority):\n *\n * ## Event: `paste` or `drop`\n *\n * 1. Translates the event data.\n * 2. Fires the {@link module:engine/view/document~Document#event:clipboardInput `view.Document#clipboardInput`} event.\n *\n * ## Event: `view.Document#clipboardInput`\n *\n * 1. If the `data.content` event field is already set (by some listener on a higher priority), it takes this content and fires the event\n *    from the last point.\n * 2. Otherwise, it retrieves `text/html` or `text/plain` from `data.dataTransfer`.\n * 3. Normalizes the raw data by applying simple filters on string data.\n * 4. Processes the raw data to {@link module:engine/view/documentfragment~DocumentFragment `view.DocumentFragment`} with the\n *    {@link module:engine/controller/datacontroller~DataController#htmlProcessor `DataController#htmlProcessor`}.\n * 5. Fires the {@link module:clipboard/clipboardpipeline~ClipboardPipeline#event:inputTransformation\n *   `ClipboardPipeline#inputTransformation`} event with the view document fragment in the `data.content` event field.\n *\n * ## Event: `ClipboardPipeline#inputTransformation`\n *\n * 1. Converts {@link module:engine/view/documentfragment~DocumentFragment `view.DocumentFragment`} from the `data.content` field to\n *    {@link module:engine/model/documentfragment~DocumentFragment `model.DocumentFragment`}.\n * 2. Fires the {@link module:clipboard/clipboardpipeline~ClipboardPipeline#event:contentInsertion `ClipboardPipeline#contentInsertion`}\n *    event with the model document fragment in the `data.content` event field.\n *    **Note**: The `ClipboardPipeline#contentInsertion` event is fired within a model change block to allow other handlers\n *    to run in the same block without post-fixers called in between (i.e., the selection post-fixer).\n *\n * ## Event: `ClipboardPipeline#contentInsertion`\n *\n * 1. Calls {@link module:engine/model/model~Model#insertContent `model.insertContent()`} to insert `data.content`\n *    at the current selection position.\n *\n * # Output pipeline\n *\n * The behavior of the default handlers (all at a `low` priority):\n *\n * ## Event: `copy`, `cut` or `dragstart`\n *\n * 1. Retrieves the selected {@link module:engine/model/documentfragment~DocumentFragment `model.DocumentFragment`} by calling\n *    {@link module:engine/model/model~Model#getSelectedContent `model#getSelectedContent()`}.\n * 2. Converts the model document fragment to {@link module:engine/view/documentfragment~DocumentFragment `view.DocumentFragment`}.\n * 3. Fires the {@link module:engine/view/document~Document#event:clipboardOutput `view.Document#clipboardOutput`} event\n *    with the view document fragment in the `data.content` event field.\n *\n * ## Event: `view.Document#clipboardOutput`\n *\n * 1. Processes `data.content` to HTML and plain text with the\n *    {@link module:engine/controller/datacontroller~DataController#htmlProcessor `DataController#htmlProcessor`}.\n * 2. Updates the `data.dataTransfer` data for `text/html` and `text/plain` with the processed data.\n * 3. For the `cut` method, calls {@link module:engine/model/model~Model#deleteContent `model.deleteContent()`}\n *    on the current selection.\n *\n * Read more about the clipboard integration in the {@glink framework/deep-dive/clipboard clipboard deep-dive} guide.\n */\nexport default class ClipboardPipeline extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'ClipboardPipeline';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [ClipboardMarkersUtils];\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const view = editor.editing.view;\n        view.addObserver(ClipboardObserver);\n        this._setupPasteDrop();\n        this._setupCopyCut();\n    }\n    /**\n     * Fires Clipboard `'outputTransformation'` event for given parameters.\n     *\n     * @internal\n     */\n    _fireOutputTransformationEvent(dataTransfer, selection, method) {\n        const clipboardMarkersUtils = this.editor.plugins.get('ClipboardMarkersUtils');\n        const documentFragment = clipboardMarkersUtils._copySelectedFragmentWithMarkers(method, selection);\n        this.fire('outputTransformation', {\n            dataTransfer,\n            content: documentFragment,\n            method\n        });\n    }\n    /**\n     * The clipboard paste pipeline.\n     */\n    _setupPasteDrop() {\n        const editor = this.editor;\n        const model = editor.model;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        const clipboardMarkersUtils = this.editor.plugins.get('ClipboardMarkersUtils');\n        // Pasting is disabled when selection is in non-editable place.\n        // Dropping is disabled in drag and drop handler.\n        this.listenTo(viewDocument, 'clipboardInput', (evt, data) => {\n            if (data.method == 'paste' && !editor.model.canEditAt(editor.model.document.selection)) {\n                evt.stop();\n            }\n        }, { priority: 'highest' });\n        this.listenTo(viewDocument, 'clipboardInput', (evt, data) => {\n            const dataTransfer = data.dataTransfer;\n            let content;\n            // Some feature could already inject content in the higher priority event handler (i.e., codeBlock).\n            if (data.content) {\n                content = data.content;\n            }\n            else {\n                let contentData = '';\n                if (dataTransfer.getData('text/html')) {\n                    contentData = normalizeClipboardHtml(dataTransfer.getData('text/html'));\n                }\n                else if (dataTransfer.getData('text/plain')) {\n                    contentData = plainTextToHtml(dataTransfer.getData('text/plain'));\n                }\n                content = this.editor.data.htmlProcessor.toView(contentData);\n            }\n            const eventInfo = new EventInfo(this, 'inputTransformation');\n            this.fire(eventInfo, {\n                content,\n                dataTransfer,\n                targetRanges: data.targetRanges,\n                method: data.method\n            });\n            // If CKEditor handled the input, do not bubble the original event any further.\n            // This helps external integrations recognize this fact and act accordingly.\n            // https://github.com/ckeditor/ckeditor5-upload/issues/92\n            if (eventInfo.stop.called) {\n                evt.stop();\n            }\n            view.scrollToTheSelection();\n        }, { priority: 'low' });\n        this.listenTo(this, 'inputTransformation', (evt, data) => {\n            if (data.content.isEmpty) {\n                return;\n            }\n            const dataController = this.editor.data;\n            // Convert the pasted content into a model document fragment.\n            // The conversion is contextual, but in this case an \"all allowed\" context is needed\n            // and for that we use the $clipboardHolder item.\n            const modelFragment = dataController.toModel(data.content, '$clipboardHolder');\n            if (modelFragment.childCount == 0) {\n                return;\n            }\n            evt.stop();\n            // Fire content insertion event in a single change block to allow other handlers to run in the same block\n            // without post-fixers called in between (i.e., the selection post-fixer).\n            model.change(() => {\n                this.fire('contentInsertion', {\n                    content: modelFragment,\n                    method: data.method,\n                    dataTransfer: data.dataTransfer,\n                    targetRanges: data.targetRanges\n                });\n            });\n        }, { priority: 'low' });\n        this.listenTo(this, 'contentInsertion', (evt, data) => {\n            clipboardMarkersUtils._setUniqueMarkerNamesInFragment(data.content);\n        }, { priority: 'highest' });\n        this.listenTo(this, 'contentInsertion', (evt, data) => {\n            data.resultRange = model.insertContent(data.content);\n        }, { priority: 'low' });\n    }\n    /**\n     * The clipboard copy/cut pipeline.\n     */\n    _setupCopyCut() {\n        const editor = this.editor;\n        const modelDocument = editor.model.document;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        const onCopyCut = (evt, data) => {\n            const dataTransfer = data.dataTransfer;\n            data.preventDefault();\n            this._fireOutputTransformationEvent(dataTransfer, modelDocument.selection, evt.name);\n        };\n        this.listenTo(viewDocument, 'copy', onCopyCut, { priority: 'low' });\n        this.listenTo(viewDocument, 'cut', (evt, data) => {\n            // Cutting is disabled when selection is in non-editable place.\n            // See: https://github.com/ckeditor/ckeditor5-clipboard/issues/26.\n            if (!editor.model.canEditAt(editor.model.document.selection)) {\n                data.preventDefault();\n            }\n            else {\n                onCopyCut(evt, data);\n            }\n        }, { priority: 'low' });\n        this.listenTo(this, 'outputTransformation', (evt, data) => {\n            const content = editor.data.toView(data.content);\n            viewDocument.fire('clipboardOutput', {\n                dataTransfer: data.dataTransfer,\n                content,\n                method: data.method\n            });\n        }, { priority: 'low' });\n        this.listenTo(viewDocument, 'clipboardOutput', (evt, data) => {\n            if (!data.content.isEmpty) {\n                data.dataTransfer.setData('text/html', this.editor.data.htmlProcessor.toData(data.content));\n                data.dataTransfer.setData('text/plain', viewToPlainText(data.content));\n            }\n            if (data.method == 'cut') {\n                editor.model.deleteContent(modelDocument.selection);\n            }\n        }, { priority: 'low' });\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module clipboard/lineview\n */\n/* istanbul ignore file -- @preserve */\nimport { View } from '@ckeditor/ckeditor5-ui';\nimport { toUnit } from '@ckeditor/ckeditor5-utils';\nconst toPx = toUnit('px');\n/**\n * The horizontal drop target line view.\n */\nexport default class LineView extends View {\n    /**\n     * @inheritDoc\n     */\n    constructor() {\n        super();\n        const bind = this.bindTemplate;\n        this.set({\n            isVisible: false,\n            left: null,\n            top: null,\n            width: null\n        });\n        this.setTemplate({\n            tag: 'div',\n            attributes: {\n                class: [\n                    'ck',\n                    'ck-clipboard-drop-target-line',\n                    bind.if('isVisible', 'ck-hidden', value => !value)\n                ],\n                style: {\n                    left: bind.to('left', left => toPx(left)),\n                    top: bind.to('top', top => toPx(top)),\n                    width: bind.to('width', width => toPx(width))\n                }\n            }\n        });\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module clipboard/dragdrop\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport { LiveRange, MouseObserver } from '@ckeditor/ckeditor5-engine';\nimport { Widget, isWidget } from '@ckeditor/ckeditor5-widget';\nimport { env, uid, global, createElement, DomEmitterMixin, delay, Rect } from '@ckeditor/ckeditor5-utils';\nimport ClipboardPipeline from './clipboardpipeline.js';\nimport ClipboardObserver from './clipboardobserver.js';\nimport DragDropTarget from './dragdroptarget.js';\nimport DragDropBlockToolbar from './dragdropblocktoolbar.js';\nimport '../theme/clipboard.css';\n// Drag and drop events overview:\n//\n//                ┌──────────────────┐\n//                │     mousedown    │   Sets the draggable attribute.\n//                └─────────┬────────┘\n//                          │\n//                          └─────────────────────┐\n//                          │                     │\n//                          │           ┌─────────V────────┐\n//                          │           │      mouseup     │   Dragging did not start, removes the draggable attribute.\n//                          │           └──────────────────┘\n//                          │\n//                ┌─────────V────────┐   Retrieves the selected model.DocumentFragment\n//                │     dragstart    │   and converts it to view.DocumentFragment.\n//                └─────────┬────────┘\n//                          │\n//                ┌─────────V────────┐   Processes view.DocumentFragment to text/html and text/plain\n//                │  clipboardOutput │   and stores the results in data.dataTransfer.\n//                └─────────┬────────┘\n//                          │\n//                          │   DOM dragover\n//                          ┌────────────┐\n//                          │            │\n//                ┌─────────V────────┐   │\n//                │     dragging     │   │   Updates the drop target marker.\n//                └─────────┬────────┘   │\n//                          │            │\n//            ┌─────────────└────────────┘\n//            │             │            │\n//            │   ┌─────────V────────┐   │\n//            │   │     dragleave    │   │   Removes the drop target marker.\n//            │   └─────────┬────────┘   │\n//            │             │            │\n//        ┌───│─────────────┘            │\n//        │   │             │            │\n//        │   │   ┌─────────V────────┐   │\n//        │   │   │     dragenter    │   │   Focuses the editor view.\n//        │   │   └─────────┬────────┘   │\n//        │   │             │            │\n//        │   │             └────────────┘\n//        │   │\n//        │   └─────────────┐\n//        │   │             │\n//        │   │   ┌─────────V────────┐\n//        └───┐   │       drop       │   (The default handler of the clipboard pipeline).\n//            │   └─────────┬────────┘\n//            │             │\n//            │   ┌─────────V────────┐   Resolves the final data.targetRanges.\n//            │   │  clipboardInput  │   Aborts if dropping on dragged content.\n//            │   └─────────┬────────┘\n//            │             │\n//            │   ┌─────────V────────┐\n//            │   │  clipboardInput  │   (The default handler of the clipboard pipeline).\n//            │   └─────────┬────────┘\n//            │             │\n//            │ ┌───────────V───────────┐\n//            │ │  inputTransformation  │   (The default handler of the clipboard pipeline).\n//            │ └───────────┬───────────┘\n//            │             │\n//            │  ┌──────────V──────────┐\n//            │  │   contentInsertion  │   Updates the document selection to drop range.\n//            │  └──────────┬──────────┘\n//            │             │\n//            │  ┌──────────V──────────┐\n//            │  │   contentInsertion  │   (The default handler of the clipboard pipeline).\n//            │  └──────────┬──────────┘\n//            │             │\n//            │  ┌──────────V──────────┐\n//            │  │   contentInsertion  │   Removes the content from the original range if the insertion was successful.\n//            │  └──────────┬──────────┘\n//            │             │\n//            └─────────────┐\n//                          │\n//                ┌─────────V────────┐\n//                │      dragend     │   Removes the drop marker and cleans the state.\n//                └──────────────────┘\n//\n/**\n * The drag and drop feature. It works on top of the {@link module:clipboard/clipboardpipeline~ClipboardPipeline}.\n *\n * Read more about the clipboard integration in the {@glink framework/deep-dive/clipboard clipboard deep-dive} guide.\n *\n * @internal\n */\nexport default class DragDrop extends Plugin {\n    constructor() {\n        super(...arguments);\n        /**\n         * A delayed callback removing draggable attributes.\n         */\n        this._clearDraggableAttributesDelayed = delay(() => this._clearDraggableAttributes(), 40);\n        /**\n         * Whether the dragged content can be dropped only in block context.\n         */\n        // TODO handle drag from other editor instance\n        // TODO configure to use block, inline or both\n        this._blockMode = false;\n        /**\n         * DOM Emitter.\n         */\n        this._domEmitter = new (DomEmitterMixin())();\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'DragDrop';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [ClipboardPipeline, Widget, DragDropTarget, DragDropBlockToolbar];\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const view = editor.editing.view;\n        this._draggedRange = null;\n        this._draggingUid = '';\n        this._draggableElement = null;\n        view.addObserver(ClipboardObserver);\n        view.addObserver(MouseObserver);\n        this._setupDragging();\n        this._setupContentInsertionIntegration();\n        this._setupClipboardInputIntegration();\n        this._setupDraggableAttributeHandling();\n        this.listenTo(editor, 'change:isReadOnly', (evt, name, isReadOnly) => {\n            if (isReadOnly) {\n                this.forceDisabled('readOnlyMode');\n            }\n            else {\n                this.clearForceDisabled('readOnlyMode');\n            }\n        });\n        this.on('change:isEnabled', (evt, name, isEnabled) => {\n            if (!isEnabled) {\n                this._finalizeDragging(false);\n            }\n        });\n        if (env.isAndroid) {\n            this.forceDisabled('noAndroidSupport');\n        }\n    }\n    /**\n     * @inheritDoc\n     */\n    destroy() {\n        if (this._draggedRange) {\n            this._draggedRange.detach();\n            this._draggedRange = null;\n        }\n        if (this._previewContainer) {\n            this._previewContainer.remove();\n        }\n        this._domEmitter.stopListening();\n        this._clearDraggableAttributesDelayed.cancel();\n        return super.destroy();\n    }\n    /**\n     * Drag and drop events handling.\n     */\n    _setupDragging() {\n        const editor = this.editor;\n        const model = editor.model;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        const dragDropTarget = editor.plugins.get(DragDropTarget);\n        // The handler for the drag start; it is responsible for setting data transfer object.\n        this.listenTo(viewDocument, 'dragstart', (evt, data) => {\n            // Don't drag the editable element itself.\n            if (data.target && data.target.is('editableElement')) {\n                data.preventDefault();\n                return;\n            }\n            this._prepareDraggedRange(data.target);\n            if (!this._draggedRange) {\n                data.preventDefault();\n                return;\n            }\n            this._draggingUid = uid();\n            data.dataTransfer.effectAllowed = this.isEnabled ? 'copyMove' : 'copy';\n            data.dataTransfer.setData('application/ckeditor5-dragging-uid', this._draggingUid);\n            const draggedSelection = model.createSelection(this._draggedRange.toRange());\n            const clipboardPipeline = this.editor.plugins.get('ClipboardPipeline');\n            clipboardPipeline._fireOutputTransformationEvent(data.dataTransfer, draggedSelection, 'dragstart');\n            const { dataTransfer, domTarget, domEvent } = data;\n            const { clientX } = domEvent;\n            this._updatePreview({ dataTransfer, domTarget, clientX });\n            data.stopPropagation();\n            if (!this.isEnabled) {\n                this._draggedRange.detach();\n                this._draggedRange = null;\n                this._draggingUid = '';\n            }\n        }, { priority: 'low' });\n        // The handler for finalizing drag and drop. It should always be triggered after dragging completes\n        // even if it was completed in a different application.\n        // Note: This is not fired if source text node got removed while downcasting a marker.\n        this.listenTo(viewDocument, 'dragend', (evt, data) => {\n            this._finalizeDragging(!data.dataTransfer.isCanceled && data.dataTransfer.dropEffect == 'move');\n        }, { priority: 'low' });\n        // Reset block dragging mode even if dropped outside the editable.\n        this._domEmitter.listenTo(global.document, 'dragend', () => {\n            this._blockMode = false;\n        }, { useCapture: true });\n        // Dragging over the editable.\n        this.listenTo(viewDocument, 'dragenter', () => {\n            if (!this.isEnabled) {\n                return;\n            }\n            view.focus();\n        });\n        // Dragging out of the editable.\n        this.listenTo(viewDocument, 'dragleave', () => {\n            // We do not know if the mouse left the editor or just some element in it, so let us wait a few milliseconds\n            // to check if 'dragover' is not fired.\n            dragDropTarget.removeDropMarkerDelayed();\n        });\n        // Handler for moving dragged content over the target area.\n        this.listenTo(viewDocument, 'dragging', (evt, data) => {\n            if (!this.isEnabled) {\n                data.dataTransfer.dropEffect = 'none';\n                return;\n            }\n            const { clientX, clientY } = data.domEvent;\n            dragDropTarget.updateDropMarker(data.target, data.targetRanges, clientX, clientY, this._blockMode, this._draggedRange);\n            // If this is content being dragged from another editor, moving out of current editor instance\n            // is not possible until 'dragend' event case will be fixed.\n            if (!this._draggedRange) {\n                data.dataTransfer.dropEffect = 'copy';\n            }\n            // In Firefox it is already set and effect allowed remains the same as originally set.\n            if (!env.isGecko) {\n                if (data.dataTransfer.effectAllowed == 'copy') {\n                    data.dataTransfer.dropEffect = 'copy';\n                }\n                else if (['all', 'copyMove'].includes(data.dataTransfer.effectAllowed)) {\n                    data.dataTransfer.dropEffect = 'move';\n                }\n            }\n            evt.stop();\n        }, { priority: 'low' });\n    }\n    /**\n     * Integration with the `clipboardInput` event.\n     */\n    _setupClipboardInputIntegration() {\n        const editor = this.editor;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        const dragDropTarget = editor.plugins.get(DragDropTarget);\n        // Update the event target ranges and abort dropping if dropping over itself.\n        this.listenTo(viewDocument, 'clipboardInput', (evt, data) => {\n            if (data.method != 'drop') {\n                return;\n            }\n            const { clientX, clientY } = data.domEvent;\n            const targetRange = dragDropTarget.getFinalDropRange(data.target, data.targetRanges, clientX, clientY, this._blockMode, this._draggedRange);\n            if (!targetRange) {\n                this._finalizeDragging(false);\n                evt.stop();\n                return;\n            }\n            // Since we cannot rely on the drag end event, we must check if the local drag range is from the current drag and drop\n            // or it is from some previous not cleared one.\n            if (this._draggedRange && this._draggingUid != data.dataTransfer.getData('application/ckeditor5-dragging-uid')) {\n                this._draggedRange.detach();\n                this._draggedRange = null;\n                this._draggingUid = '';\n            }\n            // Do not do anything if some content was dragged within the same document to the same position.\n            const isMove = getFinalDropEffect(data.dataTransfer) == 'move';\n            if (isMove && this._draggedRange && this._draggedRange.containsRange(targetRange, true)) {\n                this._finalizeDragging(false);\n                evt.stop();\n                return;\n            }\n            // Override the target ranges with the one adjusted to the best one for a drop.\n            data.targetRanges = [editor.editing.mapper.toViewRange(targetRange)];\n        }, { priority: 'high' });\n    }\n    /**\n     * Integration with the `contentInsertion` event of the clipboard pipeline.\n     */\n    _setupContentInsertionIntegration() {\n        const clipboardPipeline = this.editor.plugins.get(ClipboardPipeline);\n        clipboardPipeline.on('contentInsertion', (evt, data) => {\n            if (!this.isEnabled || data.method !== 'drop') {\n                return;\n            }\n            // Update the selection to the target range in the same change block to avoid selection post-fixing\n            // and to be able to clone text attributes for plain text dropping.\n            const ranges = data.targetRanges.map(viewRange => this.editor.editing.mapper.toModelRange(viewRange));\n            this.editor.model.change(writer => writer.setSelection(ranges));\n        }, { priority: 'high' });\n        clipboardPipeline.on('contentInsertion', (evt, data) => {\n            if (!this.isEnabled || data.method !== 'drop') {\n                return;\n            }\n            // Remove dragged range content, remove markers, clean after dragging.\n            const isMove = getFinalDropEffect(data.dataTransfer) == 'move';\n            // Whether any content was inserted (insertion might fail if the schema is disallowing some elements\n            // (for example an image caption allows only the content of a block but not blocks themselves.\n            // Some integrations might not return valid range (i.e., table pasting).\n            const isSuccess = !data.resultRange || !data.resultRange.isCollapsed;\n            this._finalizeDragging(isSuccess && isMove);\n        }, { priority: 'lowest' });\n    }\n    /**\n     * Adds listeners that add the `draggable` attribute to the elements while the mouse button is down so the dragging could start.\n     */\n    _setupDraggableAttributeHandling() {\n        const editor = this.editor;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        // Add the 'draggable' attribute to the widget while pressing the selection handle.\n        // This is required for widgets to be draggable. In Chrome it will enable dragging text nodes.\n        this.listenTo(viewDocument, 'mousedown', (evt, data) => {\n            // The lack of data can be caused by editor tests firing fake mouse events. This should not occur\n            // in real-life scenarios but this greatly simplifies editor tests that would otherwise fail a lot.\n            if (env.isAndroid || !data) {\n                return;\n            }\n            this._clearDraggableAttributesDelayed.cancel();\n            // Check if this is a mousedown over the widget (but not a nested editable).\n            let draggableElement = findDraggableWidget(data.target);\n            // Note: There is a limitation that if more than a widget is selected (a widget and some text)\n            // and dragging starts on the widget, then only the widget is dragged.\n            // If this was not a widget then we should check if we need to drag some text content.\n            // In Chrome set a 'draggable' attribute on closest editable to allow immediate dragging of the selected text range.\n            // In Firefox this is not needed. In Safari it makes the whole editable draggable (not just textual content).\n            // Disabled in read-only mode because draggable=\"true\" + contenteditable=\"false\" results\n            // in not firing selectionchange event ever, which makes the selection stuck in read-only mode.\n            if (env.isBlink && !editor.isReadOnly && !draggableElement && !viewDocument.selection.isCollapsed) {\n                const selectedElement = viewDocument.selection.getSelectedElement();\n                if (!selectedElement || !isWidget(selectedElement)) {\n                    draggableElement = viewDocument.selection.editableElement;\n                }\n            }\n            if (draggableElement) {\n                view.change(writer => {\n                    writer.setAttribute('draggable', 'true', draggableElement);\n                });\n                // Keep the reference to the model element in case the view element gets removed while dragging.\n                this._draggableElement = editor.editing.mapper.toModelElement(draggableElement);\n            }\n        });\n        // Remove the draggable attribute in case no dragging started (only mousedown + mouseup).\n        this.listenTo(viewDocument, 'mouseup', () => {\n            if (!env.isAndroid) {\n                this._clearDraggableAttributesDelayed();\n            }\n        });\n    }\n    /**\n     * Removes the `draggable` attribute from the element that was used for dragging.\n     */\n    _clearDraggableAttributes() {\n        const editing = this.editor.editing;\n        editing.view.change(writer => {\n            // Remove 'draggable' attribute.\n            if (this._draggableElement && this._draggableElement.root.rootName != '$graveyard') {\n                writer.removeAttribute('draggable', editing.mapper.toViewElement(this._draggableElement));\n            }\n            this._draggableElement = null;\n        });\n    }\n    /**\n     * Deletes the dragged content from its original range and clears the dragging state.\n     *\n     * @param moved Whether the move succeeded.\n     */\n    _finalizeDragging(moved) {\n        const editor = this.editor;\n        const model = editor.model;\n        const dragDropTarget = editor.plugins.get(DragDropTarget);\n        dragDropTarget.removeDropMarker();\n        this._clearDraggableAttributes();\n        if (editor.plugins.has('WidgetToolbarRepository')) {\n            const widgetToolbarRepository = editor.plugins.get('WidgetToolbarRepository');\n            widgetToolbarRepository.clearForceDisabled('dragDrop');\n        }\n        this._draggingUid = '';\n        if (this._previewContainer) {\n            this._previewContainer.remove();\n            this._previewContainer = undefined;\n        }\n        if (!this._draggedRange) {\n            return;\n        }\n        // Delete moved content.\n        if (moved && this.isEnabled) {\n            model.change(writer => {\n                const selection = model.createSelection(this._draggedRange);\n                model.deleteContent(selection, { doNotAutoparagraph: true });\n                // Check result selection if it does not require auto-paragraphing of empty container.\n                const selectionParent = selection.getFirstPosition().parent;\n                if (selectionParent.isEmpty &&\n                    !model.schema.checkChild(selectionParent, '$text') &&\n                    model.schema.checkChild(selectionParent, 'paragraph')) {\n                    writer.insertElement('paragraph', selectionParent, 0);\n                }\n            });\n        }\n        this._draggedRange.detach();\n        this._draggedRange = null;\n    }\n    /**\n     * Sets the dragged source range based on event target and document selection.\n     */\n    _prepareDraggedRange(target) {\n        const editor = this.editor;\n        const model = editor.model;\n        const selection = model.document.selection;\n        // Check if this is dragstart over the widget (but not a nested editable).\n        const draggableWidget = target ? findDraggableWidget(target) : null;\n        if (draggableWidget) {\n            const modelElement = editor.editing.mapper.toModelElement(draggableWidget);\n            this._draggedRange = LiveRange.fromRange(model.createRangeOn(modelElement));\n            this._blockMode = model.schema.isBlock(modelElement);\n            // Disable toolbars so they won't obscure the drop area.\n            if (editor.plugins.has('WidgetToolbarRepository')) {\n                const widgetToolbarRepository = editor.plugins.get('WidgetToolbarRepository');\n                widgetToolbarRepository.forceDisabled('dragDrop');\n            }\n            return;\n        }\n        // If this was not a widget we should check if we need to drag some text content.\n        if (selection.isCollapsed && !selection.getFirstPosition().parent.isEmpty) {\n            return;\n        }\n        const blocks = Array.from(selection.getSelectedBlocks());\n        const draggedRange = selection.getFirstRange();\n        if (blocks.length == 0) {\n            this._draggedRange = LiveRange.fromRange(draggedRange);\n            return;\n        }\n        const blockRange = getRangeIncludingFullySelectedParents(model, blocks);\n        if (blocks.length > 1) {\n            this._draggedRange = LiveRange.fromRange(blockRange);\n            this._blockMode = true;\n            // TODO block mode for dragging from outside editor? or inline? or both?\n        }\n        else if (blocks.length == 1) {\n            const touchesBlockEdges = draggedRange.start.isTouching(blockRange.start) &&\n                draggedRange.end.isTouching(blockRange.end);\n            this._draggedRange = LiveRange.fromRange(touchesBlockEdges ? blockRange : draggedRange);\n            this._blockMode = touchesBlockEdges;\n        }\n        model.change(writer => writer.setSelection(this._draggedRange.toRange()));\n    }\n    /**\n     * Updates the dragged preview image.\n     */\n    _updatePreview({ dataTransfer, domTarget, clientX }) {\n        const view = this.editor.editing.view;\n        const editable = view.document.selection.editableElement;\n        const domEditable = view.domConverter.mapViewToDom(editable);\n        const computedStyle = global.window.getComputedStyle(domEditable);\n        if (!this._previewContainer) {\n            this._previewContainer = createElement(global.document, 'div', {\n                style: 'position: fixed; left: -999999px;'\n            });\n            global.document.body.appendChild(this._previewContainer);\n        }\n        else if (this._previewContainer.firstElementChild) {\n            this._previewContainer.removeChild(this._previewContainer.firstElementChild);\n        }\n        const domRect = new Rect(domEditable);\n        // If domTarget is inside the editable root, browsers will display the preview correctly by themselves.\n        if (domEditable.contains(domTarget)) {\n            return;\n        }\n        const domEditablePaddingLeft = parseFloat(computedStyle.paddingLeft);\n        const preview = createElement(global.document, 'div');\n        preview.className = 'ck ck-content';\n        preview.style.width = computedStyle.width;\n        preview.style.paddingLeft = `${domRect.left - clientX + domEditablePaddingLeft}px`;\n        /**\n         * Set white background in drag and drop preview if iOS.\n         * Check: https://github.com/ckeditor/ckeditor5/issues/15085\n         */\n        if (env.isiOS) {\n            preview.style.backgroundColor = 'white';\n        }\n        preview.innerHTML = dataTransfer.getData('text/html');\n        dataTransfer.setDragImage(preview, 0, 0);\n        this._previewContainer.appendChild(preview);\n    }\n}\n/**\n * Returns the drop effect that should be a result of dragging the content.\n * This function is handling a quirk when checking the effect in the 'drop' DOM event.\n */\nfunction getFinalDropEffect(dataTransfer) {\n    if (env.isGecko) {\n        return dataTransfer.dropEffect;\n    }\n    return ['all', 'copyMove'].includes(dataTransfer.effectAllowed) ? 'move' : 'copy';\n}\n/**\n * Returns a widget element that should be dragged.\n */\nfunction findDraggableWidget(target) {\n    // This is directly an editable so not a widget for sure.\n    if (target.is('editableElement')) {\n        return null;\n    }\n    // TODO: Let's have a isWidgetSelectionHandleDomElement() helper in ckeditor5-widget utils.\n    if (target.hasClass('ck-widget__selection-handle')) {\n        return target.findAncestor(isWidget);\n    }\n    // Direct hit on a widget.\n    if (isWidget(target)) {\n        return target;\n    }\n    // Find closest ancestor that is either a widget or an editable element...\n    const ancestor = target.findAncestor(node => isWidget(node) || node.is('editableElement'));\n    // ...and if closer was the widget then enable dragging it.\n    if (isWidget(ancestor)) {\n        return ancestor;\n    }\n    return null;\n}\n/**\n * Recursively checks if common parent of provided elements doesn't have any other children. If that's the case,\n * it returns range including this parent. Otherwise, it returns only the range from first to last element.\n *\n * Example:\n *\n * <blockQuote>\n *   <paragraph>[Test 1</paragraph>\n *   <paragraph>Test 2</paragraph>\n *   <paragraph>Test 3]</paragraph>\n * <blockQuote>\n *\n * Because all elements inside the `blockQuote` are selected, the range is extended to include the `blockQuote` too.\n * If only first and second paragraphs would be selected, the range would not include it.\n */\nfunction getRangeIncludingFullySelectedParents(model, elements) {\n    const firstElement = elements[0];\n    const lastElement = elements[elements.length - 1];\n    const parent = firstElement.getCommonAncestor(lastElement);\n    const startPosition = model.createPositionBefore(firstElement);\n    const endPosition = model.createPositionAfter(lastElement);\n    if (parent &&\n        parent.is('element') &&\n        !model.schema.isLimit(parent)) {\n        const parentRange = model.createRangeOn(parent);\n        const touchesStart = startPosition.isTouching(parentRange.start);\n        const touchesEnd = endPosition.isTouching(parentRange.end);\n        if (touchesStart && touchesEnd) {\n            // Selection includes all elements in the parent.\n            return getRangeIncludingFullySelectedParents(model, [parent]);\n        }\n    }\n    return model.createRange(startPosition, endPosition);\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module paste-from-office/filters/list\n */\nimport { Matcher, UpcastWriter } from 'ckeditor5/src/engine.js';\n/**\n * Transforms Word specific list-like elements to the semantic HTML lists.\n *\n * Lists in Word are represented by block elements with special attributes like:\n *\n * ```xml\n * <p class=MsoListParagraphCxSpFirst style='mso-list:l1 level1 lfo1'>...</p> // Paragraph based list.\n * <h1 style='mso-list:l0 level1 lfo1'>...</h1> // Heading 1 based list.\n * ```\n *\n * @param documentFragment The view structure to be transformed.\n * @param stylesString Styles from which list-like elements styling will be extracted.\n */\nexport function transformListItemLikeElementsIntoLists(documentFragment, stylesString) {\n    if (!documentFragment.childCount) {\n        return;\n    }\n    const writer = new UpcastWriter(documentFragment.document);\n    const itemLikeElements = findAllItemLikeElements(documentFragment, writer);\n    if (!itemLikeElements.length) {\n        return;\n    }\n    let currentList = null;\n    let currentIndentation = 1;\n    itemLikeElements.forEach((itemLikeElement, i) => {\n        const isDifferentList = isNewListNeeded(itemLikeElements[i - 1], itemLikeElement);\n        const previousItemLikeElement = isDifferentList ? null : itemLikeElements[i - 1];\n        const indentationDifference = getIndentationDifference(previousItemLikeElement, itemLikeElement);\n        if (isDifferentList) {\n            currentList = null;\n            currentIndentation = 1;\n        }\n        if (!currentList || indentationDifference !== 0) {\n            const listStyle = detectListStyle(itemLikeElement, stylesString);\n            if (!currentList) {\n                currentList = insertNewEmptyList(listStyle, itemLikeElement.element, writer);\n            }\n            else if (itemLikeElement.indent > currentIndentation) {\n                const lastListItem = currentList.getChild(currentList.childCount - 1);\n                const lastListItemChild = lastListItem.getChild(lastListItem.childCount - 1);\n                currentList = insertNewEmptyList(listStyle, lastListItemChild, writer);\n                currentIndentation += 1;\n            }\n            else if (itemLikeElement.indent < currentIndentation) {\n                const differentIndentation = currentIndentation - itemLikeElement.indent;\n                currentList = findParentListAtLevel(currentList, differentIndentation);\n                currentIndentation = itemLikeElement.indent;\n            }\n            if (itemLikeElement.indent <= currentIndentation) {\n                if (!currentList.is('element', listStyle.type)) {\n                    currentList = writer.rename(listStyle.type, currentList);\n                }\n            }\n        }\n        const listItem = transformElementIntoListItem(itemLikeElement.element, writer);\n        writer.appendChild(listItem, currentList);\n    });\n}\n/**\n * Removes paragraph wrapping content inside a list item.\n */\nexport function unwrapParagraphInListItem(documentFragment, writer) {\n    for (const value of writer.createRangeIn(documentFragment)) {\n        const element = value.item;\n        if (element.is('element', 'li')) {\n            // Google Docs allows for single paragraph inside LI.\n            const firstChild = element.getChild(0);\n            if (firstChild && firstChild.is('element', 'p')) {\n                writer.unwrapElement(firstChild);\n            }\n        }\n    }\n}\n/**\n * Finds all list-like elements in a given document fragment.\n *\n * @param documentFragment Document fragment in which to look for list-like nodes.\n * @returns Array of found list-like items. Each item is an object containing:\n */\nfunction findAllItemLikeElements(documentFragment, writer) {\n    const range = writer.createRangeIn(documentFragment);\n    // Matcher for finding list-like elements.\n    const itemLikeElementsMatcher = new Matcher({\n        name: /^p|h\\d+$/,\n        styles: {\n            'mso-list': /.*/\n        }\n    });\n    const itemLikeElements = [];\n    for (const value of range) {\n        if (value.type === 'elementStart' && itemLikeElementsMatcher.match(value.item)) {\n            const itemData = getListItemData(value.item);\n            itemLikeElements.push({\n                element: value.item,\n                id: itemData.id,\n                order: itemData.order,\n                indent: itemData.indent\n            });\n        }\n    }\n    return itemLikeElements;\n}\n/**\n * Extracts list item style from the provided CSS.\n *\n * List item style is extracted from the CSS stylesheet. Each list with its specific style attribute\n * value (`mso-list:l1 level1 lfo1`) has its dedicated properties in a CSS stylesheet defined with a selector like:\n *\n * ```css\n * @list l1:level1 { ... }\n * ```\n *\n * It contains `mso-level-number-format` property which defines list numbering/bullet style. If this property\n * is not defined it means default `decimal` numbering.\n *\n * Here CSS string representation is used as `mso-level-number-format` property is an invalid CSS property\n * and will be removed during CSS parsing.\n *\n * @param listLikeItem List-like item for which list style will be searched for. Usually\n * a result of `findAllItemLikeElements()` function.\n * @param stylesString CSS stylesheet.\n * @returns An object with properties:\n *\n * * type - List type, could be `ul` or `ol`.\n * * startIndex - List start index, valid only for ordered lists.\n * * style - List style, for example: `decimal`, `lower-roman`, etc. It is extracted\n *     directly from Word stylesheet and adjusted to represent proper values for the CSS `list-style-type` property.\n *     If it cannot be adjusted, the `null` value is returned.\n */\nfunction detectListStyle(listLikeItem, stylesString) {\n    const listStyleRegexp = new RegExp(`@list l${listLikeItem.id}:level${listLikeItem.indent}\\\\s*({[^}]*)`, 'gi');\n    const listStyleTypeRegex = /mso-level-number-format:([^;]{0,100});/gi;\n    const listStartIndexRegex = /mso-level-start-at:\\s{0,100}([0-9]{0,10})\\s{0,100};/gi;\n    const listStyleMatch = listStyleRegexp.exec(stylesString);\n    let listStyleType = 'decimal'; // Decimal is default one.\n    let type = 'ol'; // <ol> is default list.\n    let startIndex = null;\n    if (listStyleMatch && listStyleMatch[1]) {\n        const listStyleTypeMatch = listStyleTypeRegex.exec(listStyleMatch[1]);\n        if (listStyleTypeMatch && listStyleTypeMatch[1]) {\n            listStyleType = listStyleTypeMatch[1].trim();\n            type = listStyleType !== 'bullet' && listStyleType !== 'image' ? 'ol' : 'ul';\n        }\n        // Styles for the numbered lists are always defined in the Word CSS stylesheet.\n        // Unordered lists MAY contain a value for the Word CSS definition `mso-level-text` but sometimes\n        // this tag is missing. And because of that, we cannot depend on that. We need to predict the list style value\n        // based on the list style marker element.\n        if (listStyleType === 'bullet') {\n            const bulletedStyle = findBulletedListStyle(listLikeItem.element);\n            if (bulletedStyle) {\n                listStyleType = bulletedStyle;\n            }\n        }\n        else {\n            const listStartIndexMatch = listStartIndexRegex.exec(listStyleMatch[1]);\n            if (listStartIndexMatch && listStartIndexMatch[1]) {\n                startIndex = parseInt(listStartIndexMatch[1]);\n            }\n        }\n    }\n    return {\n        type,\n        startIndex,\n        style: mapListStyleDefinition(listStyleType)\n    };\n}\n/**\n * Tries to extract the `list-style-type` value based on the marker element for bulleted list.\n */\nfunction findBulletedListStyle(element) {\n    const listMarkerElement = findListMarkerNode(element);\n    if (!listMarkerElement) {\n        return null;\n    }\n    const listMarker = listMarkerElement._data;\n    if (listMarker === 'o') {\n        return 'circle';\n    }\n    else if (listMarker === '·') {\n        return 'disc';\n    }\n    // Word returns '§' instead of '■' for the square list style.\n    else if (listMarker === '§') {\n        return 'square';\n    }\n    return null;\n}\n/**\n * Tries to find a text node that represents the marker element (list-style-type).\n */\nfunction findListMarkerNode(element) {\n    // If the first child is a text node, it is the data for the element.\n    // The list-style marker is not present here.\n    if (element.getChild(0).is('$text')) {\n        return null;\n    }\n    for (const childNode of element.getChildren()) {\n        // The list-style marker will be inside the `<span>` element. Let's ignore all non-span elements.\n        // It may happen that the `<a>` element is added as the first child. Most probably, it's an anchor element.\n        if (!childNode.is('element', 'span')) {\n            continue;\n        }\n        const textNodeOrElement = childNode.getChild(0);\n        if (!textNodeOrElement) {\n            continue;\n        }\n        // If already found the marker element, use it.\n        if (textNodeOrElement.is('$text')) {\n            return textNodeOrElement;\n        }\n        return textNodeOrElement.getChild(0);\n    }\n    /* istanbul ignore next -- @preserve */\n    return null;\n}\n/**\n * Parses the `list-style-type` value extracted directly from the Word CSS stylesheet and returns proper CSS definition.\n */\nfunction mapListStyleDefinition(value) {\n    if (value.startsWith('arabic-leading-zero')) {\n        return 'decimal-leading-zero';\n    }\n    switch (value) {\n        case 'alpha-upper':\n            return 'upper-alpha';\n        case 'alpha-lower':\n            return 'lower-alpha';\n        case 'roman-upper':\n            return 'upper-roman';\n        case 'roman-lower':\n            return 'lower-roman';\n        case 'circle':\n        case 'disc':\n        case 'square':\n            return value;\n        default:\n            return null;\n    }\n}\n/**\n * Creates an empty list of a given type and inserts it after a specified element.\n *\n * @param listStyle List style object which determines the type of newly created list.\n * Usually a result of `detectListStyle()` function.\n * @param element Element after which list is inserted.\n * @returns Newly created list element.\n */\nfunction insertNewEmptyList(listStyle, element, writer) {\n    const parent = element.parent;\n    const list = writer.createElement(listStyle.type);\n    const position = parent.getChildIndex(element) + 1;\n    writer.insertChild(position, list, parent);\n    // We do not support modifying the marker for a particular list item.\n    // Set the value for the `list-style-type` property directly to the list container.\n    if (listStyle.style) {\n        writer.setStyle('list-style-type', listStyle.style, list);\n    }\n    if (listStyle.startIndex && listStyle.startIndex > 1) {\n        writer.setAttribute('start', listStyle.startIndex, list);\n    }\n    return list;\n}\n/**\n * Transforms a given element into a semantic list item. As the function operates on a provided\n * {module:engine/src/view/element~Element element} it will modify the view structure to which this element belongs.\n *\n * @param element Element which will be transformed into a list item.\n * @returns New element to which the given one was transformed. It is\n * inserted in place of the old element (the reference to the old element is lost due to renaming).\n */\nfunction transformElementIntoListItem(element, writer) {\n    removeBulletElement(element, writer);\n    writer.removeStyle('text-indent', element); // #12361\n    return writer.rename('li', element);\n}\n/**\n * Extracts list item information from Word specific list-like element style:\n *\n * ```\n * `style=\"mso-list:l1 level1 lfo1\"`\n * ```\n *\n * where:\n *\n * ```\n * * `l1` is a list id (however it does not mean this is a continuous list - see #43),\n * * `level1` is a list item indentation level,\n * * `lfo1` is a list insertion order in a document.\n * ```\n *\n * @param element Element from which style data is extracted.\n */\nfunction getListItemData(element) {\n    const data = {};\n    const listStyle = element.getStyle('mso-list');\n    if (listStyle) {\n        const idMatch = listStyle.match(/(^|\\s{1,100})l(\\d+)/i);\n        const orderMatch = listStyle.match(/\\s{0,100}lfo(\\d+)/i);\n        const indentMatch = listStyle.match(/\\s{0,100}level(\\d+)/i);\n        if (idMatch && orderMatch && indentMatch) {\n            data.id = idMatch[2];\n            data.order = orderMatch[1];\n            data.indent = parseInt(indentMatch[1]);\n        }\n    }\n    return data;\n}\n/**\n * Removes span with a numbering/bullet from a given element.\n */\nfunction removeBulletElement(element, writer) {\n    // Matcher for finding `span` elements holding lists numbering/bullets.\n    const bulletMatcher = new Matcher({\n        name: 'span',\n        styles: {\n            'mso-list': 'Ignore'\n        }\n    });\n    const range = writer.createRangeIn(element);\n    for (const value of range) {\n        if (value.type === 'elementStart' && bulletMatcher.match(value.item)) {\n            writer.remove(value.item);\n        }\n    }\n}\n/**\n * Whether the previous and current items belong to the same list. It is determined based on `item.id`\n * (extracted from `mso-list` style, see #getListItemData) and a previous sibling of the current item.\n *\n * However, it's quite easy to change the `id` attribute for nested lists in Word. It will break the list feature while pasting.\n * Let's check also the `indent` attribute. If the difference between those two elements is equal to 1, we can assume that\n * the `currentItem` is a beginning of the nested list because lists in CKEditor 5 always start with the `indent=0` attribute.\n * See: https://github.com/ckeditor/ckeditor5/issues/7805.\n */\nfunction isNewListNeeded(previousItem, currentItem) {\n    if (!previousItem) {\n        return true;\n    }\n    if (previousItem.id !== currentItem.id) {\n        // See: https://github.com/ckeditor/ckeditor5/issues/7805.\n        //\n        // * List item 1.\n        //     - Nested list item 1.\n        if (currentItem.indent - previousItem.indent === 1) {\n            return false;\n        }\n        return true;\n    }\n    const previousSibling = currentItem.element.previousSibling;\n    if (!previousSibling) {\n        return true;\n    }\n    // Even with the same id the list does not have to be continuous (#43).\n    return !isList(previousSibling);\n}\nfunction isList(element) {\n    return element.is('element', 'ol') || element.is('element', 'ul');\n}\n/**\n * Calculates the indentation difference between two given list items (based on the indent attribute\n * extracted from the `mso-list` style, see #getListItemData).\n */\nfunction getIndentationDifference(previousItem, currentItem) {\n    return previousItem ? currentItem.indent - previousItem.indent : currentItem.indent - 1;\n}\n/**\n * Finds the parent list element (ul/ol) of a given list element with indentation level lower by a given value.\n *\n * @param listElement List element from which to start looking for a parent list.\n * @param indentationDifference Indentation difference between lists.\n * @returns Found list element with indentation level lower by a given value.\n */\nfunction findParentListAtLevel(listElement, indentationDifference) {\n    const ancestors = listElement.getAncestors({ parentFirst: true });\n    let parentList = null;\n    let levelChange = 0;\n    for (const ancestor of ancestors) {\n        if (ancestor.is('element', 'ul') || ancestor.is('element', 'ol')) {\n            levelChange++;\n        }\n        if (levelChange === indentationDifference) {\n            parentList = ancestor;\n            break;\n        }\n    }\n    return parentList;\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module paste-from-office/filters/image\n */\n/* globals btoa */\nimport { Matcher, UpcastWriter } from 'ckeditor5/src/engine.js';\n/**\n * Replaces source attribute of all `<img>` elements representing regular\n * images (not the Word shapes) with inlined base64 image representation extracted from RTF or Blob data.\n *\n * @param documentFragment Document fragment on which transform images.\n * @param rtfData The RTF data from which images representation will be used.\n */\nexport function replaceImagesSourceWithBase64(documentFragment, rtfData) {\n    if (!documentFragment.childCount) {\n        return;\n    }\n    const upcastWriter = new UpcastWriter(documentFragment.document);\n    const shapesIds = findAllShapesIds(documentFragment, upcastWriter);\n    removeAllImgElementsRepresentingShapes(shapesIds, documentFragment, upcastWriter);\n    insertMissingImgs(shapesIds, documentFragment, upcastWriter);\n    removeAllShapeElements(documentFragment, upcastWriter);\n    const images = findAllImageElementsWithLocalSource(documentFragment, upcastWriter);\n    if (images.length) {\n        replaceImagesFileSourceWithInlineRepresentation(images, extractImageDataFromRtf(rtfData), upcastWriter);\n    }\n}\n/**\n * Converts given HEX string to base64 representation.\n *\n * @internal\n * @param hexString The HEX string to be converted.\n * @returns Base64 representation of a given HEX string.\n */\nexport function _convertHexToBase64(hexString) {\n    return btoa(hexString.match(/\\w{2}/g).map(char => {\n        return String.fromCharCode(parseInt(char, 16));\n    }).join(''));\n}\n/**\n * Finds all shapes (`<v:*>...</v:*>`) ids. Shapes can represent images (canvas)\n * or Word shapes (which does not have RTF or Blob representation).\n *\n * @param documentFragment Document fragment from which to extract shape ids.\n * @returns Array of shape ids.\n */\nfunction findAllShapesIds(documentFragment, writer) {\n    const range = writer.createRangeIn(documentFragment);\n    const shapeElementsMatcher = new Matcher({\n        name: /v:(.+)/\n    });\n    const shapesIds = [];\n    for (const value of range) {\n        if (value.type != 'elementStart') {\n            continue;\n        }\n        const el = value.item;\n        const previousSibling = el.previousSibling;\n        const prevSiblingName = previousSibling && previousSibling.is('element') ? previousSibling.name : null;\n        // List of ids which should not be considered as shapes.\n        // https://github.com/ckeditor/ckeditor5/pull/15847#issuecomment-1941543983\n        const exceptionIds = ['Chart'];\n        const isElementAShape = shapeElementsMatcher.match(el);\n        const hasElementGfxdataAttribute = el.getAttribute('o:gfxdata');\n        const isPreviousSiblingAShapeType = prevSiblingName === 'v:shapetype';\n        const isElementIdInExceptionsArray = hasElementGfxdataAttribute &&\n            exceptionIds.some(item => el.getAttribute('id').includes(item));\n        // If shape element has 'o:gfxdata' attribute and is not directly before\n        // `<v:shapetype>` element it means that it represents a Word shape.\n        if (isElementAShape &&\n            hasElementGfxdataAttribute &&\n            !isPreviousSiblingAShapeType &&\n            !isElementIdInExceptionsArray) {\n            shapesIds.push(value.item.getAttribute('id'));\n        }\n    }\n    return shapesIds;\n}\n/**\n * Removes all `<img>` elements which represents Word shapes and not regular images.\n *\n * @param shapesIds Shape ids which will be checked against `<img>` elements.\n * @param documentFragment Document fragment from which to remove `<img>` elements.\n */\nfunction removeAllImgElementsRepresentingShapes(shapesIds, documentFragment, writer) {\n    const range = writer.createRangeIn(documentFragment);\n    const imageElementsMatcher = new Matcher({\n        name: 'img'\n    });\n    const imgs = [];\n    for (const value of range) {\n        if (value.item.is('element') && imageElementsMatcher.match(value.item)) {\n            const el = value.item;\n            const shapes = el.getAttribute('v:shapes') ? el.getAttribute('v:shapes').split(' ') : [];\n            if (shapes.length && shapes.every(shape => shapesIds.indexOf(shape) > -1)) {\n                imgs.push(el);\n                // Shapes may also have empty source while content is paste in some browsers (Safari).\n            }\n            else if (!el.getAttribute('src')) {\n                imgs.push(el);\n            }\n        }\n    }\n    for (const img of imgs) {\n        writer.remove(img);\n    }\n}\n/**\n * Removes all shape elements (`<v:*>...</v:*>`) so they do not pollute the output structure.\n *\n * @param documentFragment Document fragment from which to remove shape elements.\n */\nfunction removeAllShapeElements(documentFragment, writer) {\n    const range = writer.createRangeIn(documentFragment);\n    const shapeElementsMatcher = new Matcher({\n        name: /v:(.+)/\n    });\n    const shapes = [];\n    for (const value of range) {\n        if (value.type == 'elementStart' && shapeElementsMatcher.match(value.item)) {\n            shapes.push(value.item);\n        }\n    }\n    for (const shape of shapes) {\n        writer.remove(shape);\n    }\n}\n/**\n * Inserts `img` tags if there is none after a shape.\n */\nfunction insertMissingImgs(shapeIds, documentFragment, writer) {\n    const range = writer.createRangeIn(documentFragment);\n    const shapes = [];\n    for (const value of range) {\n        if (value.type == 'elementStart' && value.item.is('element', 'v:shape')) {\n            const id = value.item.getAttribute('id');\n            if (shapeIds.includes(id)) {\n                continue;\n            }\n            if (!containsMatchingImg(value.item.parent.getChildren(), id)) {\n                shapes.push(value.item);\n            }\n        }\n    }\n    for (const shape of shapes) {\n        const attrs = {\n            src: findSrc(shape)\n        };\n        if (shape.hasAttribute('alt')) {\n            attrs.alt = shape.getAttribute('alt');\n        }\n        const img = writer.createElement('img', attrs);\n        writer.insertChild(shape.index + 1, img, shape.parent);\n    }\n    function containsMatchingImg(nodes, id) {\n        for (const node of nodes) {\n            /* istanbul ignore else -- @preserve */\n            if (node.is('element')) {\n                if (node.name == 'img' && node.getAttribute('v:shapes') == id) {\n                    return true;\n                }\n                if (containsMatchingImg(node.getChildren(), id)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    function findSrc(shape) {\n        for (const child of shape.getChildren()) {\n            /* istanbul ignore else -- @preserve */\n            if (child.is('element') && child.getAttribute('src')) {\n                return child.getAttribute('src');\n            }\n        }\n    }\n}\n/**\n * Finds all `<img>` elements in a given document fragment which have source pointing to local `file://` resource.\n *\n * @param documentFragment Document fragment in which to look for `<img>` elements.\n * @returns result All found images grouped by source type.\n */\nfunction findAllImageElementsWithLocalSource(documentFragment, writer) {\n    const range = writer.createRangeIn(documentFragment);\n    const imageElementsMatcher = new Matcher({\n        name: 'img'\n    });\n    const imgs = [];\n    for (const value of range) {\n        if (value.item.is('element') && imageElementsMatcher.match(value.item)) {\n            if (value.item.getAttribute('src').startsWith('file://')) {\n                imgs.push(value.item);\n            }\n        }\n    }\n    return imgs;\n}\n/**\n * Extracts all images HEX representations from a given RTF data.\n *\n * @param rtfData The RTF data from which to extract images HEX representation.\n * @returns Array of found HEX representations. Each array item is an object containing:\n *\n * * hex Image representation in HEX format.\n * * type Type of image, `image/png` or `image/jpeg`.\n */\nfunction extractImageDataFromRtf(rtfData) {\n    if (!rtfData) {\n        return [];\n    }\n    const regexPictureHeader = /{\\\\pict[\\s\\S]+?\\\\bliptag-?\\d+(\\\\blipupi-?\\d+)?({\\\\\\*\\\\blipuid\\s?[\\da-fA-F]+)?[\\s}]*?/;\n    const regexPicture = new RegExp('(?:(' + regexPictureHeader.source + '))([\\\\da-fA-F\\\\s]+)\\\\}', 'g');\n    const images = rtfData.match(regexPicture);\n    const result = [];\n    if (images) {\n        for (const image of images) {\n            let imageType = false;\n            if (image.includes('\\\\pngblip')) {\n                imageType = 'image/png';\n            }\n            else if (image.includes('\\\\jpegblip')) {\n                imageType = 'image/jpeg';\n            }\n            if (imageType) {\n                result.push({\n                    hex: image.replace(regexPictureHeader, '').replace(/[^\\da-fA-F]/g, ''),\n                    type: imageType\n                });\n            }\n        }\n    }\n    return result;\n}\n/**\n * Replaces `src` attribute value of all given images with the corresponding base64 image representation.\n *\n * @param imageElements Array of image elements which will have its source replaced.\n * @param imagesHexSources Array of images hex sources (usually the result of `extractImageDataFromRtf()` function).\n * The array should be the same length as `imageElements` parameter.\n */\nfunction replaceImagesFileSourceWithInlineRepresentation(imageElements, imagesHexSources, writer) {\n    // Assume there is an equal amount of image elements and images HEX sources so they can be matched accordingly based on existing order.\n    if (imageElements.length === imagesHexSources.length) {\n        for (let i = 0; i < imageElements.length; i++) {\n            const newSrc = `data:${imagesHexSources[i].type};base64,${_convertHexToBase64(imagesHexSources[i].hex)}`;\n            writer.setAttribute('src', newSrc, imageElements[i]);\n        }\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module paste-from-office/filters/removemsattributes\n */\nimport { UpcastWriter } from 'ckeditor5/src/engine.js';\n/**\n * Cleanup MS attributes like styles, attributes and elements.\n *\n * @param documentFragment element `data.content` obtained from clipboard.\n */\nexport default function removeMSAttributes(documentFragment) {\n    const elementsToUnwrap = [];\n    const writer = new UpcastWriter(documentFragment.document);\n    for (const { item } of writer.createRangeIn(documentFragment)) {\n        if (!item.is('element')) {\n            continue;\n        }\n        for (const className of item.getClassNames()) {\n            if (/\\bmso/gi.exec(className)) {\n                writer.removeClass(className, item);\n            }\n        }\n        for (const styleName of item.getStyleNames()) {\n            if (/\\bmso/gi.exec(styleName)) {\n                writer.removeStyle(styleName, item);\n            }\n        }\n        if (item.is('element', 'w:sdt')) {\n            elementsToUnwrap.push(item);\n        }\n    }\n    for (const item of elementsToUnwrap) {\n        const itemParent = item.parent;\n        const childIndex = itemParent.getChildIndex(item);\n        writer.insertChild(childIndex, item.getChildren(), itemParent);\n        writer.remove(item);\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module paste-from-office/normalizers/mswordnormalizer\n */\nimport { transformListItemLikeElementsIntoLists } from '../filters/list.js';\nimport { replaceImagesSourceWithBase64 } from '../filters/image.js';\nimport removeMSAttributes from '../filters/removemsattributes.js';\nconst msWordMatch1 = /<meta\\s*name=\"?generator\"?\\s*content=\"?microsoft\\s*word\\s*\\d+\"?\\/?>/i;\nconst msWordMatch2 = /xmlns:o=\"urn:schemas-microsoft-com/i;\n/**\n * Normalizer for the content pasted from Microsoft Word.\n */\nexport default class MSWordNormalizer {\n    /**\n     * Creates a new `MSWordNormalizer` instance.\n     *\n     * @param document View document.\n     */\n    constructor(document) {\n        this.document = document;\n    }\n    /**\n     * @inheritDoc\n     */\n    isActive(htmlString) {\n        return msWordMatch1.test(htmlString) || msWordMatch2.test(htmlString);\n    }\n    /**\n     * @inheritDoc\n     */\n    execute(data) {\n        const { body: documentFragment, stylesString } = data._parsedData;\n        transformListItemLikeElementsIntoLists(documentFragment, stylesString);\n        replaceImagesSourceWithBase64(documentFragment, data.dataTransfer.getData('text/rtf'));\n        removeMSAttributes(documentFragment);\n        data.content = documentFragment;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * Removes the `<b>` tag wrapper added by Google Docs to a copied content.\n *\n * @param documentFragment element `data.content` obtained from clipboard\n */\nexport default function removeBoldWrapper(documentFragment, writer) {\n    for (const child of documentFragment.getChildren()) {\n        if (child.is('element', 'b') && child.getStyle('font-weight') === 'normal') {\n            const childIndex = documentFragment.getChildIndex(child);\n            writer.remove(child);\n            writer.insertChild(childIndex, child.getChildren(), documentFragment);\n        }\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module paste-from-office/filters/br\n */\nimport { DomConverter, ViewDocument } from 'ckeditor5/src/engine.js';\n/**\n * Transforms `<br>` elements that are siblings to some block element into a paragraphs.\n *\n * @param documentFragment The view structure to be transformed.\n */\nexport default function transformBlockBrsToParagraphs(documentFragment, writer) {\n    const viewDocument = new ViewDocument(writer.document.stylesProcessor);\n    const domConverter = new DomConverter(viewDocument, { renderingMode: 'data' });\n    const blockElements = domConverter.blockElements;\n    const inlineObjectElements = domConverter.inlineObjectElements;\n    const elementsToReplace = [];\n    for (const value of writer.createRangeIn(documentFragment)) {\n        const element = value.item;\n        if (element.is('element', 'br')) {\n            const nextSibling = findSibling(element, 'forward', writer, { blockElements, inlineObjectElements });\n            const previousSibling = findSibling(element, 'backward', writer, { blockElements, inlineObjectElements });\n            const nextSiblingIsBlock = isBlockViewElement(nextSibling, blockElements);\n            const previousSiblingIsBlock = isBlockViewElement(previousSibling, blockElements);\n            // If the <br> is surrounded by blocks then convert it to a paragraph:\n            // * <p>foo</p>[<br>]<p>bar</p> -> <p>foo</p>[<p></p>]<p>bar</p>\n            // * <p>foo</p>[<br>] -> <p>foo</p>[<p></p>]\n            // * [<br>]<p>foo</p> -> [<p></p>]<p>foo</p>\n            if (previousSiblingIsBlock || nextSiblingIsBlock) {\n                elementsToReplace.push(element);\n            }\n        }\n    }\n    for (const element of elementsToReplace) {\n        if (element.hasClass('Apple-interchange-newline')) {\n            writer.remove(element);\n        }\n        else {\n            writer.replace(element, writer.createElement('p'));\n        }\n    }\n}\n/**\n * Returns sibling node, threats inline elements as transparent (but should stop on an inline objects).\n */\nfunction findSibling(viewElement, direction, writer, { blockElements, inlineObjectElements }) {\n    let position = writer.createPositionAt(viewElement, direction == 'forward' ? 'after' : 'before');\n    // Find first position that is just before a first:\n    // * text node,\n    // * block element,\n    // * inline object element.\n    // It's ignoring any inline (non-object) elements like span, strong, etc.\n    position = position.getLastMatchingPosition(({ item }) => (item.is('element') &&\n        !blockElements.includes(item.name) &&\n        !inlineObjectElements.includes(item.name)), { direction });\n    return direction == 'forward' ? position.nodeAfter : position.nodeBefore;\n}\n/**\n * Returns true for view elements that are listed as block view elements.\n */\nfunction isBlockViewElement(node, blockElements) {\n    return !!node && node.is('element') && blockElements.includes(node.name);\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module paste-from-office/normalizers/googledocsnormalizer\n */\nimport { UpcastWriter } from 'ckeditor5/src/engine.js';\nimport removeBoldWrapper from '../filters/removeboldwrapper.js';\nimport transformBlockBrsToParagraphs from '../filters/br.js';\nimport { unwrapParagraphInListItem } from '../filters/list.js';\nconst googleDocsMatch = /id=(\"|')docs-internal-guid-[-0-9a-f]+(\"|')/i;\n/**\n * Normalizer for the content pasted from Google Docs.\n */\nexport default class GoogleDocsNormalizer {\n    /**\n     * Creates a new `GoogleDocsNormalizer` instance.\n     *\n     * @param document View document.\n     */\n    constructor(document) {\n        this.document = document;\n    }\n    /**\n     * @inheritDoc\n     */\n    isActive(htmlString) {\n        return googleDocsMatch.test(htmlString);\n    }\n    /**\n     * @inheritDoc\n     */\n    execute(data) {\n        const writer = new UpcastWriter(this.document);\n        const { body: documentFragment } = data._parsedData;\n        removeBoldWrapper(documentFragment, writer);\n        unwrapParagraphInListItem(documentFragment, writer);\n        transformBlockBrsToParagraphs(documentFragment, writer);\n        data.content = documentFragment;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * Removes the `xmlns` attribute from table pasted from Google Sheets.\n *\n * @param documentFragment element `data.content` obtained from clipboard\n */\nexport default function removeXmlns(documentFragment, writer) {\n    for (const child of documentFragment.getChildren()) {\n        if (child.is('element', 'table') && child.hasAttribute('xmlns')) {\n            writer.removeAttribute('xmlns', child);\n        }\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * Removes the `<google-sheets-html-origin>` tag wrapper added by Google Sheets to a copied content.\n *\n * @param documentFragment element `data.content` obtained from clipboard\n */\nexport default function removeGoogleSheetsTag(documentFragment, writer) {\n    for (const child of documentFragment.getChildren()) {\n        if (child.is('element', 'google-sheets-html-origin')) {\n            const childIndex = documentFragment.getChildIndex(child);\n            writer.remove(child);\n            writer.insertChild(childIndex, child.getChildren(), documentFragment);\n        }\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * Removes the `width:0px` style from table pasted from Google Sheets.\n *\n * @param documentFragment element `data.content` obtained from clipboard\n */\nexport default function removeInvalidTableWidth(documentFragment, writer) {\n    for (const child of documentFragment.getChildren()) {\n        if (child.is('element', 'table') && child.getStyle('width') === '0px') {\n            writer.removeStyle('width', child);\n        }\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * Removes `<style>` block added by Google Sheets to a copied content.\n *\n * @param documentFragment element `data.content` obtained from clipboard\n */\nexport default function removeStyleBlock(documentFragment, writer) {\n    for (const child of Array.from(documentFragment.getChildren())) {\n        if (child.is('element', 'style')) {\n            writer.remove(child);\n        }\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module paste-from-office/normalizers/googlesheetsnormalizer\n */\nimport { UpcastWriter } from 'ckeditor5/src/engine.js';\nimport removeXmlns from '../filters/removexmlns.js';\nimport removeGoogleSheetsTag from '../filters/removegooglesheetstag.js';\nimport removeInvalidTableWidth from '../filters/removeinvalidtablewidth.js';\nimport removeStyleBlock from '../filters/removestyleblock.js';\nconst googleSheetsMatch = /<google-sheets-html-origin/i;\n/**\n * Normalizer for the content pasted from Google Sheets.\n */\nexport default class GoogleSheetsNormalizer {\n    /**\n     * Creates a new `GoogleSheetsNormalizer` instance.\n     *\n     * @param document View document.\n     */\n    constructor(document) {\n        this.document = document;\n    }\n    /**\n     * @inheritDoc\n     */\n    isActive(htmlString) {\n        return googleSheetsMatch.test(htmlString);\n    }\n    /**\n     * @inheritDoc\n     */\n    execute(data) {\n        const writer = new UpcastWriter(this.document);\n        const { body: documentFragment } = data._parsedData;\n        removeGoogleSheetsTag(documentFragment, writer);\n        removeXmlns(documentFragment, writer);\n        removeInvalidTableWidth(documentFragment, writer);\n        removeStyleBlock(documentFragment, writer);\n        data.content = documentFragment;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module paste-from-office/filters/space\n */\n/**\n * Replaces last space preceding elements closing tag with `&nbsp;`. Such operation prevents spaces from being removed\n * during further DOM/View processing (see especially {@link module:engine/view/domconverter~DomConverter#_processDomInlineNodes}).\n * This method also takes into account Word specific `<o:p></o:p>` empty tags.\n * Additionally multiline sequences of spaces and new lines between tags are removed (see #39 and #40).\n *\n * @param htmlString HTML string in which spacing should be normalized.\n * @returns Input HTML with spaces normalized.\n */\nexport function normalizeSpacing(htmlString) {\n    // Run normalizeSafariSpaceSpans() two times to cover nested spans.\n    return normalizeSafariSpaceSpans(normalizeSafariSpaceSpans(htmlString))\n        // Remove all \\r\\n from \"spacerun spans\" so the last replace line doesn't strip all whitespaces.\n        .replace(/(<span\\s+style=['\"]mso-spacerun:yes['\"]>[^\\S\\r\\n]*?)[\\r\\n]+([^\\S\\r\\n]*<\\/span>)/g, '$1$2')\n        .replace(/<span\\s+style=['\"]mso-spacerun:yes['\"]><\\/span>/g, '')\n        .replace(/(<span\\s+style=['\"]letter-spacing:[^'\"]+?['\"]>)[\\r\\n]+(<\\/span>)/g, '$1 $2')\n        .replace(/ <\\//g, '\\u00A0</')\n        .replace(/ <o:p><\\/o:p>/g, '\\u00A0<o:p></o:p>')\n        // Remove <o:p> block filler from empty paragraph. Safari uses \\u00A0 instead of &nbsp;.\n        .replace(/<o:p>(&nbsp;|\\u00A0)<\\/o:p>/g, '')\n        // Remove all whitespaces when they contain any \\r or \\n.\n        .replace(/>([^\\S\\r\\n]*[\\r\\n]\\s*)</g, '><');\n}\n/**\n * Normalizes spacing in special Word `spacerun spans` (`<span style='mso-spacerun:yes'>\\s+</span>`) by replacing\n * all spaces with `&nbsp; ` pairs. This prevents spaces from being removed during further DOM/View processing\n * (see especially {@link module:engine/view/domconverter~DomConverter#_processDomInlineNodes}).\n *\n * @param htmlDocument Native `Document` object in which spacing should be normalized.\n */\nexport function normalizeSpacerunSpans(htmlDocument) {\n    htmlDocument.querySelectorAll('span[style*=spacerun]').forEach(el => {\n        const htmlElement = el;\n        const innerTextLength = htmlElement.innerText.length || 0;\n        htmlElement.innerText = Array(innerTextLength + 1).join('\\u00A0 ').substr(0, innerTextLength);\n    });\n}\n/**\n * Normalizes specific spacing generated by Safari when content pasted from Word (`<span class=\"Apple-converted-space\"> </span>`)\n * by replacing all spaces sequences longer than 1 space with `&nbsp; ` pairs. This prevents spaces from being removed during\n * further DOM/View processing (see especially {@link module:engine/view/domconverter~DomConverter#_processDataFromDomText}).\n *\n * This function is similar to {@link module:clipboard/utils/normalizeclipboarddata normalizeClipboardData util} but uses\n * regular spaces / &nbsp; sequence for replacement.\n *\n * @param htmlString HTML string in which spacing should be normalized\n * @returns Input HTML with spaces normalized.\n */\nfunction normalizeSafariSpaceSpans(htmlString) {\n    return htmlString.replace(/<span(?: class=\"Apple-converted-space\"|)>(\\s+)<\\/span>/g, (fullMatch, spaces) => {\n        return spaces.length === 1 ? ' ' : Array(spaces.length + 1).join('\\u00A0 ').substr(0, spaces.length);\n    });\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module paste-from-office/filters/parse\n */\n/* globals DOMParser */\nimport { DomConverter, ViewDocument } from 'ckeditor5/src/engine.js';\nimport { normalizeSpacing, normalizeSpacerunSpans } from './space.js';\n/**\n * Parses the provided HTML extracting contents of `<body>` and `<style>` tags.\n *\n * @param htmlString HTML string to be parsed.\n */\nexport function parseHtml(htmlString, stylesProcessor) {\n    const domParser = new DOMParser();\n    // Remove Word specific \"if comments\" so content inside is not omitted by the parser.\n    htmlString = htmlString.replace(/<!--\\[if gte vml 1]>/g, '');\n    // Clean the <head> section of MS Windows specific tags. See https://github.com/ckeditor/ckeditor5/issues/15333.\n    // The regular expression matches the <o:SmartTagType> tag with optional attributes (with or without values).\n    htmlString = htmlString.replace(/<o:SmartTagType(?:\\s+[^\\s>=]+(?:=\"[^\"]*\")?)*\\s*\\/?>/gi, '');\n    const normalizedHtml = normalizeSpacing(cleanContentAfterBody(htmlString));\n    // Parse htmlString as native Document object.\n    const htmlDocument = domParser.parseFromString(normalizedHtml, 'text/html');\n    normalizeSpacerunSpans(htmlDocument);\n    // Get `innerHTML` first as transforming to View modifies the source document.\n    const bodyString = htmlDocument.body.innerHTML;\n    // Transform document.body to View.\n    const bodyView = documentToView(htmlDocument, stylesProcessor);\n    // Extract stylesheets.\n    const stylesObject = extractStyles(htmlDocument);\n    return {\n        body: bodyView,\n        bodyString,\n        styles: stylesObject.styles,\n        stylesString: stylesObject.stylesString\n    };\n}\n/**\n * Transforms native `Document` object into {@link module:engine/view/documentfragment~DocumentFragment}. Comments are skipped.\n *\n * @param htmlDocument Native `Document` object to be transformed.\n */\nfunction documentToView(htmlDocument, stylesProcessor) {\n    const viewDocument = new ViewDocument(stylesProcessor);\n    const domConverter = new DomConverter(viewDocument, { renderingMode: 'data' });\n    const fragment = htmlDocument.createDocumentFragment();\n    const nodes = htmlDocument.body.childNodes;\n    while (nodes.length > 0) {\n        fragment.appendChild(nodes[0]);\n    }\n    return domConverter.domToView(fragment, { skipComments: true });\n}\n/**\n * Extracts both `CSSStyleSheet` and string representation from all `style` elements available in a provided `htmlDocument`.\n *\n * @param htmlDocument Native `Document` object from which styles will be extracted.\n */\nfunction extractStyles(htmlDocument) {\n    const styles = [];\n    const stylesString = [];\n    const styleTags = Array.from(htmlDocument.getElementsByTagName('style'));\n    for (const style of styleTags) {\n        if (style.sheet && style.sheet.cssRules && style.sheet.cssRules.length) {\n            styles.push(style.sheet);\n            stylesString.push(style.innerHTML);\n        }\n    }\n    return {\n        styles,\n        stylesString: stylesString.join(' ')\n    };\n}\n/**\n * Removes leftover content from between closing </body> and closing </html> tag:\n *\n * ```html\n * <html><body><p>Foo Bar</p></body><span>Fo</span></html> -> <html><body><p>Foo Bar</p></body></html>\n * ```\n *\n * This function is used as specific browsers (Edge) add some random content after `body` tag when pasting from Word.\n * @param htmlString The HTML string to be cleaned.\n * @returns The HTML string with leftover content removed.\n */\nfunction cleanContentAfterBody(htmlString) {\n    const bodyCloseTag = '</body>';\n    const htmlCloseTag = '</html>';\n    const bodyCloseIndex = htmlString.indexOf(bodyCloseTag);\n    if (bodyCloseIndex < 0) {\n        return htmlString;\n    }\n    const htmlCloseIndex = htmlString.indexOf(htmlCloseTag, bodyCloseIndex + bodyCloseTag.length);\n    return htmlString.substring(0, bodyCloseIndex + bodyCloseTag.length) +\n        (htmlCloseIndex >= 0 ? htmlString.substring(htmlCloseIndex) : '');\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module paste-from-office/pastefromoffice\n */\nimport { Plugin } from 'ckeditor5/src/core.js';\nimport { ClipboardPipeline } from 'ckeditor5/src/clipboard.js';\nimport MSWordNormalizer from './normalizers/mswordnormalizer.js';\nimport GoogleDocsNormalizer from './normalizers/googledocsnormalizer.js';\nimport GoogleSheetsNormalizer from './normalizers/googlesheetsnormalizer.js';\nimport { parseHtml } from './filters/parse.js';\n/**\n * The Paste from Office plugin.\n *\n * This plugin handles content pasted from Office apps and transforms it (if necessary)\n * to a valid structure which can then be understood by the editor features.\n *\n * Transformation is made by a set of predefined {@link module:paste-from-office/normalizer~Normalizer normalizers}.\n * This plugin includes following normalizers:\n * * {@link module:paste-from-office/normalizers/mswordnormalizer~MSWordNormalizer Microsoft Word normalizer}\n * * {@link module:paste-from-office/normalizers/googledocsnormalizer~GoogleDocsNormalizer Google Docs normalizer}\n *\n * For more information about this feature check the {@glink api/paste-from-office package page}.\n */\nexport default class PasteFromOffice extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'PasteFromOffice';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [ClipboardPipeline];\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const clipboardPipeline = editor.plugins.get('ClipboardPipeline');\n        const viewDocument = editor.editing.view.document;\n        const normalizers = [];\n        normalizers.push(new MSWordNormalizer(viewDocument));\n        normalizers.push(new GoogleDocsNormalizer(viewDocument));\n        normalizers.push(new GoogleSheetsNormalizer(viewDocument));\n        clipboardPipeline.on('inputTransformation', (evt, data) => {\n            if (data._isTransformedWithPasteFromOffice) {\n                return;\n            }\n            const codeBlock = editor.model.document.selection.getFirstPosition().parent;\n            if (codeBlock.is('element', 'codeBlock')) {\n                return;\n            }\n            const htmlString = data.dataTransfer.getData('text/html');\n            const activeNormalizer = normalizers.find(normalizer => normalizer.isActive(htmlString));\n            if (activeNormalizer) {\n                if (!data._parsedData) {\n                    data._parsedData = parseHtml(htmlString, viewDocument.stylesProcessor);\n                }\n                activeNormalizer.execute(data);\n                data._isTransformedWithPasteFromOffice = true;\n            }\n        }, { priority: 'high' });\n    }\n}\n"],
  "mappings": "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",
  "names": ["document", "document", "document"]
}
