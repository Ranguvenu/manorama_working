import "./chunk-U5S3T6FN.js";
import {
  ButtonView
} from "./chunk-2UXKTWKP.js";
import "./chunk-GJCFV3G2.js";
import {
  CKEditorError,
  ElementReplacer,
  createElement
} from "./chunk-MFEZX3FO.js";
import {
  PendingActions,
  Plugin
} from "./chunk-YB4X7RFQ.js";
import "./chunk-VMNDBVXW.js";
import "./chunk-LQD6FQVM.js";
import "./chunk-ROME4SDB.js";

// node_modules/@ckeditor/ckeditor5-source-editing/src/utils/formathtml.js
function formatHtml(input) {
  const elementsToFormat = [
    { name: "address", isVoid: false },
    { name: "article", isVoid: false },
    { name: "aside", isVoid: false },
    { name: "blockquote", isVoid: false },
    { name: "details", isVoid: false },
    { name: "dialog", isVoid: false },
    { name: "dd", isVoid: false },
    { name: "div", isVoid: false },
    { name: "dl", isVoid: false },
    { name: "dt", isVoid: false },
    { name: "fieldset", isVoid: false },
    { name: "figcaption", isVoid: false },
    { name: "figure", isVoid: false },
    { name: "footer", isVoid: false },
    { name: "form", isVoid: false },
    { name: "h1", isVoid: false },
    { name: "h2", isVoid: false },
    { name: "h3", isVoid: false },
    { name: "h4", isVoid: false },
    { name: "h5", isVoid: false },
    { name: "h6", isVoid: false },
    { name: "header", isVoid: false },
    { name: "hgroup", isVoid: false },
    { name: "hr", isVoid: true },
    { name: "li", isVoid: false },
    { name: "main", isVoid: false },
    { name: "nav", isVoid: false },
    { name: "ol", isVoid: false },
    { name: "p", isVoid: false },
    { name: "section", isVoid: false },
    { name: "table", isVoid: false },
    { name: "tbody", isVoid: false },
    { name: "td", isVoid: false },
    { name: "th", isVoid: false },
    { name: "thead", isVoid: false },
    { name: "tr", isVoid: false },
    { name: "ul", isVoid: false }
  ];
  const elementNamesToFormat = elementsToFormat.map((element) => element.name).join("|");
  const lines = input.replace(new RegExp(`</?(${elementNamesToFormat})( .*?)?>`, "g"), "\n$&\n").replace(/<br[^>]*>/g, "$&\n").split("\n");
  let indentCount = 0;
  let isPreformattedLine = false;
  return lines.filter((line) => line.length).map((line) => {
    isPreformattedLine = isPreformattedBlockLine(line, isPreformattedLine);
    if (isNonVoidOpeningTag(line, elementsToFormat)) {
      return indentLine(line, indentCount++);
    }
    if (isClosingTag(line, elementsToFormat)) {
      return indentLine(line, --indentCount);
    }
    if (isPreformattedLine === "middle" || isPreformattedLine === "last") {
      return line;
    }
    return indentLine(line, indentCount);
  }).join("\n");
}
function isNonVoidOpeningTag(line, elementsToFormat) {
  return elementsToFormat.some((element) => {
    if (element.isVoid) {
      return false;
    }
    if (!new RegExp(`<${element.name}( .*?)?>`).test(line)) {
      return false;
    }
    return true;
  });
}
function isClosingTag(line, elementsToFormat) {
  return elementsToFormat.some((element) => {
    return new RegExp(`</${element.name}>`).test(line);
  });
}
function indentLine(line, indentCount, indentChar = "    ") {
  return `${indentChar.repeat(Math.max(0, indentCount))}${line}`;
}
function isPreformattedBlockLine(line, isPreviousLinePreFormatted) {
  if (new RegExp("<pre( .*?)?>").test(line)) {
    return "first";
  } else if (new RegExp("</pre>").test(line)) {
    return "last";
  } else if (isPreviousLinePreFormatted === "first" || isPreviousLinePreFormatted === "middle") {
    return "middle";
  } else {
    return false;
  }
}

// node_modules/@ckeditor/ckeditor5-source-editing/src/sourceediting.js
import "/var/www/html/manorama/node_modules/@ckeditor/ckeditor5-source-editing/theme/sourceediting.css";
import sourceEditingIcon from "/var/www/html/manorama/node_modules/@ckeditor/ckeditor5-source-editing/theme/icons/source-editing.svg";
var COMMAND_FORCE_DISABLE_ID = "SourceEditingMode";
var SourceEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "SourceEditing";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [PendingActions];
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    this.set("isSourceEditingMode", false);
    this._elementReplacer = new ElementReplacer();
    this._replacedRoots = /* @__PURE__ */ new Map();
    this._dataFromRoots = /* @__PURE__ */ new Map();
    editor.config.define("sourceEditing.allowCollaborationFeatures", false);
  }
  /**
   * @inheritDoc
   */
  init() {
    this._checkCompatibility();
    const editor = this.editor;
    const t = editor.t;
    editor.ui.componentFactory.add("sourceEditing", (locale) => {
      const buttonView = new ButtonView(locale);
      buttonView.set({
        label: t("Source"),
        icon: sourceEditingIcon,
        tooltip: true,
        withText: true,
        class: "ck-source-editing-button"
      });
      buttonView.bind("isOn").to(this, "isSourceEditingMode");
      buttonView.bind("isEnabled").to(this, "isEnabled", editor, "isReadOnly", editor.plugins.get(PendingActions), "hasAny", (isEnabled, isEditorReadOnly, hasAnyPendingActions) => {
        if (!isEnabled) {
          return false;
        }
        if (isEditorReadOnly) {
          return false;
        }
        if (hasAnyPendingActions) {
          return false;
        }
        return true;
      });
      this.listenTo(buttonView, "execute", () => {
        this.isSourceEditingMode = !this.isSourceEditingMode;
      });
      return buttonView;
    });
    if (this._isAllowedToHandleSourceEditingMode()) {
      this.on("change:isSourceEditingMode", (evt, name, isSourceEditingMode) => {
        if (isSourceEditingMode) {
          this._hideVisibleDialog();
          this._showSourceEditing();
          this._disableCommands();
        } else {
          this._hideSourceEditing();
          this._enableCommands();
        }
      });
      this.on("change:isEnabled", (evt, name, isEnabled) => this._handleReadOnlyMode(!isEnabled));
      this.listenTo(editor, "change:isReadOnly", (evt, name, isReadOnly) => this._handleReadOnlyMode(isReadOnly));
    }
    editor.data.on("get", () => {
      if (this.isSourceEditingMode) {
        this.updateEditorData();
      }
    }, { priority: "high" });
  }
  /**
   * Updates the source data in all hidden editing roots.
   */
  updateEditorData() {
    const editor = this.editor;
    const data = {};
    for (const [rootName, domSourceEditingElementWrapper] of this._replacedRoots) {
      const oldData = this._dataFromRoots.get(rootName);
      const newData = domSourceEditingElementWrapper.dataset.value;
      if (oldData !== newData) {
        data[rootName] = newData;
        this._dataFromRoots.set(rootName, newData);
      }
    }
    if (Object.keys(data).length) {
      editor.data.set(data, { batchType: { isUndoable: true }, suppressErrorInCollaboration: true });
    }
  }
  _checkCompatibility() {
    const editor = this.editor;
    const allowCollaboration = editor.config.get("sourceEditing.allowCollaborationFeatures");
    if (!allowCollaboration && editor.plugins.has("RealTimeCollaborativeEditing")) {
      throw new CKEditorError("source-editing-incompatible-with-real-time-collaboration", null);
    }
    const collaborationPluginNamesToWarn = [
      "CommentsEditing",
      "TrackChangesEditing",
      "RevisionHistory"
    ];
    if (!allowCollaboration && collaborationPluginNamesToWarn.some((pluginName) => editor.plugins.has(pluginName))) {
      console.warn("You initialized the editor with the source editing feature and at least one of the collaboration features. Please be advised that the source editing feature may not work, and be careful when editing document source that contains markers created by the collaboration features.");
    }
    if (editor.plugins.has("RestrictedEditingModeEditing")) {
      console.warn("You initialized the editor with the source editing feature and restricted editing feature. Please be advised that the source editing feature may not work, and be careful when editing document source that contains markers created by the restricted editing feature.");
    }
  }
  /**
   * Creates source editing wrappers that replace each editing root. Each wrapper contains the document source from the corresponding
   * root.
   *
   * The wrapper element contains a textarea and it solves the problem, that the textarea element cannot auto expand its height based on
   * the content it contains. The solution is to make the textarea more like a plain div element, which expands in height as much as it
   * needs to, in order to display the whole document source without scrolling. The wrapper element is a parent for the textarea and for
   * the pseudo-element `::after`, that replicates the look, content, and position of the textarea. The pseudo-element replica is hidden,
   * but it is styled to be an identical visual copy of the textarea with the same content. Then, the wrapper is a grid container and both
   * of its children (the textarea and the `::after` pseudo-element) are positioned within a CSS grid to occupy the same grid cell. The
   * content in the pseudo-element `::after` is set in CSS and it stretches the grid to the appropriate size based on the textarea value.
   * Since both children occupy the same grid cell, both have always the same height.
   */
  _showSourceEditing() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    const model = editor.model;
    model.change((writer) => {
      writer.setSelection(null);
      writer.removeSelectionAttribute(model.document.selection.getAttributeKeys());
    });
    for (const [rootName, domRootElement] of editingView.domRoots) {
      const data = formatSource(editor.data.get({ rootName }));
      const domSourceEditingElementTextarea = createElement(domRootElement.ownerDocument, "textarea", {
        rows: "1",
        "aria-label": "Source code editing area"
      });
      const domSourceEditingElementWrapper = createElement(domRootElement.ownerDocument, "div", {
        class: "ck-source-editing-area",
        "data-value": data
      }, [domSourceEditingElementTextarea]);
      domSourceEditingElementTextarea.value = data;
      domSourceEditingElementTextarea.setSelectionRange(0, 0);
      domSourceEditingElementTextarea.addEventListener("input", () => {
        domSourceEditingElementWrapper.dataset.value = domSourceEditingElementTextarea.value;
        editor.ui.update();
      });
      editingView.change((writer) => {
        const viewRoot = editingView.document.getRoot(rootName);
        writer.addClass("ck-hidden", viewRoot);
      });
      editor.ui.setEditableElement("sourceEditing:" + rootName, domSourceEditingElementTextarea);
      this._replacedRoots.set(rootName, domSourceEditingElementWrapper);
      this._elementReplacer.replace(domRootElement, domSourceEditingElementWrapper);
      this._dataFromRoots.set(rootName, data);
    }
    this._focusSourceEditing();
  }
  /**
   * Restores all hidden editing roots and sets the source data in them.
   */
  _hideSourceEditing() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    this.updateEditorData();
    editingView.change((writer) => {
      for (const [rootName] of this._replacedRoots) {
        writer.removeClass("ck-hidden", editingView.document.getRoot(rootName));
      }
    });
    this._elementReplacer.restore();
    this._replacedRoots.clear();
    this._dataFromRoots.clear();
    editingView.focus();
  }
  /**
   * Focuses the textarea containing document source from the first editing root.
   */
  _focusSourceEditing() {
    const editor = this.editor;
    const [domSourceEditingElementWrapper] = this._replacedRoots.values();
    const textarea = domSourceEditingElementWrapper.querySelector("textarea");
    editor.editing.view.document.isFocused = false;
    textarea.focus();
  }
  /**
   * Disables all commands.
   */
  _disableCommands() {
    const editor = this.editor;
    for (const command of editor.commands.commands()) {
      command.forceDisabled(COMMAND_FORCE_DISABLE_ID);
    }
  }
  /**
   * Clears forced disable for all commands, that was previously set through {@link #_disableCommands}.
   */
  _enableCommands() {
    const editor = this.editor;
    for (const command of editor.commands.commands()) {
      command.clearForceDisabled(COMMAND_FORCE_DISABLE_ID);
    }
  }
  /**
   * Adds or removes the `readonly` attribute from the textarea from all roots, if document source mode is active.
   *
   * @param isReadOnly Indicates whether all textarea elements should be read-only.
   */
  _handleReadOnlyMode(isReadOnly) {
    if (!this.isSourceEditingMode) {
      return;
    }
    for (const [, domSourceEditingElementWrapper] of this._replacedRoots) {
      domSourceEditingElementWrapper.querySelector("textarea").readOnly = isReadOnly;
    }
  }
  /**
   * Checks, if the plugin is allowed to handle the source editing mode by itself. Currently, the source editing mode is supported only
   * for the {@link module:editor-classic/classiceditor~ClassicEditor classic editor}.
   */
  _isAllowedToHandleSourceEditingMode() {
    const editor = this.editor;
    const editable = editor.ui.view.editable;
    return editable && !editable.hasExternalElement;
  }
  /**
   * If any {@link module:ui/dialog/dialogview~DialogView editor dialog} is currently visible, hide it.
   */
  _hideVisibleDialog() {
    if (this.editor.plugins.has("Dialog")) {
      const dialogPlugin = this.editor.plugins.get("Dialog");
      if (dialogPlugin.isOpen) {
        dialogPlugin.hide();
      }
    }
  }
};
function formatSource(input) {
  if (!isHtml(input)) {
    return input;
  }
  return formatHtml(input);
}
function isHtml(input) {
  return input.startsWith("<");
}
export {
  SourceEditing
};
/*! Bundled license information:

@ckeditor/ckeditor5-source-editing/src/utils/formathtml.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-source-editing/src/sourceediting.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-source-editing/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-source-editing/src/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=@ckeditor_ckeditor5-source-editing.js.map
