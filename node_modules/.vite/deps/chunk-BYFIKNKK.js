import {
  ObservableMixin,
  Rect,
  Template,
  View,
  compareArrays
} from "./chunk-XTWUOPXT.js";

// node_modules/@ckeditor/ckeditor5-widget/src/widgetresize/resizerstate.js
var ResizeState = class extends ObservableMixin() {
  /**
   * @param options Resizer options.
   */
  constructor(options) {
    super();
    this.set("activeHandlePosition", null);
    this.set("proposedWidthPercents", null);
    this.set("proposedWidth", null);
    this.set("proposedHeight", null);
    this.set("proposedHandleHostWidth", null);
    this.set("proposedHandleHostHeight", null);
    this._options = options;
    this._referenceCoordinates = null;
  }
  /**
   * The original width (pixels) of the resized object when the resize process was started.
   */
  get originalWidth() {
    return this._originalWidth;
  }
  /**
   * The original height (pixels) of the resized object when the resize process was started.
   */
  get originalHeight() {
    return this._originalHeight;
  }
  /**
   * The original width (percents) of the resized object when the resize process was started.
   */
  get originalWidthPercents() {
    return this._originalWidthPercents;
  }
  /**
   * A width to height ratio of the resized image.
   */
  get aspectRatio() {
    return this._aspectRatio;
  }
  /**
   *
   * @param domResizeHandle The handle used to calculate the reference point.
   */
  begin(domResizeHandle, domHandleHost, domResizeHost) {
    const clientRect = new Rect(domHandleHost);
    this.activeHandlePosition = getHandlePosition(domResizeHandle);
    this._referenceCoordinates = getAbsoluteBoundaryPoint(domHandleHost, getOppositePosition(this.activeHandlePosition));
    this._originalWidth = clientRect.width;
    this._originalHeight = clientRect.height;
    this._aspectRatio = clientRect.width / clientRect.height;
    const widthStyle = domResizeHost.style.width;
    if (widthStyle && widthStyle.match(/^\d+(\.\d*)?%$/)) {
      this._originalWidthPercents = parseFloat(widthStyle);
    } else {
      this._originalWidthPercents = calculateHostPercentageWidth(domResizeHost, clientRect);
    }
  }
  update(newSize) {
    this.proposedWidth = newSize.width;
    this.proposedHeight = newSize.height;
    this.proposedWidthPercents = newSize.widthPercents;
    this.proposedHandleHostWidth = newSize.handleHostWidth;
    this.proposedHandleHostHeight = newSize.handleHostHeight;
  }
};
function calculateHostPercentageWidth(domResizeHost, resizeHostRect) {
  const domResizeHostParent = domResizeHost.parentElement;
  let parentWidth = parseFloat(domResizeHostParent.ownerDocument.defaultView.getComputedStyle(domResizeHostParent).width);
  const ancestorLevelLimit = 5;
  let currentLevel = 0;
  let checkedElement = domResizeHostParent;
  while (isNaN(parentWidth)) {
    checkedElement = checkedElement.parentElement;
    if (++currentLevel > ancestorLevelLimit) {
      return 0;
    }
    parentWidth = parseFloat(domResizeHostParent.ownerDocument.defaultView.getComputedStyle(checkedElement).width);
  }
  return resizeHostRect.width / parentWidth * 100;
}
function getAbsoluteBoundaryPoint(element, resizerPosition) {
  const elementRect = new Rect(element);
  const positionParts = resizerPosition.split("-");
  const ret = {
    x: positionParts[1] == "right" ? elementRect.right : elementRect.left,
    y: positionParts[0] == "bottom" ? elementRect.bottom : elementRect.top
  };
  ret.x += element.ownerDocument.defaultView.scrollX;
  ret.y += element.ownerDocument.defaultView.scrollY;
  return ret;
}
function getResizerHandleClass(resizerPosition) {
  return `ck-widget__resizer__handle-${resizerPosition}`;
}
function getHandlePosition(domHandle) {
  const resizerPositions = ["top-left", "top-right", "bottom-right", "bottom-left"];
  for (const position of resizerPositions) {
    if (domHandle.classList.contains(getResizerHandleClass(position))) {
      return position;
    }
  }
}
function getOppositePosition(position) {
  const parts = position.split("-");
  const replacements = {
    top: "bottom",
    bottom: "top",
    left: "right",
    right: "left"
  };
  return `${replacements[parts[0]]}-${replacements[parts[1]]}`;
}

// node_modules/@ckeditor/ckeditor5-widget/src/widgetresize/sizeview.js
var SizeView = class extends View {
  constructor() {
    super();
    const bind = this.bindTemplate;
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-size-view",
          bind.to("_viewPosition", (value) => value ? `ck-orientation-${value}` : "")
        ],
        style: {
          display: bind.if("_isVisible", "none", (visible) => !visible)
        }
      },
      children: [{
        text: bind.to("_label")
      }]
    });
  }
  /**
   * A method used for binding the `SizeView` instance properties to the `ResizeState` instance observable properties.
   *
   * @internal
   * @param options An object defining the resizer options, used for setting the proper size label.
   * @param resizeState The `ResizeState` class instance, used for keeping the `SizeView` state up to date.
   */
  _bindToState(options, resizeState) {
    this.bind("_isVisible").to(resizeState, "proposedWidth", resizeState, "proposedHeight", (width, height) => width !== null && height !== null);
    this.bind("_label").to(resizeState, "proposedHandleHostWidth", resizeState, "proposedHandleHostHeight", resizeState, "proposedWidthPercents", (width, height, widthPercents) => {
      if (options.unit === "px") {
        return `${width}Ã—${height}`;
      } else {
        return `${widthPercents}%`;
      }
    });
    this.bind("_viewPosition").to(
      resizeState,
      "activeHandlePosition",
      resizeState,
      "proposedHandleHostWidth",
      resizeState,
      "proposedHandleHostHeight",
      // If the widget is too small to contain the size label, display the label above.
      (position, width, height) => width < 50 || height < 50 ? "above-center" : position
    );
  }
  /**
   * A method used for cleaning up. It removes the bindings and hides the view.
   *
   * @internal
   */
  _dismiss() {
    this.unbind();
    this._isVisible = false;
  }
};

// node_modules/@ckeditor/ckeditor5-widget/src/widgetresize/resizer.js
var Resizer = class extends ObservableMixin() {
  /**
   * @param options Resizer options.
   */
  constructor(options) {
    super();
    this._viewResizerWrapper = null;
    this._options = options;
    this.set("isEnabled", true);
    this.set("isSelected", false);
    this.bind("isVisible").to(this, "isEnabled", this, "isSelected", (isEnabled, isSelected) => isEnabled && isSelected);
    this.decorate("begin");
    this.decorate("cancel");
    this.decorate("commit");
    this.decorate("updateSize");
    this.on("commit", (event) => {
      if (!this.state.proposedWidth && !this.state.proposedWidthPercents) {
        this._cleanup();
        event.stop();
      }
    }, { priority: "high" });
  }
  /**
   * Stores the state of the resizable host geometry, such as the original width, the currently proposed height, etc.
   *
   * Note that a new state is created for each resize transaction.
   */
  get state() {
    return this._state;
  }
  /**
   * Makes resizer visible in the UI.
   */
  show() {
    const editingView = this._options.editor.editing.view;
    editingView.change((writer) => {
      writer.removeClass("ck-hidden", this._viewResizerWrapper);
    });
  }
  /**
   * Hides resizer in the UI.
   */
  hide() {
    const editingView = this._options.editor.editing.view;
    editingView.change((writer) => {
      writer.addClass("ck-hidden", this._viewResizerWrapper);
    });
  }
  /**
   * Attaches the resizer to the DOM.
   */
  attach() {
    const that = this;
    const widgetElement = this._options.viewElement;
    const editingView = this._options.editor.editing.view;
    editingView.change((writer) => {
      const viewResizerWrapper = writer.createUIElement("div", {
        class: "ck ck-reset_all ck-widget__resizer"
      }, function(domDocument) {
        const domElement = this.toDomElement(domDocument);
        that._appendHandles(domElement);
        that._appendSizeUI(domElement);
        return domElement;
      });
      writer.insert(writer.createPositionAt(widgetElement, "end"), viewResizerWrapper);
      writer.addClass("ck-widget_with-resizer", widgetElement);
      this._viewResizerWrapper = viewResizerWrapper;
      if (!this.isVisible) {
        this.hide();
      }
    });
    this.on("change:isVisible", () => {
      if (this.isVisible) {
        this.show();
        this.redraw();
      } else {
        this.hide();
      }
    });
  }
  /**
   * Starts the resizing process.
   *
   * Creates a new {@link #state} for the current process.
   *
   * @fires begin
   * @param domResizeHandle Clicked handle.
   */
  begin(domResizeHandle) {
    this._state = new ResizeState(this._options);
    this._sizeView._bindToState(this._options, this.state);
    this._initialViewWidth = this._options.viewElement.getStyle("width");
    this.state.begin(domResizeHandle, this._getHandleHost(), this._getResizeHost());
  }
  /**
   * Updates the proposed size based on `domEventData`.
   *
   * @fires updateSize
   */
  updateSize(domEventData) {
    const newSize = this._proposeNewSize(domEventData);
    const editingView = this._options.editor.editing.view;
    editingView.change((writer) => {
      const unit = this._options.unit || "%";
      const newWidth = (unit === "%" ? newSize.widthPercents : newSize.width) + unit;
      writer.setStyle("width", newWidth, this._options.viewElement);
    });
    const domHandleHost = this._getHandleHost();
    const domHandleHostRect = new Rect(domHandleHost);
    const handleHostWidth = Math.round(domHandleHostRect.width);
    const handleHostHeight = Math.round(domHandleHostRect.height);
    const domResizeHostRect = new Rect(domHandleHost);
    newSize.width = Math.round(domResizeHostRect.width);
    newSize.height = Math.round(domResizeHostRect.height);
    this.redraw(domHandleHostRect);
    this.state.update({
      ...newSize,
      handleHostWidth,
      handleHostHeight
    });
  }
  /**
   * Applies the geometry proposed with the resizer.
   *
   * @fires commit
   */
  commit() {
    const unit = this._options.unit || "%";
    const newValue = (unit === "%" ? this.state.proposedWidthPercents : this.state.proposedWidth) + unit;
    this._options.editor.editing.view.change(() => {
      this._cleanup();
      this._options.onCommit(newValue);
    });
  }
  /**
   * Cancels and rejects the proposed resize dimensions, hiding the UI.
   *
   * @fires cancel
   */
  cancel() {
    this._cleanup();
  }
  /**
   * Destroys the resizer.
   */
  destroy() {
    this.cancel();
  }
  /**
   * Redraws the resizer.
   *
   * @param handleHostRect Handle host rectangle might be given to improve performance.
   */
  redraw(handleHostRect) {
    const domWrapper = this._domResizerWrapper;
    if (!existsInDom(domWrapper)) {
      return;
    }
    const widgetWrapper = domWrapper.parentElement;
    const handleHost = this._getHandleHost();
    const resizerWrapper = this._viewResizerWrapper;
    const currentDimensions = [
      resizerWrapper.getStyle("width"),
      resizerWrapper.getStyle("height"),
      resizerWrapper.getStyle("left"),
      resizerWrapper.getStyle("top")
    ];
    let newDimensions;
    if (widgetWrapper.isSameNode(handleHost)) {
      const clientRect = handleHostRect || new Rect(handleHost);
      newDimensions = [
        clientRect.width + "px",
        clientRect.height + "px",
        void 0,
        void 0
      ];
    } else {
      newDimensions = [
        handleHost.offsetWidth + "px",
        handleHost.offsetHeight + "px",
        handleHost.offsetLeft + "px",
        handleHost.offsetTop + "px"
      ];
    }
    if (compareArrays(currentDimensions, newDimensions) !== "same") {
      this._options.editor.editing.view.change((writer) => {
        writer.setStyle({
          width: newDimensions[0],
          height: newDimensions[1],
          left: newDimensions[2],
          top: newDimensions[3]
        }, resizerWrapper);
      });
    }
  }
  containsHandle(domElement) {
    return this._domResizerWrapper.contains(domElement);
  }
  static isResizeHandle(domElement) {
    return domElement.classList.contains("ck-widget__resizer__handle");
  }
  /**
   * Cleans up the context state.
   */
  _cleanup() {
    this._sizeView._dismiss();
    const editingView = this._options.editor.editing.view;
    editingView.change((writer) => {
      writer.setStyle("width", this._initialViewWidth, this._options.viewElement);
    });
  }
  /**
   * Calculates the proposed size as the resize handles are dragged.
   *
   * @param domEventData Event data that caused the size update request. It should be used to calculate the proposed size.
   */
  _proposeNewSize(domEventData) {
    const state = this.state;
    const currentCoordinates = extractCoordinates(domEventData);
    const isCentered = this._options.isCentered ? this._options.isCentered(this) : true;
    const enlargement = {
      x: state._referenceCoordinates.x - (currentCoordinates.x + state.originalWidth),
      y: currentCoordinates.y - state.originalHeight - state._referenceCoordinates.y
    };
    if (isCentered && state.activeHandlePosition.endsWith("-right")) {
      enlargement.x = currentCoordinates.x - (state._referenceCoordinates.x + state.originalWidth);
    }
    if (isCentered) {
      enlargement.x *= 2;
    }
    let width = Math.abs(state.originalWidth + enlargement.x);
    let height = Math.abs(state.originalHeight + enlargement.y);
    const dominant = width / state.aspectRatio > height ? "width" : "height";
    if (dominant == "width") {
      height = width / state.aspectRatio;
    } else {
      width = height * state.aspectRatio;
    }
    return {
      width: Math.round(width),
      height: Math.round(height),
      widthPercents: Math.min(Math.round(state.originalWidthPercents / state.originalWidth * width * 100) / 100, 100)
    };
  }
  /**
   * Obtains the resize host.
   *
   * Resize host is an object that receives dimensions which are the result of resizing.
   */
  _getResizeHost() {
    const widgetWrapper = this._domResizerWrapper.parentElement;
    return this._options.getResizeHost(widgetWrapper);
  }
  /**
   * Obtains the handle host.
   *
   * Handle host is an object that the handles are aligned to.
   *
   * Handle host will not always be an entire widget itself. Take an image as an example. The image widget
   * contains an image and a caption. Only the image should be surrounded with handles.
   */
  _getHandleHost() {
    const widgetWrapper = this._domResizerWrapper.parentElement;
    return this._options.getHandleHost(widgetWrapper);
  }
  /**
   * DOM container of the entire resize UI.
   *
   * Note that this property will have a value only after the element bound with the resizer is rendered
   * (otherwise `null`).
   */
  get _domResizerWrapper() {
    return this._options.editor.editing.view.domConverter.mapViewToDom(this._viewResizerWrapper);
  }
  /**
   * Renders the resize handles in the DOM.
   *
   * @param domElement The resizer wrapper.
   */
  _appendHandles(domElement) {
    const resizerPositions = ["top-left", "top-right", "bottom-right", "bottom-left"];
    for (const currentPosition of resizerPositions) {
      domElement.appendChild(new Template({
        tag: "div",
        attributes: {
          class: `ck-widget__resizer__handle ${getResizerClass(currentPosition)}`
        }
      }).render());
    }
  }
  /**
   * Sets up the {@link #_sizeView} property and adds it to the passed `domElement`.
   */
  _appendSizeUI(domElement) {
    this._sizeView = new SizeView();
    this._sizeView.render();
    domElement.appendChild(this._sizeView.element);
  }
};
function getResizerClass(resizerPosition) {
  return `ck-widget__resizer__handle-${resizerPosition}`;
}
function extractCoordinates(event) {
  return {
    x: event.pageX,
    y: event.pageY
  };
}
function existsInDom(element) {
  return element && element.ownerDocument && element.ownerDocument.contains(element);
}

// node_modules/@ckeditor/ckeditor5-widget/src/widgetresize.js
import "/var/www/html/manorama/node_modules/@ckeditor/ckeditor5-widget/theme/widgetresize.css";
/*! Bundled license information:

@ckeditor/ckeditor5-widget/src/widgettoolbarrepository.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/widgetresize/resizerstate.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/widgetresize/sizeview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/widgetresize/resizer.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/widgetresize.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=chunk-BYFIKNKK.js.map
