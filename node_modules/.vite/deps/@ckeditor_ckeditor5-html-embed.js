import "./chunk-SA55FI2N.js";
import "./chunk-BYFIKNKK.js";
import {
  Widget,
  findOptimalInsertionRange,
  toWidget
} from "./chunk-XTWUOPXT.js";
import "./chunk-U5S3T6FN.js";
import {
  ButtonView
} from "./chunk-2UXKTWKP.js";
import "./chunk-GJCFV3G2.js";
import {
  createElement,
  logWarning
} from "./chunk-MFEZX3FO.js";
import {
  Command,
  Plugin,
  icons
} from "./chunk-YB4X7RFQ.js";
import "./chunk-VMNDBVXW.js";
import "./chunk-LQD6FQVM.js";
import "./chunk-ROME4SDB.js";

// node_modules/@ckeditor/ckeditor5-html-embed/src/htmlembedcommand.js
var HtmlEmbedCommand = class extends Command {
  /**
   * @inheritDoc
   */
  refresh() {
    const model = this.editor.model;
    const schema = model.schema;
    const selection = model.document.selection;
    const selectedRawHtmlElement = getSelectedRawHtmlModelWidget(selection);
    this.isEnabled = isHtmlEmbedAllowedInParent(selection, schema, model);
    this.value = selectedRawHtmlElement ? selectedRawHtmlElement.getAttribute("value") || "" : null;
  }
  /**
   * Executes the command, which either:
   *
   * * creates and inserts a new HTML embed element if none was selected,
   * * updates the content of the HTML embed if one was selected.
   *
   * @fires execute
   * @param value When passed, the value (content) will be set on a new embed or a selected one.
   */
  execute(value) {
    const model = this.editor.model;
    const selection = model.document.selection;
    model.change((writer) => {
      let htmlEmbedElement;
      if (this.value !== null) {
        htmlEmbedElement = getSelectedRawHtmlModelWidget(selection);
      } else {
        htmlEmbedElement = writer.createElement("rawHtml");
        model.insertObject(htmlEmbedElement, null, null, { setSelection: "on" });
      }
      writer.setAttribute("value", value, htmlEmbedElement);
    });
  }
};
function isHtmlEmbedAllowedInParent(selection, schema, model) {
  const parent = getInsertHtmlEmbedParent(selection, model);
  return schema.checkChild(parent, "rawHtml");
}
function getInsertHtmlEmbedParent(selection, model) {
  const insertionRange = findOptimalInsertionRange(selection, model);
  const parent = insertionRange.start.parent;
  if (parent.isEmpty && !parent.is("rootElement")) {
    return parent.parent;
  }
  return parent;
}
function getSelectedRawHtmlModelWidget(selection) {
  const selectedElement = selection.getSelectedElement();
  if (selectedElement && selectedElement.is("element", "rawHtml")) {
    return selectedElement;
  }
  return null;
}

// node_modules/@ckeditor/ckeditor5-html-embed/src/htmlembedediting.js
import "/var/www/html/manorama/node_modules/@ckeditor/ckeditor5-html-embed/theme/htmlembed.css";
var HtmlEmbedEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "HtmlEmbedEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    this._widgetButtonViewReferences = /* @__PURE__ */ new Set();
    editor.config.define("htmlEmbed", {
      showPreviews: false,
      sanitizeHtml: (rawHtml) => {
        logWarning("html-embed-provide-sanitize-function");
        return {
          html: rawHtml,
          hasChanged: false
        };
      }
    });
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const schema = editor.model.schema;
    schema.register("rawHtml", {
      inheritAllFrom: "$blockObject",
      allowAttributes: ["value"]
    });
    editor.commands.add("htmlEmbed", new HtmlEmbedCommand(editor));
    this._setupConversion();
  }
  /**
   * Prepares converters for the feature.
   */
  _setupConversion() {
    const editor = this.editor;
    const t = editor.t;
    const view = editor.editing.view;
    const widgetButtonViewReferences = this._widgetButtonViewReferences;
    const htmlEmbedConfig = editor.config.get("htmlEmbed");
    this.editor.editing.view.on("render", () => {
      for (const buttonView of widgetButtonViewReferences) {
        if (buttonView.element && buttonView.element.isConnected) {
          return;
        }
        buttonView.destroy();
        widgetButtonViewReferences.delete(buttonView);
      }
    }, { priority: "lowest" });
    editor.data.registerRawContentMatcher({
      name: "div",
      classes: "raw-html-embed"
    });
    editor.conversion.for("upcast").elementToElement({
      view: {
        name: "div",
        classes: "raw-html-embed"
      },
      model: (viewElement, { writer }) => {
        return writer.createElement("rawHtml", {
          value: viewElement.getCustomProperty("$rawContent")
        });
      }
    });
    editor.conversion.for("dataDowncast").elementToElement({
      model: "rawHtml",
      view: (modelElement, { writer }) => {
        return writer.createRawElement("div", { class: "raw-html-embed" }, function(domElement) {
          domElement.innerHTML = modelElement.getAttribute("value") || "";
        });
      }
    });
    editor.conversion.for("editingDowncast").elementToStructure({
      model: { name: "rawHtml", attributes: ["value"] },
      view: (modelElement, { writer }) => {
        let domContentWrapper;
        let state;
        let props;
        const viewContentWrapper = writer.createRawElement("div", {
          class: "raw-html-embed__content-wrapper"
        }, function(domElement) {
          domContentWrapper = domElement;
          renderContent({ editor, domElement, state, props });
          domContentWrapper.addEventListener("mousedown", () => {
            if (state.isEditable) {
              const model = editor.model;
              const selectedElement = model.document.selection.getSelectedElement();
              if (selectedElement !== modelElement) {
                model.change((writer2) => writer2.setSelection(modelElement, "on"));
              }
            }
          }, true);
        });
        const rawHtmlApi = {
          makeEditable() {
            state = Object.assign({}, state, {
              isEditable: true
            });
            renderContent({ domElement: domContentWrapper, editor, state, props });
            view.change((writer2) => {
              writer2.setAttribute("data-cke-ignore-events", "true", viewContentWrapper);
            });
            domContentWrapper.querySelector("textarea").focus();
          },
          save(newValue) {
            if (newValue !== state.getRawHtmlValue()) {
              editor.execute("htmlEmbed", newValue);
              editor.editing.view.focus();
            } else {
              this.cancel();
            }
          },
          cancel() {
            state = Object.assign({}, state, {
              isEditable: false
            });
            renderContent({ domElement: domContentWrapper, editor, state, props });
            editor.editing.view.focus();
            view.change((writer2) => {
              writer2.removeAttribute("data-cke-ignore-events", viewContentWrapper);
            });
          }
        };
        state = {
          showPreviews: htmlEmbedConfig.showPreviews,
          isEditable: false,
          getRawHtmlValue: () => modelElement.getAttribute("value") || ""
        };
        props = {
          sanitizeHtml: htmlEmbedConfig.sanitizeHtml,
          textareaPlaceholder: t("Paste raw HTML here..."),
          onEditClick() {
            rawHtmlApi.makeEditable();
          },
          onSaveClick(newValue) {
            rawHtmlApi.save(newValue);
          },
          onCancelClick() {
            rawHtmlApi.cancel();
          }
        };
        const viewContainer = writer.createContainerElement("div", {
          class: "raw-html-embed",
          "data-html-embed-label": t("HTML snippet"),
          dir: editor.locale.uiLanguageDirection
        }, viewContentWrapper);
        writer.setCustomProperty("rawHtmlApi", rawHtmlApi, viewContainer);
        writer.setCustomProperty("rawHtml", true, viewContainer);
        return toWidget(viewContainer, writer, {
          label: t("HTML snippet"),
          hasSelectionHandle: true
        });
      }
    });
    function renderContent({ editor: editor2, domElement, state, props }) {
      domElement.textContent = "";
      const domDocument = domElement.ownerDocument;
      let domTextarea;
      if (state.isEditable) {
        const textareaProps = {
          isDisabled: false,
          placeholder: props.textareaPlaceholder
        };
        domTextarea = createDomTextarea({ domDocument, state, props: textareaProps });
        domElement.append(domTextarea);
      } else if (state.showPreviews) {
        const previewContainerProps = {
          sanitizeHtml: props.sanitizeHtml
        };
        domElement.append(createPreviewContainer({ domDocument, state, props: previewContainerProps, editor: editor2 }));
      } else {
        const textareaProps = {
          isDisabled: true,
          placeholder: props.textareaPlaceholder
        };
        domElement.append(createDomTextarea({ domDocument, state, props: textareaProps }));
      }
      const buttonsWrapperProps = {
        onEditClick: props.onEditClick,
        onSaveClick: () => {
          props.onSaveClick(domTextarea.value);
        },
        onCancelClick: props.onCancelClick
      };
      domElement.prepend(createDomButtonsWrapper({ editor: editor2, domDocument, state, props: buttonsWrapperProps }));
    }
    function createDomButtonsWrapper({ editor: editor2, domDocument, state, props }) {
      const domButtonsWrapper = createElement(domDocument, "div", {
        class: "raw-html-embed__buttons-wrapper"
      });
      if (state.isEditable) {
        const saveButtonView = createUIButton(editor2, "save", props.onSaveClick);
        const cancelButtonView = createUIButton(editor2, "cancel", props.onCancelClick);
        domButtonsWrapper.append(saveButtonView.element, cancelButtonView.element);
        widgetButtonViewReferences.add(saveButtonView).add(cancelButtonView);
      } else {
        const editButtonView = createUIButton(editor2, "edit", props.onEditClick);
        domButtonsWrapper.append(editButtonView.element);
        widgetButtonViewReferences.add(editButtonView);
      }
      return domButtonsWrapper;
    }
    function createDomTextarea({ domDocument, state, props }) {
      const domTextarea = createElement(domDocument, "textarea", {
        placeholder: props.placeholder,
        class: "ck ck-reset ck-input ck-input-text raw-html-embed__source"
      });
      domTextarea.disabled = props.isDisabled;
      domTextarea.value = state.getRawHtmlValue();
      return domTextarea;
    }
    function createPreviewContainer({ editor: editor2, domDocument, state, props }) {
      const sanitizedOutput = props.sanitizeHtml(state.getRawHtmlValue());
      const placeholderText = state.getRawHtmlValue().length > 0 ? t("No preview available") : t("Empty snippet content");
      const domPreviewPlaceholder = createElement(domDocument, "div", {
        class: "ck ck-reset_all raw-html-embed__preview-placeholder"
      }, placeholderText);
      const domPreviewContent = createElement(domDocument, "div", {
        class: "raw-html-embed__preview-content",
        dir: editor2.locale.contentLanguageDirection
      });
      const domRange = domDocument.createRange();
      const domDocumentFragment = domRange.createContextualFragment(sanitizedOutput.html);
      domPreviewContent.appendChild(domDocumentFragment);
      const domPreviewContainer = createElement(domDocument, "div", {
        class: "raw-html-embed__preview"
      }, [
        domPreviewPlaceholder,
        domPreviewContent
      ]);
      return domPreviewContainer;
    }
  }
};
function createUIButton(editor, type, onClick) {
  const { t } = editor.locale;
  const buttonView = new ButtonView(editor.locale);
  const command = editor.commands.get("htmlEmbed");
  buttonView.set({
    class: `raw-html-embed__${type}-button`,
    icon: icons.pencil,
    tooltip: true,
    tooltipPosition: editor.locale.uiLanguageDirection === "rtl" ? "e" : "w"
  });
  buttonView.render();
  if (type === "edit") {
    buttonView.set({
      icon: icons.pencil,
      label: t("Edit source")
    });
    buttonView.bind("isEnabled").to(command);
  } else if (type === "save") {
    buttonView.set({
      icon: icons.check,
      label: t("Save changes")
    });
    buttonView.bind("isEnabled").to(command);
  } else {
    buttonView.set({
      icon: icons.cancel,
      label: t("Cancel")
    });
  }
  buttonView.on("execute", onClick);
  return buttonView;
}

// node_modules/@ckeditor/ckeditor5-html-embed/src/htmlembedui.js
var HtmlEmbedUI = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "HtmlEmbedUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const t = editor.t;
    editor.ui.componentFactory.add("htmlEmbed", (locale) => {
      const command = editor.commands.get("htmlEmbed");
      const view = new ButtonView(locale);
      view.set({
        label: t("Insert HTML"),
        icon: icons.html,
        tooltip: true
      });
      view.bind("isEnabled").to(command, "isEnabled");
      this.listenTo(view, "execute", () => {
        editor.execute("htmlEmbed");
        editor.editing.view.focus();
        const rawHtmlApi = editor.editing.view.document.selection.getSelectedElement().getCustomProperty("rawHtmlApi");
        rawHtmlApi.makeEditable();
      });
      return view;
    });
  }
};

// node_modules/@ckeditor/ckeditor5-html-embed/src/htmlembed.js
var HtmlEmbed = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [HtmlEmbedEditing, HtmlEmbedUI, Widget];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "HtmlEmbed";
  }
};
export {
  HtmlEmbed,
  HtmlEmbedEditing,
  HtmlEmbedUI
};
/*! Bundled license information:

@ckeditor/ckeditor5-html-embed/src/htmlembedcommand.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-html-embed/src/htmlembedediting.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-html-embed/src/htmlembedui.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-html-embed/src/htmlembed.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-html-embed/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-html-embed/src/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=@ckeditor_ckeditor5-html-embed.js.map
