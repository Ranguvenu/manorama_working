import {
  Widget,
  toWidget,
  viewToModelPositionOutsideModelElement
} from "./chunk-XTWUOPXT.js";
import {
  Command,
  Plugin
} from "./chunk-YB4X7RFQ.js";
import "./chunk-VMNDBVXW.js";
import {
  assignIn_default,
  cloneDeepWith_default,
  clone_default,
  get_default,
  isObject_default,
  isPlainObject_default,
  unset_default
} from "./chunk-LQD6FQVM.js";
import "./chunk-ROME4SDB.js";

// node_modules/@ckeditor/ckeditor5-utils/src/env.js
function getUserAgent() {
  try {
    return navigator.userAgent.toLowerCase();
  } catch (e) {
    return "";
  }
}
var userAgent = getUserAgent();
var env = {
  isMac: isMac(userAgent),
  isWindows: isWindows(userAgent),
  isGecko: isGecko(userAgent),
  isSafari: isSafari(userAgent),
  isiOS: isiOS(userAgent),
  isAndroid: isAndroid(userAgent),
  isBlink: isBlink(userAgent),
  features: {
    isRegExpUnicodePropertySupported: isRegExpUnicodePropertySupported()
  }
};
var env_default = env;
function isMac(userAgent2) {
  return userAgent2.indexOf("macintosh") > -1;
}
function isWindows(userAgent2) {
  return userAgent2.indexOf("windows") > -1;
}
function isGecko(userAgent2) {
  return !!userAgent2.match(/gecko\/\d+/);
}
function isSafari(userAgent2) {
  return userAgent2.indexOf(" applewebkit/") > -1 && userAgent2.indexOf("chrome") === -1;
}
function isiOS(userAgent2) {
  return !!userAgent2.match(/iphone|ipad/i) || isMac(userAgent2) && navigator.maxTouchPoints > 0;
}
function isAndroid(userAgent2) {
  return userAgent2.indexOf("android") > -1;
}
function isBlink(userAgent2) {
  return userAgent2.indexOf("chrome/") > -1 && userAgent2.indexOf("edge/") < 0;
}
function isRegExpUnicodePropertySupported() {
  let isSupported = false;
  try {
    isSupported = "ć".search(new RegExp("[\\p{L}]", "u")) === 0;
  } catch (error) {
  }
  return isSupported;
}

// node_modules/@ckeditor/ckeditor5-utils/src/fastdiff.js
function fastDiff(a, b, cmp, atomicChanges) {
  cmp = cmp || function(a2, b2) {
    return a2 === b2;
  };
  const arrayA = Array.isArray(a) ? a : Array.prototype.slice.call(a);
  const arrayB = Array.isArray(b) ? b : Array.prototype.slice.call(b);
  const changeIndexes = findChangeBoundaryIndexes(arrayA, arrayB, cmp);
  const result = atomicChanges ? changeIndexesToAtomicChanges(changeIndexes, arrayB.length) : changeIndexesToChanges(arrayB, changeIndexes);
  return result;
}
function findChangeBoundaryIndexes(arr1, arr2, cmp) {
  const firstIndex = findFirstDifferenceIndex(arr1, arr2, cmp);
  if (firstIndex === -1) {
    return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 };
  }
  const oldArrayReversed = cutAndReverse(arr1, firstIndex);
  const newArrayReversed = cutAndReverse(arr2, firstIndex);
  const lastIndex = findFirstDifferenceIndex(oldArrayReversed, newArrayReversed, cmp);
  const lastIndexOld = arr1.length - lastIndex;
  const lastIndexNew = arr2.length - lastIndex;
  return { firstIndex, lastIndexOld, lastIndexNew };
}
function findFirstDifferenceIndex(arr1, arr2, cmp) {
  for (let i = 0; i < Math.max(arr1.length, arr2.length); i++) {
    if (arr1[i] === void 0 || arr2[i] === void 0 || !cmp(arr1[i], arr2[i])) {
      return i;
    }
  }
  return -1;
}
function cutAndReverse(arr, howMany) {
  return arr.slice(howMany).reverse();
}
function changeIndexesToChanges(newArray, changeIndexes) {
  const result = [];
  const { firstIndex, lastIndexOld, lastIndexNew } = changeIndexes;
  if (lastIndexNew - firstIndex > 0) {
    result.push({
      index: firstIndex,
      type: "insert",
      values: newArray.slice(firstIndex, lastIndexNew)
    });
  }
  if (lastIndexOld - firstIndex > 0) {
    result.push({
      index: firstIndex + (lastIndexNew - firstIndex),
      type: "delete",
      howMany: lastIndexOld - firstIndex
    });
  }
  return result;
}
function changeIndexesToAtomicChanges(changeIndexes, newLength) {
  const { firstIndex, lastIndexOld, lastIndexNew } = changeIndexes;
  if (firstIndex === -1) {
    return Array(newLength).fill("equal");
  }
  let result = [];
  if (firstIndex > 0) {
    result = result.concat(Array(firstIndex).fill("equal"));
  }
  if (lastIndexNew - firstIndex > 0) {
    result = result.concat(Array(lastIndexNew - firstIndex).fill("insert"));
  }
  if (lastIndexOld - firstIndex > 0) {
    result = result.concat(Array(lastIndexOld - firstIndex).fill("delete"));
  }
  if (lastIndexNew < newLength) {
    result = result.concat(Array(newLength - lastIndexNew).fill("equal"));
  }
  return result;
}

// node_modules/@ckeditor/ckeditor5-utils/src/diff.js
function diff(a, b, cmp) {
  cmp = cmp || function(a2, b2) {
    return a2 === b2;
  };
  const aLength = a.length;
  const bLength = b.length;
  if (aLength > 200 || bLength > 200 || aLength + bLength > 300) {
    return diff.fastDiff(a, b, cmp, true);
  }
  let _insert, _delete;
  if (bLength < aLength) {
    const tmp = a;
    a = b;
    b = tmp;
    _insert = "delete";
    _delete = "insert";
  } else {
    _insert = "insert";
    _delete = "delete";
  }
  const m = a.length;
  const n = b.length;
  const delta = n - m;
  const es = {};
  const fp = {};
  function snake(k2) {
    const y1 = (fp[k2 - 1] !== void 0 ? fp[k2 - 1] : -1) + 1;
    const y2 = fp[k2 + 1] !== void 0 ? fp[k2 + 1] : -1;
    const dir = y1 > y2 ? -1 : 1;
    if (es[k2 + dir]) {
      es[k2] = es[k2 + dir].slice(0);
    }
    if (!es[k2]) {
      es[k2] = [];
    }
    es[k2].push(y1 > y2 ? _insert : _delete);
    let y = Math.max(y1, y2);
    let x = y - k2;
    while (x < m && y < n && cmp(a[x], b[y])) {
      x++;
      y++;
      es[k2].push("equal");
    }
    return y;
  }
  let p = 0;
  let k;
  do {
    for (k = -p; k < delta; k++) {
      fp[k] = snake(k);
    }
    for (k = delta + p; k > delta; k--) {
      fp[k] = snake(k);
    }
    fp[delta] = snake(delta);
    p++;
  } while (fp[delta] !== n);
  return es[delta].slice(1);
}
diff.fastDiff = fastDiff;

// node_modules/@ckeditor/ckeditor5-utils/src/spy.js
function spy() {
  return function spy2() {
    spy2.called = true;
  };
}
var spy_default = spy;

// node_modules/@ckeditor/ckeditor5-utils/src/eventinfo.js
var EventInfo = class {
  /**
   * @param source The emitter.
   * @param name The event name.
   */
  constructor(source, name) {
    this.source = source;
    this.name = name;
    this.path = [];
    this.stop = spy_default();
    this.off = spy_default();
  }
};

// node_modules/@ckeditor/ckeditor5-utils/src/uid.js
var HEX_NUMBERS = new Array(256).fill("").map((_, index) => ("0" + index.toString(16)).slice(-2));
function uid() {
  const r1 = Math.random() * 4294967296 >>> 0;
  const r2 = Math.random() * 4294967296 >>> 0;
  const r3 = Math.random() * 4294967296 >>> 0;
  const r4 = Math.random() * 4294967296 >>> 0;
  return "e" + HEX_NUMBERS[r1 >> 0 & 255] + HEX_NUMBERS[r1 >> 8 & 255] + HEX_NUMBERS[r1 >> 16 & 255] + HEX_NUMBERS[r1 >> 24 & 255] + HEX_NUMBERS[r2 >> 0 & 255] + HEX_NUMBERS[r2 >> 8 & 255] + HEX_NUMBERS[r2 >> 16 & 255] + HEX_NUMBERS[r2 >> 24 & 255] + HEX_NUMBERS[r3 >> 0 & 255] + HEX_NUMBERS[r3 >> 8 & 255] + HEX_NUMBERS[r3 >> 16 & 255] + HEX_NUMBERS[r3 >> 24 & 255] + HEX_NUMBERS[r4 >> 0 & 255] + HEX_NUMBERS[r4 >> 8 & 255] + HEX_NUMBERS[r4 >> 16 & 255] + HEX_NUMBERS[r4 >> 24 & 255];
}

// node_modules/@ckeditor/ckeditor5-utils/src/priorities.js
var priorities = {
  get(priority = "normal") {
    if (typeof priority != "number") {
      return this[priority] || this.normal;
    } else {
      return priority;
    }
  },
  highest: 1e5,
  high: 1e3,
  normal: 0,
  low: -1e3,
  lowest: -1e5
};
var priorities_default = priorities;

// node_modules/@ckeditor/ckeditor5-utils/src/inserttopriorityarray.js
function insertToPriorityArray(objects, objectToInsert) {
  const priority = priorities_default.get(objectToInsert.priority);
  for (let i = 0; i < objects.length; i++) {
    if (priorities_default.get(objects[i].priority) < priority) {
      objects.splice(i, 0, objectToInsert);
      return;
    }
  }
  objects.push(objectToInsert);
}

// node_modules/@ckeditor/ckeditor5-utils/src/ckeditorerror.js
var DOCUMENTATION_URL = "https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html";
var CKEditorError = class _CKEditorError extends Error {
  /**
   * Creates an instance of the CKEditorError class.
   *
   * @param errorName The error id in an `error-name` format. A link to this error documentation page will be added
   * to the thrown error's `message`.
   * @param context A context of the error by which the {@link module:watchdog/watchdog~Watchdog watchdog}
   * is able to determine which editor crashed. It should be an editor instance or a property connected to it. It can be also
   * a `null` value if the editor should not be restarted in case of the error (e.g. during the editor initialization).
   * The error context should be checked using the `areConnectedThroughProperties( editor, context )` utility
   * to check if the object works as the context.
   * @param data Additional data describing the error. A stringified version of this object
   * will be appended to the error message, so the data are quickly visible in the console. The original
   * data object will also be later available under the {@link #data} property.
   */
  constructor(errorName, context, data) {
    super(getErrorMessage(errorName, data));
    this.name = "CKEditorError";
    this.context = context;
    this.data = data;
  }
  /**
   * Checks if the error is of the `CKEditorError` type.
   */
  is(type) {
    return type === "CKEditorError";
  }
  /**
   * A utility that ensures that the thrown error is a {@link module:utils/ckeditorerror~CKEditorError} one.
   * It is useful when combined with the {@link module:watchdog/watchdog~Watchdog} feature, which can restart the editor in case
   * of a {@link module:utils/ckeditorerror~CKEditorError} error.
   *
   * @param err The error to rethrow.
   * @param context An object connected through properties with the editor instance. This context will be used
   * by the watchdog to verify which editor should be restarted.
   */
  static rethrowUnexpectedError(err, context) {
    if (err.is && err.is("CKEditorError")) {
      throw err;
    }
    const error = new _CKEditorError(err.message, context);
    error.stack = err.stack;
    throw error;
  }
};
function logWarning(errorName, data) {
  console.warn(...formatConsoleArguments(errorName, data));
}
function getLinkToDocumentationMessage(errorName) {
  return `
Read more: ${DOCUMENTATION_URL}#error-${errorName}`;
}
function getErrorMessage(errorName, data) {
  const processedObjects = /* @__PURE__ */ new WeakSet();
  const circularReferencesReplacer = (key, value) => {
    if (typeof value === "object" && value !== null) {
      if (processedObjects.has(value)) {
        return `[object ${value.constructor.name}]`;
      }
      processedObjects.add(value);
    }
    return value;
  };
  const stringifiedData = data ? ` ${JSON.stringify(data, circularReferencesReplacer)}` : "";
  const documentationLink = getLinkToDocumentationMessage(errorName);
  return errorName + stringifiedData + documentationLink;
}
function formatConsoleArguments(errorName, data) {
  const documentationMessage = getLinkToDocumentationMessage(errorName);
  return data ? [errorName, data, documentationMessage] : [errorName, documentationMessage];
}

// node_modules/@ckeditor/ckeditor5-utils/src/version.js
var version = "41.1.0";
var releaseDate = new Date(2024, 1, 7);
if (globalThis.CKEDITOR_VERSION) {
  throw new CKEditorError("ckeditor-duplicated-modules", null);
} else {
  globalThis.CKEDITOR_VERSION = version;
}

// node_modules/@ckeditor/ckeditor5-utils/src/emittermixin.js
var _listeningTo = Symbol("listeningTo");
var _emitterId = Symbol("emitterId");
var _delegations = Symbol("delegations");
var defaultEmitterClass = EmitterMixin(Object);
function EmitterMixin(base) {
  if (!base) {
    return defaultEmitterClass;
  }
  class Mixin extends base {
    on(event, callback, options) {
      this.listenTo(this, event, callback, options);
    }
    once(event, callback, options) {
      let wasFired = false;
      const onceCallback = (event2, ...args) => {
        if (!wasFired) {
          wasFired = true;
          event2.off();
          callback.call(this, event2, ...args);
        }
      };
      this.listenTo(this, event, onceCallback, options);
    }
    off(event, callback) {
      this.stopListening(this, event, callback);
    }
    listenTo(emitter, event, callback, options = {}) {
      let emitterInfo, eventCallbacks;
      if (!this[_listeningTo]) {
        this[_listeningTo] = {};
      }
      const emitters = this[_listeningTo];
      if (!_getEmitterId(emitter)) {
        _setEmitterId(emitter);
      }
      const emitterId = _getEmitterId(emitter);
      if (!(emitterInfo = emitters[emitterId])) {
        emitterInfo = emitters[emitterId] = {
          emitter,
          callbacks: {}
        };
      }
      if (!(eventCallbacks = emitterInfo.callbacks[event])) {
        eventCallbacks = emitterInfo.callbacks[event] = [];
      }
      eventCallbacks.push(callback);
      addEventListener(this, emitter, event, callback, options);
    }
    stopListening(emitter, event, callback) {
      const emitters = this[_listeningTo];
      let emitterId = emitter && _getEmitterId(emitter);
      const emitterInfo = emitters && emitterId ? emitters[emitterId] : void 0;
      const eventCallbacks = emitterInfo && event ? emitterInfo.callbacks[event] : void 0;
      if (!emitters || emitter && !emitterInfo || event && !eventCallbacks) {
        return;
      }
      if (callback) {
        removeEventListener(this, emitter, event, callback);
        const index = eventCallbacks.indexOf(callback);
        if (index !== -1) {
          if (eventCallbacks.length === 1) {
            delete emitterInfo.callbacks[event];
          } else {
            removeEventListener(this, emitter, event, callback);
          }
        }
      } else if (eventCallbacks) {
        while (callback = eventCallbacks.pop()) {
          removeEventListener(this, emitter, event, callback);
        }
        delete emitterInfo.callbacks[event];
      } else if (emitterInfo) {
        for (event in emitterInfo.callbacks) {
          this.stopListening(emitter, event);
        }
        delete emitters[emitterId];
      } else {
        for (emitterId in emitters) {
          this.stopListening(emitters[emitterId].emitter);
        }
        delete this[_listeningTo];
      }
    }
    fire(eventOrInfo, ...args) {
      try {
        const eventInfo = eventOrInfo instanceof EventInfo ? eventOrInfo : new EventInfo(this, eventOrInfo);
        const event = eventInfo.name;
        let callbacks = getCallbacksForEvent(this, event);
        eventInfo.path.push(this);
        if (callbacks) {
          const callbackArgs = [eventInfo, ...args];
          callbacks = Array.from(callbacks);
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i].callback.apply(this, callbackArgs);
            if (eventInfo.off.called) {
              delete eventInfo.off.called;
              this._removeEventListener(event, callbacks[i].callback);
            }
            if (eventInfo.stop.called) {
              break;
            }
          }
        }
        const delegations = this[_delegations];
        if (delegations) {
          const destinations = delegations.get(event);
          const passAllDestinations = delegations.get("*");
          if (destinations) {
            fireDelegatedEvents(destinations, eventInfo, args);
          }
          if (passAllDestinations) {
            fireDelegatedEvents(passAllDestinations, eventInfo, args);
          }
        }
        return eventInfo.return;
      } catch (err) {
        CKEditorError.rethrowUnexpectedError(err, this);
      }
    }
    delegate(...events) {
      return {
        to: (emitter, nameOrFunction) => {
          if (!this[_delegations]) {
            this[_delegations] = /* @__PURE__ */ new Map();
          }
          events.forEach((eventName) => {
            const destinations = this[_delegations].get(eventName);
            if (!destinations) {
              this[_delegations].set(eventName, /* @__PURE__ */ new Map([[emitter, nameOrFunction]]));
            } else {
              destinations.set(emitter, nameOrFunction);
            }
          });
        }
      };
    }
    stopDelegating(event, emitter) {
      if (!this[_delegations]) {
        return;
      }
      if (!event) {
        this[_delegations].clear();
      } else if (!emitter) {
        this[_delegations].delete(event);
      } else {
        const destinations = this[_delegations].get(event);
        if (destinations) {
          destinations.delete(emitter);
        }
      }
    }
    _addEventListener(event, callback, options) {
      createEventNamespace(this, event);
      const lists = getCallbacksListsForNamespace(this, event);
      const priority = priorities_default.get(options.priority);
      const callbackDefinition = {
        callback,
        priority
      };
      for (const callbacks of lists) {
        insertToPriorityArray(callbacks, callbackDefinition);
      }
    }
    _removeEventListener(event, callback) {
      const lists = getCallbacksListsForNamespace(this, event);
      for (const callbacks of lists) {
        for (let i = 0; i < callbacks.length; i++) {
          if (callbacks[i].callback == callback) {
            callbacks.splice(i, 1);
            i--;
          }
        }
      }
    }
  }
  return Mixin;
}
[
  "on",
  "once",
  "off",
  "listenTo",
  "stopListening",
  "fire",
  "delegate",
  "stopDelegating",
  "_addEventListener",
  "_removeEventListener"
].forEach((key) => {
  EmitterMixin[key] = defaultEmitterClass.prototype[key];
});
function _getEmitterListenedTo(listeningEmitter, listenedToEmitterId) {
  const listeningTo = listeningEmitter[_listeningTo];
  if (listeningTo && listeningTo[listenedToEmitterId]) {
    return listeningTo[listenedToEmitterId].emitter;
  }
  return null;
}
function _setEmitterId(emitter, id) {
  if (!emitter[_emitterId]) {
    emitter[_emitterId] = id || uid();
  }
}
function _getEmitterId(emitter) {
  return emitter[_emitterId];
}
function getEvents(source) {
  if (!source._events) {
    Object.defineProperty(source, "_events", {
      value: {}
    });
  }
  return source._events;
}
function makeEventNode() {
  return {
    callbacks: [],
    childEvents: []
  };
}
function createEventNamespace(source, eventName) {
  const events = getEvents(source);
  if (events[eventName]) {
    return;
  }
  let name = eventName;
  let childEventName = null;
  const newEventNodes = [];
  while (name !== "") {
    if (events[name]) {
      break;
    }
    events[name] = makeEventNode();
    newEventNodes.push(events[name]);
    if (childEventName) {
      events[name].childEvents.push(childEventName);
    }
    childEventName = name;
    name = name.substr(0, name.lastIndexOf(":"));
  }
  if (name !== "") {
    for (const node of newEventNodes) {
      node.callbacks = events[name].callbacks.slice();
    }
    events[name].childEvents.push(childEventName);
  }
}
function getCallbacksListsForNamespace(source, eventName) {
  const eventNode = getEvents(source)[eventName];
  if (!eventNode) {
    return [];
  }
  let callbacksLists = [eventNode.callbacks];
  for (let i = 0; i < eventNode.childEvents.length; i++) {
    const childCallbacksLists = getCallbacksListsForNamespace(source, eventNode.childEvents[i]);
    callbacksLists = callbacksLists.concat(childCallbacksLists);
  }
  return callbacksLists;
}
function getCallbacksForEvent(source, eventName) {
  let event;
  if (!source._events || !(event = source._events[eventName]) || !event.callbacks.length) {
    if (eventName.indexOf(":") > -1) {
      return getCallbacksForEvent(source, eventName.substr(0, eventName.lastIndexOf(":")));
    } else {
      return null;
    }
  }
  return event.callbacks;
}
function fireDelegatedEvents(destinations, eventInfo, fireArgs) {
  for (let [emitter, name] of destinations) {
    if (!name) {
      name = eventInfo.name;
    } else if (typeof name == "function") {
      name = name(eventInfo.name);
    }
    const delegatedInfo = new EventInfo(eventInfo.source, name);
    delegatedInfo.path = [...eventInfo.path];
    emitter.fire(delegatedInfo, ...fireArgs);
  }
}
function addEventListener(listener, emitter, event, callback, options) {
  if (emitter._addEventListener) {
    emitter._addEventListener(event, callback, options);
  } else {
    listener._addEventListener.call(emitter, event, callback, options);
  }
}
function removeEventListener(listener, emitter, event, callback) {
  if (emitter._removeEventListener) {
    emitter._removeEventListener(event, callback);
  } else {
    listener._removeEventListener.call(emitter, event, callback);
  }
}

// node_modules/@ckeditor/ckeditor5-utils/src/observablemixin.js
var observablePropertiesSymbol = Symbol("observableProperties");
var boundObservablesSymbol = Symbol("boundObservables");
var boundPropertiesSymbol = Symbol("boundProperties");
var decoratedMethods = Symbol("decoratedMethods");
var decoratedOriginal = Symbol("decoratedOriginal");
var defaultObservableClass = ObservableMixin(EmitterMixin());
function ObservableMixin(base) {
  if (!base) {
    return defaultObservableClass;
  }
  class Mixin extends base {
    set(name, value) {
      if (isObject_default(name)) {
        Object.keys(name).forEach((property) => {
          this.set(property, name[property]);
        }, this);
        return;
      }
      initObservable(this);
      const properties = this[observablePropertiesSymbol];
      if (name in this && !properties.has(name)) {
        throw new CKEditorError("observable-set-cannot-override", this);
      }
      Object.defineProperty(this, name, {
        enumerable: true,
        configurable: true,
        get() {
          return properties.get(name);
        },
        set(value2) {
          const oldValue = properties.get(name);
          let newValue = this.fire(`set:${name}`, name, value2, oldValue);
          if (newValue === void 0) {
            newValue = value2;
          }
          if (oldValue !== newValue || !properties.has(name)) {
            properties.set(name, newValue);
            this.fire(`change:${name}`, name, newValue, oldValue);
          }
        }
      });
      this[name] = value;
    }
    bind(...bindProperties) {
      if (!bindProperties.length || !isStringArray(bindProperties)) {
        throw new CKEditorError("observable-bind-wrong-properties", this);
      }
      if (new Set(bindProperties).size !== bindProperties.length) {
        throw new CKEditorError("observable-bind-duplicate-properties", this);
      }
      initObservable(this);
      const boundProperties = this[boundPropertiesSymbol];
      bindProperties.forEach((propertyName) => {
        if (boundProperties.has(propertyName)) {
          throw new CKEditorError("observable-bind-rebind", this);
        }
      });
      const bindings = /* @__PURE__ */ new Map();
      bindProperties.forEach((a) => {
        const binding = { property: a, to: [] };
        boundProperties.set(a, binding);
        bindings.set(a, binding);
      });
      return {
        to: bindTo,
        toMany: bindToMany,
        _observable: this,
        _bindProperties: bindProperties,
        _to: [],
        _bindings: bindings
      };
    }
    unbind(...unbindProperties) {
      if (!this[observablePropertiesSymbol]) {
        return;
      }
      const boundProperties = this[boundPropertiesSymbol];
      const boundObservables = this[boundObservablesSymbol];
      if (unbindProperties.length) {
        if (!isStringArray(unbindProperties)) {
          throw new CKEditorError("observable-unbind-wrong-properties", this);
        }
        unbindProperties.forEach((propertyName) => {
          const binding = boundProperties.get(propertyName);
          if (!binding) {
            return;
          }
          binding.to.forEach(([toObservable, toProperty]) => {
            const toProperties = boundObservables.get(toObservable);
            const toPropertyBindings = toProperties[toProperty];
            toPropertyBindings.delete(binding);
            if (!toPropertyBindings.size) {
              delete toProperties[toProperty];
            }
            if (!Object.keys(toProperties).length) {
              boundObservables.delete(toObservable);
              this.stopListening(toObservable, "change");
            }
          });
          boundProperties.delete(propertyName);
        });
      } else {
        boundObservables.forEach((bindings, boundObservable) => {
          this.stopListening(boundObservable, "change");
        });
        boundObservables.clear();
        boundProperties.clear();
      }
    }
    decorate(methodName) {
      initObservable(this);
      const originalMethod = this[methodName];
      if (!originalMethod) {
        throw new CKEditorError("observablemixin-cannot-decorate-undefined", this, { object: this, methodName });
      }
      this.on(methodName, (evt, args) => {
        evt.return = originalMethod.apply(this, args);
      });
      this[methodName] = function(...args) {
        return this.fire(methodName, args);
      };
      this[methodName][decoratedOriginal] = originalMethod;
      if (!this[decoratedMethods]) {
        this[decoratedMethods] = [];
      }
      this[decoratedMethods].push(methodName);
    }
    // Override the EmitterMixin stopListening method to be able to clean (and restore) decorated methods.
    // This is needed in case of:
    //  1. Have x.foo() decorated.
    //  2. Call x.stopListening()
    //  3. Call x.foo(). Problem: nothing happens (the original foo() method is not executed)
    stopListening(emitter, event, callback) {
      if (!emitter && this[decoratedMethods]) {
        for (const methodName of this[decoratedMethods]) {
          this[methodName] = this[methodName][decoratedOriginal];
        }
        delete this[decoratedMethods];
      }
      super.stopListening(emitter, event, callback);
    }
  }
  return Mixin;
}
[
  "set",
  "bind",
  "unbind",
  "decorate",
  "on",
  "once",
  "off",
  "listenTo",
  "stopListening",
  "fire",
  "delegate",
  "stopDelegating",
  "_addEventListener",
  "_removeEventListener"
].forEach((key) => {
  ObservableMixin[key] = defaultObservableClass.prototype[key];
});
function initObservable(observable) {
  if (observable[observablePropertiesSymbol]) {
    return;
  }
  Object.defineProperty(observable, observablePropertiesSymbol, {
    value: /* @__PURE__ */ new Map()
  });
  Object.defineProperty(observable, boundObservablesSymbol, {
    value: /* @__PURE__ */ new Map()
  });
  Object.defineProperty(observable, boundPropertiesSymbol, {
    value: /* @__PURE__ */ new Map()
  });
}
function bindTo(...args) {
  const parsedArgs = parseBindToArgs(...args);
  const bindingsKeys = Array.from(this._bindings.keys());
  const numberOfBindings = bindingsKeys.length;
  if (!parsedArgs.callback && parsedArgs.to.length > 1) {
    throw new CKEditorError("observable-bind-to-no-callback", this);
  }
  if (numberOfBindings > 1 && parsedArgs.callback) {
    throw new CKEditorError("observable-bind-to-extra-callback", this);
  }
  parsedArgs.to.forEach((to) => {
    if (to.properties.length && to.properties.length !== numberOfBindings) {
      throw new CKEditorError("observable-bind-to-properties-length", this);
    }
    if (!to.properties.length) {
      to.properties = this._bindProperties;
    }
  });
  this._to = parsedArgs.to;
  if (parsedArgs.callback) {
    this._bindings.get(bindingsKeys[0]).callback = parsedArgs.callback;
  }
  attachBindToListeners(this._observable, this._to);
  updateBindToBound(this);
  this._bindProperties.forEach((propertyName) => {
    updateBoundObservableProperty(this._observable, propertyName);
  });
}
function bindToMany(observables, attribute, callback) {
  if (this._bindings.size > 1) {
    throw new CKEditorError("observable-bind-to-many-not-one-binding", this);
  }
  this.to(
    ...getBindingTargets(observables, attribute),
    // ...using given callback to parse attribute values.
    callback
  );
}
function getBindingTargets(observables, attribute) {
  const observableAndAttributePairs = observables.map((observable) => [observable, attribute]);
  return Array.prototype.concat.apply([], observableAndAttributePairs);
}
function isStringArray(arr) {
  return arr.every((a) => typeof a == "string");
}
function parseBindToArgs(...args) {
  if (!args.length) {
    throw new CKEditorError("observable-bind-to-parse-error", null);
  }
  const parsed = { to: [] };
  let lastObservable;
  if (typeof args[args.length - 1] == "function") {
    parsed.callback = args.pop();
  }
  args.forEach((a) => {
    if (typeof a == "string") {
      lastObservable.properties.push(a);
    } else if (typeof a == "object") {
      lastObservable = { observable: a, properties: [] };
      parsed.to.push(lastObservable);
    } else {
      throw new CKEditorError("observable-bind-to-parse-error", null);
    }
  });
  return parsed;
}
function updateBoundObservables(observable, binding, toObservable, toPropertyName) {
  const boundObservables = observable[boundObservablesSymbol];
  const bindingsToObservable = boundObservables.get(toObservable);
  const bindings = bindingsToObservable || {};
  if (!bindings[toPropertyName]) {
    bindings[toPropertyName] = /* @__PURE__ */ new Set();
  }
  bindings[toPropertyName].add(binding);
  if (!bindingsToObservable) {
    boundObservables.set(toObservable, bindings);
  }
}
function updateBindToBound(chain) {
  let toProperty;
  chain._bindings.forEach((binding, propertyName) => {
    chain._to.forEach((to) => {
      toProperty = to.properties[binding.callback ? 0 : chain._bindProperties.indexOf(propertyName)];
      binding.to.push([to.observable, toProperty]);
      updateBoundObservables(chain._observable, binding, to.observable, toProperty);
    });
  });
}
function updateBoundObservableProperty(observable, propertyName) {
  const boundProperties = observable[boundPropertiesSymbol];
  const binding = boundProperties.get(propertyName);
  let propertyValue;
  if (binding.callback) {
    propertyValue = binding.callback.apply(observable, binding.to.map((to) => to[0][to[1]]));
  } else {
    propertyValue = binding.to[0];
    propertyValue = propertyValue[0][propertyValue[1]];
  }
  if (Object.prototype.hasOwnProperty.call(observable, propertyName)) {
    observable[propertyName] = propertyValue;
  } else {
    observable.set(propertyName, propertyValue);
  }
}
function attachBindToListeners(observable, toBindings) {
  toBindings.forEach((to) => {
    const boundObservables = observable[boundObservablesSymbol];
    let bindings;
    if (!boundObservables.get(to.observable)) {
      observable.listenTo(to.observable, "change", (evt, propertyName) => {
        bindings = boundObservables.get(to.observable)[propertyName];
        if (bindings) {
          bindings.forEach((binding) => {
            updateBoundObservableProperty(observable, binding.property);
          });
        }
      });
    }
  });
}

// node_modules/@ckeditor/ckeditor5-utils/src/count.js
function count(iterable) {
  let count2 = 0;
  for (const _ of iterable) {
    count2++;
  }
  return count2;
}

// node_modules/@ckeditor/ckeditor5-utils/src/comparearrays.js
function compareArrays(a, b) {
  const minLen = Math.min(a.length, b.length);
  for (let i = 0; i < minLen; i++) {
    if (a[i] != b[i]) {
      return i;
    }
  }
  if (a.length == b.length) {
    return "same";
  } else if (a.length < b.length) {
    return "prefix";
  } else {
    return "extension";
  }
}

// node_modules/@ckeditor/ckeditor5-utils/src/isiterable.js
function isIterable(value) {
  return !!(value && value[Symbol.iterator]);
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/isnode.js
function isNode(obj) {
  if (obj) {
    if (obj.defaultView) {
      return obj instanceof obj.defaultView.Document;
    } else if (obj.ownerDocument && obj.ownerDocument.defaultView) {
      return obj instanceof obj.ownerDocument.defaultView.Node;
    }
  }
  return false;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/iswindow.js
function isWindow(obj) {
  const stringifiedObject = Object.prototype.toString.apply(obj);
  if (stringifiedObject == "[object Window]") {
    return true;
  }
  if (stringifiedObject == "[object global]") {
    return true;
  }
  return false;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/emittermixin.js
var defaultEmitterClass2 = DomEmitterMixin(EmitterMixin());
function DomEmitterMixin(base) {
  if (!base) {
    return defaultEmitterClass2;
  }
  class Mixin extends base {
    listenTo(emitter, event, callback, options = {}) {
      if (isNode(emitter) || isWindow(emitter)) {
        const proxyOptions = {
          capture: !!options.useCapture,
          passive: !!options.usePassive
        };
        const proxyEmitter = this._getProxyEmitter(emitter, proxyOptions) || new ProxyEmitter(emitter, proxyOptions);
        this.listenTo(proxyEmitter, event, callback, options);
      } else {
        super.listenTo(emitter, event, callback, options);
      }
    }
    stopListening(emitter, event, callback) {
      if (isNode(emitter) || isWindow(emitter)) {
        const proxyEmitters = this._getAllProxyEmitters(emitter);
        for (const proxy of proxyEmitters) {
          this.stopListening(proxy, event, callback);
        }
      } else {
        super.stopListening(emitter, event, callback);
      }
    }
    /**
     * Retrieves ProxyEmitter instance for given DOM Node residing in this Host and given options.
     *
     * @param node DOM Node of the ProxyEmitter.
     * @param options Additional options.
     * @param options.useCapture Indicates that events of this type will be dispatched to the registered
     * listener before being dispatched to any EventTarget beneath it in the DOM tree.
     * @param options.usePassive Indicates that the function specified by listener will never call preventDefault()
     * and prevents blocking browser's main thread by this event handler.
     * @returns ProxyEmitter instance bound to the DOM Node.
     */
    _getProxyEmitter(node, options) {
      return _getEmitterListenedTo(this, getProxyEmitterId(node, options));
    }
    /**
     * Retrieves all the ProxyEmitter instances for given DOM Node residing in this Host.
     *
     * @param node DOM Node of the ProxyEmitter.
     */
    _getAllProxyEmitters(node) {
      return [
        { capture: false, passive: false },
        { capture: false, passive: true },
        { capture: true, passive: false },
        { capture: true, passive: true }
      ].map((options) => this._getProxyEmitter(node, options)).filter((proxy) => !!proxy);
    }
  }
  return Mixin;
}
[
  "_getProxyEmitter",
  "_getAllProxyEmitters",
  "on",
  "once",
  "off",
  "listenTo",
  "stopListening",
  "fire",
  "delegate",
  "stopDelegating",
  "_addEventListener",
  "_removeEventListener"
].forEach((key) => {
  DomEmitterMixin[key] = defaultEmitterClass2.prototype[key];
});
var ProxyEmitter = class extends EmitterMixin() {
  /**
   * @param node DOM Node that fires events.
   * @param options Additional options.
   * @param options.useCapture Indicates that events of this type will be dispatched to the registered
   * listener before being dispatched to any EventTarget beneath it in the DOM tree.
   * @param options.usePassive Indicates that the function specified by listener will never call preventDefault()
   * and prevents blocking browser's main thread by this event handler.
   */
  constructor(node, options) {
    super();
    _setEmitterId(this, getProxyEmitterId(node, options));
    this._domNode = node;
    this._options = options;
  }
  /**
   * Registers a callback function to be executed when an event is fired.
   *
   * It attaches a native DOM listener to the DOM Node. When fired,
   * a corresponding Emitter event will also fire with DOM Event object as an argument.
   *
   * **Note**: This is automatically called by the
   * {@link module:utils/emittermixin~Emitter#listenTo `Emitter#listenTo()`}.
   *
   * @param event The name of the event.
   */
  attach(event) {
    if (this._domListeners && this._domListeners[event]) {
      return;
    }
    const domListener = this._createDomListener(event);
    this._domNode.addEventListener(event, domListener, this._options);
    if (!this._domListeners) {
      this._domListeners = {};
    }
    this._domListeners[event] = domListener;
  }
  /**
   * Stops executing the callback on the given event.
   *
   * **Note**: This is automatically called by the
   * {@link module:utils/emittermixin~Emitter#stopListening `Emitter#stopListening()`}.
   *
   * @param event The name of the event.
   */
  detach(event) {
    let events;
    if (this._domListeners[event] && (!(events = this._events[event]) || !events.callbacks.length)) {
      this._domListeners[event].removeListener();
    }
  }
  /**
   * Adds callback to emitter for given event.
   *
   * @internal
   * @param event The name of the event.
   * @param callback The function to be called on event.
   * @param options Additional options.
   */
  _addEventListener(event, callback, options) {
    this.attach(event);
    EmitterMixin().prototype._addEventListener.call(this, event, callback, options);
  }
  /**
   * Removes callback from emitter for given event.
   *
   * @internal
   * @param event The name of the event.
   * @param callback The function to stop being called.
   */
  _removeEventListener(event, callback) {
    EmitterMixin().prototype._removeEventListener.call(this, event, callback);
    this.detach(event);
  }
  /**
   * Creates a native DOM listener callback. When the native DOM event
   * is fired it will fire corresponding event on this ProxyEmitter.
   * Note: A native DOM Event is passed as an argument.
   *
   * @param event The name of the event.
   * @returns The DOM listener callback.
   */
  _createDomListener(event) {
    const domListener = (domEvt) => {
      this.fire(event, domEvt);
    };
    domListener.removeListener = () => {
      this._domNode.removeEventListener(event, domListener, this._options);
      delete this._domListeners[event];
    };
    return domListener;
  }
};
function getNodeUID(node) {
  return node["data-ck-expando"] || (node["data-ck-expando"] = uid());
}
function getProxyEmitterId(node, options) {
  let id = getNodeUID(node);
  for (const option of Object.keys(options).sort()) {
    if (options[option]) {
      id += "-" + option;
    }
  }
  return id;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/global.js
var globalVar;
try {
  globalVar = { window, document };
} catch (e) {
  globalVar = { window: {}, document: {} };
}
var global_default = globalVar;

// node_modules/@ckeditor/ckeditor5-utils/src/dom/getancestors.js
function getAncestors(node) {
  const nodes = [];
  let currentNode = node;
  while (currentNode && currentNode.nodeType != Node.DOCUMENT_NODE) {
    nodes.unshift(currentNode);
    currentNode = currentNode.parentNode;
  }
  return nodes;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/istext.js
function isText(obj) {
  return Object.prototype.toString.call(obj) == "[object Text]";
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/resizeobserver.js
var ResizeObserver = class _ResizeObserver {
  /**
   * Creates an instance of the `ResizeObserver` class.
   *
   * @param element A DOM element that is to be observed for resizing. Note that
   * the element must be visible (i.e. not detached from DOM) for the observer to work.
   * @param callback A function called when the observed element was resized. It passes
   * the [`ResizeObserverEntry`](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserverEntry)
   * object with information about the resize event.
   */
  constructor(element, callback) {
    if (!_ResizeObserver._observerInstance) {
      _ResizeObserver._createObserver();
    }
    this._element = element;
    this._callback = callback;
    _ResizeObserver._addElementCallback(element, callback);
    _ResizeObserver._observerInstance.observe(element);
  }
  /**
   * The element observed by this observer.
   */
  get element() {
    return this._element;
  }
  /**
   * Destroys the observer which disables the `callback` passed to the {@link #constructor}.
   */
  destroy() {
    _ResizeObserver._deleteElementCallback(this._element, this._callback);
  }
  /**
   * Registers a new resize callback for the DOM element.
   */
  static _addElementCallback(element, callback) {
    if (!_ResizeObserver._elementCallbacks) {
      _ResizeObserver._elementCallbacks = /* @__PURE__ */ new Map();
    }
    let callbacks = _ResizeObserver._elementCallbacks.get(element);
    if (!callbacks) {
      callbacks = /* @__PURE__ */ new Set();
      _ResizeObserver._elementCallbacks.set(element, callbacks);
    }
    callbacks.add(callback);
  }
  /**
   * Removes a resize callback from the DOM element. If no callbacks are left
   * for the element, it removes the element from the native observer.
   */
  static _deleteElementCallback(element, callback) {
    const callbacks = _ResizeObserver._getElementCallbacks(element);
    if (callbacks) {
      callbacks.delete(callback);
      if (!callbacks.size) {
        _ResizeObserver._elementCallbacks.delete(element);
        _ResizeObserver._observerInstance.unobserve(element);
      }
    }
    if (_ResizeObserver._elementCallbacks && !_ResizeObserver._elementCallbacks.size) {
      _ResizeObserver._observerInstance = null;
      _ResizeObserver._elementCallbacks = null;
    }
  }
  /**
   * Returns are registered resize callbacks for the DOM element.
   */
  static _getElementCallbacks(element) {
    if (!_ResizeObserver._elementCallbacks) {
      return null;
    }
    return _ResizeObserver._elementCallbacks.get(element);
  }
  /**
   * Creates the single native observer shared across all `ResizeObserver` instances.
   */
  static _createObserver() {
    _ResizeObserver._observerInstance = new global_default.window.ResizeObserver((entries) => {
      for (const entry of entries) {
        const callbacks = _ResizeObserver._getElementCallbacks(entry.target);
        if (callbacks) {
          for (const callback of callbacks) {
            callback(entry);
          }
        }
      }
    });
  }
};
ResizeObserver._observerInstance = null;
ResizeObserver._elementCallbacks = null;

// node_modules/@ckeditor/ckeditor5-utils/src/dom/indexof.js
function indexOf(node) {
  let index = 0;
  while (node.previousSibling) {
    node = node.previousSibling;
    index++;
  }
  return index;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/iscomment.js
function isComment(obj) {
  return obj && obj.nodeType === Node.COMMENT_NODE;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/isvalidattributename.js
function isValidAttributeName(name) {
  try {
    global_default.document.createAttribute(name);
  } catch (error) {
    return false;
  }
  return true;
}

// node_modules/@ckeditor/ckeditor5-utils/src/keyboard.js
var modifiersToGlyphsMac = {
  ctrl: "⌃",
  cmd: "⌘",
  alt: "⌥",
  shift: "⇧"
};
var modifiersToGlyphsNonMac = {
  ctrl: "Ctrl+",
  alt: "Alt+",
  shift: "Shift+"
};
var keyCodes = generateKnownKeyCodes();
var keyCodeNames = Object.fromEntries(Object.entries(keyCodes).map(([name, code2]) => [code2, name.charAt(0).toUpperCase() + name.slice(1)]));
function getCode(key) {
  let keyCode;
  if (typeof key == "string") {
    keyCode = keyCodes[key.toLowerCase()];
    if (!keyCode) {
      throw new CKEditorError("keyboard-unknown-key", null, { key });
    }
  } else {
    keyCode = key.keyCode + (key.altKey ? keyCodes.alt : 0) + (key.ctrlKey ? keyCodes.ctrl : 0) + (key.shiftKey ? keyCodes.shift : 0) + (key.metaKey ? keyCodes.cmd : 0);
  }
  return keyCode;
}
function parseKeystroke(keystroke) {
  if (typeof keystroke == "string") {
    keystroke = splitKeystrokeText(keystroke);
  }
  return keystroke.map((key) => typeof key == "string" ? getEnvKeyCode(key) : key).reduce((key, sum) => sum + key, 0);
}
function getEnvKeystrokeText(keystroke) {
  let keystrokeCode = parseKeystroke(keystroke);
  const modifiersToGlyphs = Object.entries(env_default.isMac || env_default.isiOS ? modifiersToGlyphsMac : modifiersToGlyphsNonMac);
  const modifiers = modifiersToGlyphs.reduce((modifiers2, [name, glyph]) => {
    if ((keystrokeCode & keyCodes[name]) != 0) {
      keystrokeCode &= ~keyCodes[name];
      modifiers2 += glyph;
    }
    return modifiers2;
  }, "");
  return modifiers + (keystrokeCode ? keyCodeNames[keystrokeCode] : "");
}
function getEnvKeyCode(key) {
  if (key.endsWith("!")) {
    return getCode(key.slice(0, -1));
  }
  const code2 = getCode(key);
  return (env_default.isMac || env_default.isiOS) && code2 == keyCodes.ctrl ? keyCodes.cmd : code2;
}
function generateKnownKeyCodes() {
  const keyCodes2 = {
    arrowleft: 37,
    arrowup: 38,
    arrowright: 39,
    arrowdown: 40,
    backspace: 8,
    delete: 46,
    enter: 13,
    space: 32,
    esc: 27,
    tab: 9,
    // The idea about these numbers is that they do not collide with any real key codes, so we can use them
    // like bit masks.
    ctrl: 1114112,
    shift: 2228224,
    alt: 4456448,
    cmd: 8912896
  };
  for (let code2 = 65; code2 <= 90; code2++) {
    const letter = String.fromCharCode(code2);
    keyCodes2[letter.toLowerCase()] = code2;
  }
  for (let code2 = 48; code2 <= 57; code2++) {
    keyCodes2[code2 - 48] = code2;
  }
  for (let code2 = 112; code2 <= 123; code2++) {
    keyCodes2["f" + (code2 - 111)] = code2;
  }
  for (const char of "`-=[];',./\\") {
    keyCodes2[char] = char.charCodeAt(0);
  }
  return keyCodes2;
}
function splitKeystrokeText(keystroke) {
  return keystroke.split("+").map((key) => key.trim());
}

// node_modules/@ckeditor/ckeditor5-utils/src/toarray.js
function toArray(data) {
  return Array.isArray(data) ? data : [data];
}

// node_modules/@ckeditor/ckeditor5-utils/src/translation-service.js
if (!global_default.window.CKEDITOR_TRANSLATIONS) {
  global_default.window.CKEDITOR_TRANSLATIONS = {};
}

// node_modules/@ckeditor/ckeditor5-utils/src/collection.js
var Collection = class extends EmitterMixin() {
  constructor(initialItemsOrOptions = {}, options = {}) {
    super();
    const hasInitialItems = isIterable(initialItemsOrOptions);
    if (!hasInitialItems) {
      options = initialItemsOrOptions;
    }
    this._items = [];
    this._itemMap = /* @__PURE__ */ new Map();
    this._idProperty = options.idProperty || "id";
    this._bindToExternalToInternalMap = /* @__PURE__ */ new WeakMap();
    this._bindToInternalToExternalMap = /* @__PURE__ */ new WeakMap();
    this._skippedIndexesFromExternal = [];
    if (hasInitialItems) {
      for (const item of initialItemsOrOptions) {
        this._items.push(item);
        this._itemMap.set(this._getItemIdBeforeAdding(item), item);
      }
    }
  }
  /**
   * The number of items available in the collection.
   */
  get length() {
    return this._items.length;
  }
  /**
   * Returns the first item from the collection or null when collection is empty.
   */
  get first() {
    return this._items[0] || null;
  }
  /**
   * Returns the last item from the collection or null when collection is empty.
   */
  get last() {
    return this._items[this.length - 1] || null;
  }
  /**
   * Adds an item into the collection.
   *
   * If the item does not have an id, then it will be automatically generated and set on the item.
   *
   * @param item
   * @param index The position of the item in the collection. The item
   * is pushed to the collection when `index` not specified.
   * @fires add
   * @fires change
   */
  add(item, index) {
    return this.addMany([item], index);
  }
  /**
   * Adds multiple items into the collection.
   *
   * Any item not containing an id will get an automatically generated one.
   *
   * @param items
   * @param index The position of the insertion. Items will be appended if no `index` is specified.
   * @fires add
   * @fires change
   */
  addMany(items, index) {
    if (index === void 0) {
      index = this._items.length;
    } else if (index > this._items.length || index < 0) {
      throw new CKEditorError("collection-add-item-invalid-index", this);
    }
    let offset = 0;
    for (const item of items) {
      const itemId = this._getItemIdBeforeAdding(item);
      const currentItemIndex = index + offset;
      this._items.splice(currentItemIndex, 0, item);
      this._itemMap.set(itemId, item);
      this.fire("add", item, currentItemIndex);
      offset++;
    }
    this.fire("change", {
      added: items,
      removed: [],
      index
    });
    return this;
  }
  /**
   * Gets an item by its ID or index.
   *
   * @param idOrIndex The item ID or index in the collection.
   * @returns The requested item or `null` if such item does not exist.
   */
  get(idOrIndex) {
    let item;
    if (typeof idOrIndex == "string") {
      item = this._itemMap.get(idOrIndex);
    } else if (typeof idOrIndex == "number") {
      item = this._items[idOrIndex];
    } else {
      throw new CKEditorError("collection-get-invalid-arg", this);
    }
    return item || null;
  }
  /**
   * Returns a Boolean indicating whether the collection contains an item.
   *
   * @param itemOrId The item or its ID in the collection.
   * @returns `true` if the collection contains the item, `false` otherwise.
   */
  has(itemOrId) {
    if (typeof itemOrId == "string") {
      return this._itemMap.has(itemOrId);
    } else {
      const idProperty = this._idProperty;
      const id = itemOrId[idProperty];
      return id && this._itemMap.has(id);
    }
  }
  /**
   * Gets an index of an item in the collection.
   * When an item is not defined in the collection, the index will equal -1.
   *
   * @param itemOrId The item or its ID in the collection.
   * @returns The index of a given item.
   */
  getIndex(itemOrId) {
    let item;
    if (typeof itemOrId == "string") {
      item = this._itemMap.get(itemOrId);
    } else {
      item = itemOrId;
    }
    return item ? this._items.indexOf(item) : -1;
  }
  /**
   * Removes an item from the collection.
   *
   * @param subject The item to remove, its ID or index in the collection.
   * @returns The removed item.
   * @fires remove
   * @fires change
   */
  remove(subject) {
    const [item, index] = this._remove(subject);
    this.fire("change", {
      added: [],
      removed: [item],
      index
    });
    return item;
  }
  /**
   * Executes the callback for each item in the collection and composes an array or values returned by this callback.
   *
   * @typeParam U The result type of the callback.
   * @param callback
   * @param ctx Context in which the `callback` will be called.
   * @returns The result of mapping.
   */
  map(callback, ctx) {
    return this._items.map(callback, ctx);
  }
  /**
   * Performs the specified action for each item in the collection.
   *
   * @param ctx Context in which the `callback` will be called.
   */
  forEach(callback, ctx) {
    this._items.forEach(callback, ctx);
  }
  /**
   * Finds the first item in the collection for which the `callback` returns a true value.
   *
   * @param callback
   * @param ctx Context in which the `callback` will be called.
   * @returns The item for which `callback` returned a true value.
   */
  find(callback, ctx) {
    return this._items.find(callback, ctx);
  }
  /**
   * Returns an array with items for which the `callback` returned a true value.
   *
   * @param callback
   * @param ctx Context in which the `callback` will be called.
   * @returns The array with matching items.
   */
  filter(callback, ctx) {
    return this._items.filter(callback, ctx);
  }
  /**
   * Removes all items from the collection and destroys the binding created using
   * {@link #bindTo}.
   *
   * @fires remove
   * @fires change
   */
  clear() {
    if (this._bindToCollection) {
      this.stopListening(this._bindToCollection);
      this._bindToCollection = null;
    }
    const removedItems = Array.from(this._items);
    while (this.length) {
      this._remove(0);
    }
    this.fire("change", {
      added: [],
      removed: removedItems,
      index: 0
    });
  }
  /**
   * Binds and synchronizes the collection with another one.
   *
   * The binding can be a simple factory:
   *
   * ```ts
   * class FactoryClass {
   * 	public label: string;
   *
   * 	constructor( data: { label: string } ) {
   * 		this.label = data.label;
   * 	}
   * }
   *
   * const source = new Collection<{ label: string }>( { idProperty: 'label' } );
   * const target = new Collection<FactoryClass>();
   *
   * target.bindTo( source ).as( FactoryClass );
   *
   * source.add( { label: 'foo' } );
   * source.add( { label: 'bar' } );
   *
   * console.log( target.length ); // 2
   * console.log( target.get( 1 ).label ); // 'bar'
   *
   * source.remove( 0 );
   * console.log( target.length ); // 1
   * console.log( target.get( 0 ).label ); // 'bar'
   * ```
   *
   * or the factory driven by a custom callback:
   *
   * ```ts
   * class FooClass {
   * 	public label: string;
   *
   * 	constructor( data: { label: string } ) {
   * 		this.label = data.label;
   * 	}
   * }
   *
   * class BarClass {
   * 	public label: string;
   *
   * 	constructor( data: { label: string } ) {
   * 		this.label = data.label;
   * 	}
   * }
   *
   * const source = new Collection<{ label: string }>( { idProperty: 'label' } );
   * const target = new Collection<FooClass | BarClass>();
   *
   * target.bindTo( source ).using( ( item ) => {
   * 	if ( item.label == 'foo' ) {
   * 		return new FooClass( item );
   * 	} else {
   * 		return new BarClass( item );
   * 	}
   * } );
   *
   * source.add( { label: 'foo' } );
   * source.add( { label: 'bar' } );
   *
   * console.log( target.length ); // 2
   * console.log( target.get( 0 ) instanceof FooClass ); // true
   * console.log( target.get( 1 ) instanceof BarClass ); // true
   * ```
   *
   * or the factory out of property name:
   *
   * ```ts
   * const source = new Collection<{ nested: { value: string } }>();
   * const target = new Collection<{ value: string }>();
   *
   * target.bindTo( source ).using( 'nested' );
   *
   * source.add( { nested: { value: 'foo' } } );
   * source.add( { nested: { value: 'bar' } } );
   *
   * console.log( target.length ); // 2
   * console.log( target.get( 0 ).value ); // 'foo'
   * console.log( target.get( 1 ).value ); // 'bar'
   * ```
   *
   * It's possible to skip specified items by returning null value:
   *
   * ```ts
   * const source = new Collection<{ hidden: boolean }>();
   * const target = new Collection<{ hidden: boolean }>();
   *
   * target.bindTo( source ).using( item => {
   * 	if ( item.hidden ) {
   * 		return null;
   * 	}
   *
   * 	return item;
   * } );
   *
   * source.add( { hidden: true } );
   * source.add( { hidden: false } );
   *
   * console.log( source.length ); // 2
   * console.log( target.length ); // 1
   * ```
   *
   * **Note**: {@link #clear} can be used to break the binding.
   *
   * @typeParam S The type of `externalCollection` element.
   * @param externalCollection A collection to be bound.
   * @returns The binding chain object.
   */
  bindTo(externalCollection) {
    if (this._bindToCollection) {
      throw new CKEditorError("collection-bind-to-rebind", this);
    }
    this._bindToCollection = externalCollection;
    return {
      as: (Class2) => {
        this._setUpBindToBinding((item) => new Class2(item));
      },
      using: (callbackOrProperty) => {
        if (typeof callbackOrProperty == "function") {
          this._setUpBindToBinding(callbackOrProperty);
        } else {
          this._setUpBindToBinding((item) => item[callbackOrProperty]);
        }
      }
    };
  }
  /**
   * Finalizes and activates a binding initiated by {@link #bindTo}.
   *
   * @param factory A function which produces collection items.
   */
  _setUpBindToBinding(factory) {
    const externalCollection = this._bindToCollection;
    const addItem = (evt, externalItem, index) => {
      const isExternalBoundToThis = externalCollection._bindToCollection == this;
      const externalItemBound = externalCollection._bindToInternalToExternalMap.get(externalItem);
      if (isExternalBoundToThis && externalItemBound) {
        this._bindToExternalToInternalMap.set(externalItem, externalItemBound);
        this._bindToInternalToExternalMap.set(externalItemBound, externalItem);
      } else {
        const item = factory(externalItem);
        if (!item) {
          this._skippedIndexesFromExternal.push(index);
          return;
        }
        let finalIndex = index;
        for (const skipped of this._skippedIndexesFromExternal) {
          if (index > skipped) {
            finalIndex--;
          }
        }
        for (const skipped of externalCollection._skippedIndexesFromExternal) {
          if (finalIndex >= skipped) {
            finalIndex++;
          }
        }
        this._bindToExternalToInternalMap.set(externalItem, item);
        this._bindToInternalToExternalMap.set(item, externalItem);
        this.add(item, finalIndex);
        for (let i = 0; i < externalCollection._skippedIndexesFromExternal.length; i++) {
          if (finalIndex <= externalCollection._skippedIndexesFromExternal[i]) {
            externalCollection._skippedIndexesFromExternal[i]++;
          }
        }
      }
    };
    for (const externalItem of externalCollection) {
      addItem(null, externalItem, externalCollection.getIndex(externalItem));
    }
    this.listenTo(externalCollection, "add", addItem);
    this.listenTo(externalCollection, "remove", (evt, externalItem, index) => {
      const item = this._bindToExternalToInternalMap.get(externalItem);
      if (item) {
        this.remove(item);
      }
      this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((result, skipped) => {
        if (index < skipped) {
          result.push(skipped - 1);
        }
        if (index > skipped) {
          result.push(skipped);
        }
        return result;
      }, []);
    });
  }
  /**
   * Returns an unique id property for a given `item`.
   *
   * The method will generate new id and assign it to the `item` if it doesn't have any.
   *
   * @param item Item to be added.
   */
  _getItemIdBeforeAdding(item) {
    const idProperty = this._idProperty;
    let itemId;
    if (idProperty in item) {
      itemId = item[idProperty];
      if (typeof itemId != "string") {
        throw new CKEditorError("collection-add-invalid-id", this);
      }
      if (this.get(itemId)) {
        throw new CKEditorError("collection-add-item-already-exists", this);
      }
    } else {
      item[idProperty] = itemId = uid();
    }
    return itemId;
  }
  /**
   * Core {@link #remove} method implementation shared in other functions.
   *
   * In contrast this method **does not** fire the {@link #event:change} event.
   *
   * @param subject The item to remove, its id or index in the collection.
   * @returns Returns an array with the removed item and its index.
   * @fires remove
   */
  _remove(subject) {
    let index, id, item;
    let itemDoesNotExist = false;
    const idProperty = this._idProperty;
    if (typeof subject == "string") {
      id = subject;
      item = this._itemMap.get(id);
      itemDoesNotExist = !item;
      if (item) {
        index = this._items.indexOf(item);
      }
    } else if (typeof subject == "number") {
      index = subject;
      item = this._items[index];
      itemDoesNotExist = !item;
      if (item) {
        id = item[idProperty];
      }
    } else {
      item = subject;
      id = item[idProperty];
      index = this._items.indexOf(item);
      itemDoesNotExist = index == -1 || !this._itemMap.get(id);
    }
    if (itemDoesNotExist) {
      throw new CKEditorError("collection-remove-404", this);
    }
    this._items.splice(index, 1);
    this._itemMap.delete(id);
    const externalItem = this._bindToInternalToExternalMap.get(item);
    this._bindToInternalToExternalMap.delete(item);
    this._bindToExternalToInternalMap.delete(externalItem);
    this.fire("remove", item, index);
    return [item, index];
  }
  /**
   * Iterable interface.
   */
  [Symbol.iterator]() {
    return this._items[Symbol.iterator]();
  }
};

// node_modules/@ckeditor/ckeditor5-utils/src/first.js
function first(iterator) {
  const iteratorItem = iterator.next();
  if (iteratorItem.done) {
    return null;
  }
  return iteratorItem.value;
}

// node_modules/@ckeditor/ckeditor5-utils/src/focustracker.js
var FocusTracker = class extends DomEmitterMixin(ObservableMixin()) {
  constructor() {
    super();
    this._elements = /* @__PURE__ */ new Set();
    this._nextEventLoopTimeout = null;
    this.set("isFocused", false);
    this.set("focusedElement", null);
  }
  /**
   * Starts tracking the specified element.
   */
  add(element) {
    if (this._elements.has(element)) {
      throw new CKEditorError("focustracker-add-element-already-exist", this);
    }
    this.listenTo(element, "focus", () => this._focus(element), { useCapture: true });
    this.listenTo(element, "blur", () => this._blur(), { useCapture: true });
    this._elements.add(element);
  }
  /**
   * Stops tracking the specified element and stops listening on this element.
   */
  remove(element) {
    if (element === this.focusedElement) {
      this._blur();
    }
    if (this._elements.has(element)) {
      this.stopListening(element);
      this._elements.delete(element);
    }
  }
  /**
   * Destroys the focus tracker by:
   * - Disabling all event listeners attached to tracked elements.
   * - Removing all tracked elements that were previously added.
   */
  destroy() {
    this.stopListening();
  }
  /**
   * Stores currently focused element and set {@link #isFocused} as `true`.
   */
  _focus(element) {
    clearTimeout(this._nextEventLoopTimeout);
    this.focusedElement = element;
    this.isFocused = true;
  }
  /**
   * Clears currently focused element and set {@link #isFocused} as `false`.
   * This method uses `setTimeout` to change order of fires `blur` and `focus` events.
   */
  _blur() {
    clearTimeout(this._nextEventLoopTimeout);
    this._nextEventLoopTimeout = setTimeout(() => {
      this.focusedElement = null;
      this.isFocused = false;
    }, 0);
  }
};

// node_modules/@ckeditor/ckeditor5-utils/src/objecttomap.js
function objectToMap(obj) {
  const map = /* @__PURE__ */ new Map();
  for (const key in obj) {
    map.set(key, obj[key]);
  }
  return map;
}

// node_modules/@ckeditor/ckeditor5-utils/src/tomap.js
function toMap(data) {
  if (isIterable(data)) {
    return new Map(data);
  } else {
    return objectToMap(data);
  }
}

// node_modules/@ckeditor/ckeditor5-utils/src/delay.js
function delay(func, wait2) {
  let timer;
  function delayed(...args) {
    delayed.cancel();
    timer = setTimeout(() => func(...args), wait2);
  }
  delayed.cancel = () => {
    clearTimeout(timer);
  };
  return delayed;
}

// node_modules/@ckeditor/ckeditor5-utils/src/unicode.js
var EMOJI_PATTERN = buildEmojiRegexp();
function buildEmojiRegexp() {
  const parts = [
    // Emoji Tag Sequence (ETS)
    /\p{Emoji}[\u{E0020}-\u{E007E}]+\u{E007F}/u,
    // Emoji Keycap Sequence
    /\p{Emoji}\u{FE0F}?\u{20E3}/u,
    // Emoji Presentation Sequence
    /\p{Emoji}\u{FE0F}/u,
    // Single-Character Emoji / Emoji Modifier Sequence
    /(?=\p{General_Category=Other_Symbol})\p{Emoji}\p{Emoji_Modifier}*/u
  ];
  const flagSequence = /\p{Regional_Indicator}{2}/u.source;
  const emoji = "(?:" + parts.map((part) => part.source).join("|") + ")";
  const sequence = `${flagSequence}|${emoji}(?:‍${emoji})*`;
  return new RegExp(sequence, "ug");
}

// node_modules/@ckeditor/ckeditor5-ui/src/viewcollection.js
var ViewCollection = class extends Collection {
  /**
   * Creates a new instance of the {@link module:ui/viewcollection~ViewCollection}.
   *
   * @param initialItems The initial items of the collection.
   */
  constructor(initialItems = []) {
    super(initialItems, {
      // An #id Number attribute should be legal and not break the `ViewCollection` instance.
      // https://github.com/ckeditor/ckeditor5-ui/issues/93
      idProperty: "viewUid"
    });
    this.on("add", (evt, view, index) => {
      this._renderViewIntoCollectionParent(view, index);
    });
    this.on("remove", (evt, view) => {
      if (view.element && this._parentElement) {
        view.element.remove();
      }
    });
    this._parentElement = null;
  }
  /**
   * Destroys the view collection along with child views.
   * See the view {@link module:ui/view~View#destroy} method.
   */
  destroy() {
    this.map((view) => view.destroy());
  }
  /**
   * Sets the parent HTML element of this collection. When parent is set, {@link #add adding} and
   * {@link #remove removing} views in the collection synchronizes their
   * {@link module:ui/view~View#element elements} in the parent element.
   *
   * @param element A new parent element.
   */
  setParent(elementOrDocFragment) {
    this._parentElement = elementOrDocFragment;
    for (const view of this) {
      this._renderViewIntoCollectionParent(view);
    }
  }
  /**
   * Delegates selected events coming from within views in the collection to any
   * {@link module:utils/emittermixin~Emitter}.
   *
   * For the following views and collection:
   *
   * ```ts
   * const viewA = new View();
   * const viewB = new View();
   * const viewC = new View();
   *
   * const views = parentView.createCollection();
   *
   * views.delegate( 'eventX' ).to( viewB );
   * views.delegate( 'eventX', 'eventY' ).to( viewC );
   *
   * views.add( viewA );
   * ```
   *
   * the `eventX` is delegated (fired by) `viewB` and `viewC` along with `customData`:
   *
   * ```ts
   * viewA.fire( 'eventX', customData );
   * ```
   *
   * and `eventY` is delegated (fired by) `viewC` along with `customData`:
   *
   * ```ts
   * viewA.fire( 'eventY', customData );
   * ```
   *
   * See {@link module:utils/emittermixin~Emitter#delegate}.
   *
   * @param events {@link module:ui/view~View} event names to be delegated to another
   * {@link module:utils/emittermixin~Emitter}.
   * @returns Object with `to` property, a function which accepts the destination
   * of {@link module:utils/emittermixin~Emitter#delegate delegated} events.
   */
  delegate(...events) {
    if (!events.length || !isStringArray2(events)) {
      throw new CKEditorError("ui-viewcollection-delegate-wrong-events", this);
    }
    return {
      to: (dest) => {
        for (const view of this) {
          for (const evtName of events) {
            view.delegate(evtName).to(dest);
          }
        }
        this.on("add", (evt, view) => {
          for (const evtName of events) {
            view.delegate(evtName).to(dest);
          }
        });
        this.on("remove", (evt, view) => {
          for (const evtName of events) {
            view.stopDelegating(evtName, dest);
          }
        });
      }
    };
  }
  /**
   * This method {@link module:ui/view~View#render renders} a new view added to the collection.
   *
   * If the {@link #_parentElement parent element} of the collection is set, this method also adds
   * the view's {@link module:ui/view~View#element} as a child of the parent in DOM at a specified index.
   *
   * **Note**: If index is not specified, the view's element is pushed as the last child
   * of the parent element.
   *
   * @param view A new view added to the collection.
   * @param index An index the view holds in the collection. When not specified,
   * the view is added at the end.
   */
  _renderViewIntoCollectionParent(view, index) {
    if (!view.isRendered) {
      view.render();
    }
    if (view.element && this._parentElement) {
      this._parentElement.insertBefore(view.element, this._parentElement.children[index]);
    }
  }
  /**
   * Removes a child view from the collection. If the {@link #setParent parent element} of the
   * collection has been set, the {@link module:ui/view~View#element element} of the view is also removed
   * in DOM, reflecting the order of the collection.
   *
   * See the {@link #add} method.
   *
   * @param subject The view to remove, its id or index in the collection.
   * @returns The removed view.
   */
  remove(subject) {
    return super.remove(subject);
  }
};
function isStringArray2(arr) {
  return arr.every((a) => typeof a == "string");
}

// node_modules/@ckeditor/ckeditor5-ui/src/template.js
var xhtmlNs = "http://www.w3.org/1999/xhtml";
var Template = class extends EmitterMixin() {
  /**
   * Creates an instance of the {@link ~Template} class.
   *
   * @param def The definition of the template.
   */
  constructor(def) {
    super();
    Object.assign(this, normalize(clone(def)));
    this._isRendered = false;
    this._revertData = null;
  }
  /**
   * Renders a DOM Node (an HTML element or text) out of the template.
   *
   * ```ts
   * const domNode = new Template( { ... } ).render();
   * ```
   *
   * See: {@link #apply}.
   */
  render() {
    const node = this._renderNode({
      intoFragment: true
    });
    this._isRendered = true;
    return node;
  }
  /**
   * Applies the template to an existing DOM Node, either HTML element or text.
   *
   * **Note:** No new DOM nodes will be created. Applying extends:
   *
   * {@link module:ui/template~TemplateDefinition attributes},
   * {@link module:ui/template~TemplateDefinition event listeners}, and
   * `textContent` of {@link module:ui/template~TemplateDefinition children} only.
   *
   * **Note:** Existing `class` and `style` attributes are extended when a template
   * is applied to an HTML element, while other attributes and `textContent` are overridden.
   *
   * **Note:** The process of applying a template can be easily reverted using the
   * {@link module:ui/template~Template#revert} method.
   *
   * ```ts
   * const element = document.createElement( 'div' );
   * const observable = new Model( { divClass: 'my-div' } );
   * const emitter = Object.create( EmitterMixin );
   * const bind = Template.bind( observable, emitter );
   *
   * new Template( {
   * 	attributes: {
   * 		id: 'first-div',
   * 		class: bind.to( 'divClass' )
   * 	},
   * 	on: {
   * 		click: bind( 'elementClicked' ) // Will be fired by the observable.
   * 	},
   * 	children: [
   * 		'Div text.'
   * 	]
   * } ).apply( element );
   *
   * console.log( element.outerHTML ); // -> '<div id="first-div" class="my-div"></div>'
   * ```
   *
   * @see module:ui/template~Template#render
   * @see module:ui/template~Template#revert
   * @param node Root node for the template to apply.
   */
  apply(node) {
    this._revertData = getEmptyRevertData();
    this._renderNode({
      node,
      intoFragment: false,
      isApplying: true,
      revertData: this._revertData
    });
    return node;
  }
  /**
   * Reverts a template {@link module:ui/template~Template#apply applied} to a DOM node.
   *
   * @param node The root node for the template to revert. In most of the cases, it is the
   * same node used by {@link module:ui/template~Template#apply}.
   */
  revert(node) {
    if (!this._revertData) {
      throw new CKEditorError("ui-template-revert-not-applied", [this, node]);
    }
    this._revertTemplateFromNode(node, this._revertData);
  }
  /**
   * Returns an iterator which traverses the template in search of {@link module:ui/view~View}
   * instances and returns them one by one.
   *
   * ```ts
   * const viewFoo = new View();
   * const viewBar = new View();
   * const viewBaz = new View();
   * const template = new Template( {
   * 	tag: 'div',
   * 	children: [
   * 		viewFoo,
   * 		{
   * 			tag: 'div',
   * 			children: [
   * 				viewBar
   * 			]
   * 		},
   * 		viewBaz
   * 	]
   * } );
   *
   * // Logs: viewFoo, viewBar, viewBaz
   * for ( const view of template.getViews() ) {
   * 	console.log( view );
   * }
   * ```
   */
  *getViews() {
    function* search(def) {
      if (def.children) {
        for (const child of def.children) {
          if (isView(child)) {
            yield child;
          } else if (isTemplate(child)) {
            yield* search(child);
          }
        }
      }
    }
    yield* search(this);
  }
  /**
   * An entry point to the interface which binds DOM nodes to
   * {@link module:utils/observablemixin~Observable observables}.
   * There are two types of bindings:
   *
   * * HTML element attributes or text `textContent` synchronized with attributes of an
   * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}
   * and {@link module:ui/template~BindChain#if}.
   *
   * ```ts
   * const bind = Template.bind( observable, emitter );
   *
   * new Template( {
   * 	attributes: {
   * 		// Binds the element "class" attribute to observable#classAttribute.
   * 		class: bind.to( 'classAttribute' )
   * 	}
   * } ).render();
   * ```
   *
   * * DOM events fired on HTML element propagated through
   * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}.
   *
   * ```ts
   * const bind = Template.bind( observable, emitter );
   *
   * new Template( {
   * 	on: {
   * 		// Will be fired by the observable.
   * 		click: bind( 'elementClicked' )
   * 	}
   * } ).render();
   * ```
   *
   * Also see {@link module:ui/view~View#bindTemplate}.
   *
   * @param observable An observable which provides boundable attributes.
   * @param emitter An emitter that listens to observable attribute
   * changes or DOM Events (depending on the kind of the binding). Usually, a {@link module:ui/view~View} instance.
   */
  static bind(observable, emitter) {
    return {
      to(eventNameOrFunctionOrAttribute, callback) {
        return new TemplateToBinding({
          eventNameOrFunction: eventNameOrFunctionOrAttribute,
          attribute: eventNameOrFunctionOrAttribute,
          observable,
          emitter,
          callback
        });
      },
      if(attribute, valueIfTrue, callback) {
        return new TemplateIfBinding({
          observable,
          emitter,
          attribute,
          valueIfTrue,
          callback
        });
      }
    };
  }
  /**
   * Extends an existing {@link module:ui/template~Template} instance with some additional content
   * from another {@link module:ui/template~TemplateDefinition}.
   *
   * ```ts
   * const bind = Template.bind( observable, emitter );
   *
   * const template = new Template( {
   * 	tag: 'p',
   * 	attributes: {
   * 		class: 'a',
   * 		data-x: bind.to( 'foo' )
   * 	},
   * 	children: [
   * 		{
   * 			tag: 'span',
   * 			attributes: {
   * 				class: 'b'
   * 			},
   * 			children: [
   * 				'Span'
   * 			]
   * 		}
   * 	]
   *  } );
   *
   * // Instance-level extension.
   * Template.extend( template, {
   * 	attributes: {
   * 		class: 'b',
   * 		data-x: bind.to( 'bar' )
   * 	},
   * 	children: [
   * 		{
   * 			attributes: {
   * 				class: 'c'
   * 			}
   * 		}
   * 	]
   * } );
   *
   * // Child extension.
   * Template.extend( template.children[ 0 ], {
   * 	attributes: {
   * 		class: 'd'
   * 	}
   * } );
   * ```
   *
   * the `outerHTML` of `template.render()` is:
   *
   * ```html
   * <p class="a b" data-x="{ observable.foo } { observable.bar }">
   * 	<span class="b c d">Span</span>
   * </p>
   * ```
   *
   * @param template An existing template instance to be extended.
   * @param def Additional definition to be applied to a template.
   */
  static extend(template, def) {
    if (template._isRendered) {
      throw new CKEditorError("template-extend-render", [this, template]);
    }
    extendTemplate(template, normalize(clone(def)));
  }
  /**
   * Renders a DOM Node (either an HTML element or text) out of the template.
   *
   * @param data Rendering data.
   */
  _renderNode(data) {
    let isInvalid;
    if (data.node) {
      isInvalid = this.tag && this.text;
    } else {
      isInvalid = this.tag ? this.text : !this.text;
    }
    if (isInvalid) {
      throw new CKEditorError("ui-template-wrong-syntax", this);
    }
    if (this.text) {
      return this._renderText(data);
    } else {
      return this._renderElement(data);
    }
  }
  /**
   * Renders an HTML element out of the template.
   *
   * @param data Rendering data.
   */
  _renderElement(data) {
    let node = data.node;
    if (!node) {
      node = data.node = document.createElementNS(this.ns || xhtmlNs, this.tag);
    }
    this._renderAttributes(data);
    this._renderElementChildren(data);
    this._setUpListeners(data);
    return node;
  }
  /**
   * Renders a text node out of {@link module:ui/template~Template#text}.
   *
   * @param data Rendering data.
   */
  _renderText(data) {
    let node = data.node;
    if (node) {
      data.revertData.text = node.textContent;
    } else {
      node = data.node = document.createTextNode("");
    }
    if (hasTemplateBinding(this.text)) {
      this._bindToObservable({
        schema: this.text,
        updater: getTextUpdater(node),
        data
      });
    } else {
      node.textContent = this.text.join("");
    }
    return node;
  }
  /**
   * Renders HTML element attributes out of {@link module:ui/template~Template#attributes}.
   *
   * @param data Rendering data.
   */
  _renderAttributes(data) {
    if (!this.attributes) {
      return;
    }
    const node = data.node;
    const revertData = data.revertData;
    for (const attrName in this.attributes) {
      const domAttrValue = node.getAttribute(attrName);
      const attrValue = this.attributes[attrName];
      if (revertData) {
        revertData.attributes[attrName] = domAttrValue;
      }
      const attrNs = isNamespaced(attrValue) ? attrValue[0].ns : null;
      if (hasTemplateBinding(attrValue)) {
        const valueToBind = isNamespaced(attrValue) ? attrValue[0].value : attrValue;
        if (revertData && shouldExtend(attrName)) {
          valueToBind.unshift(domAttrValue);
        }
        this._bindToObservable({
          schema: valueToBind,
          updater: getAttributeUpdater(node, attrName, attrNs),
          data
        });
      } else if (attrName == "style" && typeof attrValue[0] !== "string") {
        this._renderStyleAttribute(attrValue[0], data);
      } else {
        if (revertData && domAttrValue && shouldExtend(attrName)) {
          attrValue.unshift(domAttrValue);
        }
        const value = attrValue.map((val) => val ? val.value || val : val).reduce((prev, next) => prev.concat(next), []).reduce(arrayValueReducer, "");
        if (!isFalsy(value)) {
          node.setAttributeNS(attrNs, attrName, value);
        }
      }
    }
  }
  /**
   * Renders the `style` attribute of an HTML element based on
   * {@link module:ui/template~Template#attributes}.
   *
   * A style attribute is an object with static values:
   *
   * ```ts
   * attributes: {
   * 	style: {
   * 		color: 'red'
   * 	}
   * }
   * ```
   *
   * or values bound to {@link module:ui/model~Model} properties:
   *
   * ```ts
   * attributes: {
   * 	style: {
   * 		color: bind.to( ... )
   * 	}
   * }
   * ```
   *
   * Note: The `style` attribute is rendered without setting the namespace. It does not seem to be
   * needed.
   *
   * @param styles Styles located in `attributes.style` of {@link module:ui/template~TemplateDefinition}.
   * @param data Rendering data.
   */
  _renderStyleAttribute(styles, data) {
    const node = data.node;
    for (const styleName in styles) {
      const styleValue = styles[styleName];
      if (hasTemplateBinding(styleValue)) {
        this._bindToObservable({
          schema: [styleValue],
          updater: getStyleUpdater(node, styleName),
          data
        });
      } else {
        node.style[styleName] = styleValue;
      }
    }
  }
  /**
   * Recursively renders HTML element's children from {@link module:ui/template~Template#children}.
   *
   * @param data Rendering data.
   */
  _renderElementChildren(data) {
    const node = data.node;
    const container = data.intoFragment ? document.createDocumentFragment() : node;
    const isApplying = data.isApplying;
    let childIndex = 0;
    for (const child of this.children) {
      if (isViewCollection(child)) {
        if (!isApplying) {
          child.setParent(node);
          for (const view of child) {
            container.appendChild(view.element);
          }
        }
      } else if (isView(child)) {
        if (!isApplying) {
          if (!child.isRendered) {
            child.render();
          }
          container.appendChild(child.element);
        }
      } else if (isNode(child)) {
        container.appendChild(child);
      } else {
        if (isApplying) {
          const revertData = data.revertData;
          const childRevertData = getEmptyRevertData();
          revertData.children.push(childRevertData);
          child._renderNode({
            intoFragment: false,
            node: container.childNodes[childIndex++],
            isApplying: true,
            revertData: childRevertData
          });
        } else {
          container.appendChild(child.render());
        }
      }
    }
    if (data.intoFragment) {
      node.appendChild(container);
    }
  }
  /**
   * Activates `on` event listeners from the {@link module:ui/template~TemplateDefinition}
   * on an HTML element.
   *
   * @param data Rendering data.
   */
  _setUpListeners(data) {
    if (!this.eventListeners) {
      return;
    }
    for (const key in this.eventListeners) {
      const revertBindings = this.eventListeners[key].map((schemaItem) => {
        const [domEvtName, domSelector] = key.split("@");
        return schemaItem.activateDomEventListener(domEvtName, domSelector, data);
      });
      if (data.revertData) {
        data.revertData.bindings.push(revertBindings);
      }
    }
  }
  /**
   * For a given {@link module:ui/template~TemplateValueSchema} containing {@link module:ui/template~TemplateBinding}
   * activates the binding and sets its initial value.
   *
   * Note: {@link module:ui/template~TemplateValueSchema} can be for HTML element attributes or
   * text node `textContent`.
   *
   * @param options Binding options.
   * @param options.updater A function which updates the DOM (like attribute or text).
   * @param options.data Rendering data.
   */
  _bindToObservable({ schema, updater, data }) {
    const revertData = data.revertData;
    syncValueSchemaValue(schema, updater, data);
    const revertBindings = schema.filter((item) => !isFalsy(item)).filter((item) => item.observable).map((templateBinding) => templateBinding.activateAttributeListener(schema, updater, data));
    if (revertData) {
      revertData.bindings.push(revertBindings);
    }
  }
  /**
   * Reverts {@link module:ui/template~RenderData#revertData template data} from a node to
   * return it to the original state.
   *
   * @param node A node to be reverted.
   * @param revertData An object that stores information about what changes have been made by
   * {@link #apply} to the node. See {@link module:ui/template~RenderData#revertData} for more information.
   */
  _revertTemplateFromNode(node, revertData) {
    for (const binding of revertData.bindings) {
      for (const revertBinding of binding) {
        revertBinding();
      }
    }
    if (revertData.text) {
      node.textContent = revertData.text;
      return;
    }
    const element = node;
    for (const attrName in revertData.attributes) {
      const attrValue = revertData.attributes[attrName];
      if (attrValue === null) {
        element.removeAttribute(attrName);
      } else {
        element.setAttribute(attrName, attrValue);
      }
    }
    for (let i = 0; i < revertData.children.length; ++i) {
      this._revertTemplateFromNode(element.childNodes[i], revertData.children[i]);
    }
  }
};
var TemplateBinding = class {
  /**
   * Creates an instance of the {@link module:ui/template~TemplateBinding} class.
   *
   * @param def The definition of the binding.
   */
  constructor(def) {
    this.attribute = def.attribute;
    this.observable = def.observable;
    this.emitter = def.emitter;
    this.callback = def.callback;
  }
  /**
   * Returns the value of the binding. It is the value of the {@link module:ui/template~TemplateBinding#attribute} in
   * {@link module:ui/template~TemplateBinding#observable}. The value may be processed by the
   * {@link module:ui/template~TemplateBinding#callback}, if such has been passed to the binding.
   *
   * @param node A native DOM node, passed to the custom {@link module:ui/template~TemplateBinding#callback}.
   * @returns The value of {@link module:ui/template~TemplateBinding#attribute} in
   * {@link module:ui/template~TemplateBinding#observable}.
   */
  getValue(node) {
    const value = this.observable[this.attribute];
    return this.callback ? this.callback(value, node) : value;
  }
  /**
   * Activates the listener which waits for changes of the {@link module:ui/template~TemplateBinding#attribute} in
   * {@link module:ui/template~TemplateBinding#observable}, then updates the DOM with the aggregated
   * value of {@link module:ui/template~TemplateValueSchema}.
   *
   * @param schema A full schema to generate an attribute or text in the DOM.
   * @param updater A DOM updater function used to update the native DOM attribute or text.
   * @param data Rendering data.
   * @returns A function to sever the listener binding.
   */
  activateAttributeListener(schema, updater, data) {
    const callback = () => syncValueSchemaValue(schema, updater, data);
    this.emitter.listenTo(this.observable, `change:${this.attribute}`, callback);
    return () => {
      this.emitter.stopListening(this.observable, `change:${this.attribute}`, callback);
    };
  }
};
var TemplateToBinding = class extends TemplateBinding {
  constructor(def) {
    super(def);
    this.eventNameOrFunction = def.eventNameOrFunction;
  }
  /**
   * Activates the listener for the native DOM event, which when fired, is propagated by
   * the {@link module:ui/template~TemplateBinding#emitter}.
   *
   * @param domEvtName The name of the native DOM event.
   * @param domSelector The selector in the DOM to filter delegated events.
   * @param data Rendering data.
   * @returns A function to sever the listener binding.
   */
  activateDomEventListener(domEvtName, domSelector, data) {
    const callback = (evt, domEvt) => {
      if (!domSelector || domEvt.target.matches(domSelector)) {
        if (typeof this.eventNameOrFunction == "function") {
          this.eventNameOrFunction(domEvt);
        } else {
          this.observable.fire(this.eventNameOrFunction, domEvt);
        }
      }
    };
    this.emitter.listenTo(data.node, domEvtName, callback);
    return () => {
      this.emitter.stopListening(data.node, domEvtName, callback);
    };
  }
};
var TemplateIfBinding = class extends TemplateBinding {
  constructor(def) {
    super(def);
    this.valueIfTrue = def.valueIfTrue;
  }
  /**
   * @inheritDoc
   */
  getValue(node) {
    const value = super.getValue(node);
    return isFalsy(value) ? false : this.valueIfTrue || true;
  }
};
function hasTemplateBinding(schema) {
  if (!schema) {
    return false;
  }
  if (schema.value) {
    schema = schema.value;
  }
  if (Array.isArray(schema)) {
    return schema.some(hasTemplateBinding);
  } else if (schema instanceof TemplateBinding) {
    return true;
  }
  return false;
}
function getValueSchemaValue(schema, node) {
  return schema.map((schemaItem) => {
    if (schemaItem instanceof TemplateBinding) {
      return schemaItem.getValue(node);
    }
    return schemaItem;
  });
}
function syncValueSchemaValue(schema, updater, { node }) {
  const values = getValueSchemaValue(schema, node);
  let value;
  if (schema.length == 1 && schema[0] instanceof TemplateIfBinding) {
    value = values[0];
  } else {
    value = values.reduce(arrayValueReducer, "");
  }
  if (isFalsy(value)) {
    updater.remove();
  } else {
    updater.set(value);
  }
}
function getTextUpdater(node) {
  return {
    set(value) {
      node.textContent = value;
    },
    remove() {
      node.textContent = "";
    }
  };
}
function getAttributeUpdater(el, attrName, ns) {
  return {
    set(value) {
      el.setAttributeNS(ns, attrName, value);
    },
    remove() {
      el.removeAttributeNS(ns, attrName);
    }
  };
}
function getStyleUpdater(el, styleName) {
  return {
    set(value) {
      el.style[styleName] = value;
    },
    remove() {
      el.style[styleName] = null;
    }
  };
}
function clone(def) {
  const clone3 = cloneDeepWith_default(def, (value) => {
    if (value && (value instanceof TemplateBinding || isTemplate(value) || isView(value) || isViewCollection(value))) {
      return value;
    }
  });
  return clone3;
}
function normalize(def) {
  if (typeof def == "string") {
    def = normalizePlainTextDefinition(def);
  } else if (def.text) {
    normalizeTextDefinition(def);
  }
  if (def.on) {
    def.eventListeners = normalizeListeners(def.on);
    delete def.on;
  }
  if (!def.text) {
    if (def.attributes) {
      normalizeAttributes(def.attributes);
    }
    const children = [];
    if (def.children) {
      if (isViewCollection(def.children)) {
        children.push(def.children);
      } else {
        for (const child of def.children) {
          if (isTemplate(child) || isView(child) || isNode(child)) {
            children.push(child);
          } else {
            children.push(new Template(child));
          }
        }
      }
    }
    def.children = children;
  }
  return def;
}
function normalizeAttributes(attributes) {
  for (const a in attributes) {
    if (attributes[a].value) {
      attributes[a].value = toArray(attributes[a].value);
    }
    arrayify(attributes, a);
  }
}
function normalizeListeners(listeners) {
  for (const l in listeners) {
    arrayify(listeners, l);
  }
  return listeners;
}
function normalizePlainTextDefinition(def) {
  return {
    text: [def]
  };
}
function normalizeTextDefinition(def) {
  def.text = toArray(def.text);
}
function arrayify(obj, key) {
  obj[key] = toArray(obj[key]);
}
function arrayValueReducer(prev, cur) {
  if (isFalsy(cur)) {
    return prev;
  } else if (isFalsy(prev)) {
    return cur;
  } else {
    return `${prev} ${cur}`;
  }
}
function extendObjectValueArray(obj, ext) {
  for (const a in ext) {
    if (obj[a]) {
      obj[a].push(...ext[a]);
    } else {
      obj[a] = ext[a];
    }
  }
}
function extendTemplate(template, def) {
  if (def.attributes) {
    if (!template.attributes) {
      template.attributes = {};
    }
    extendObjectValueArray(template.attributes, def.attributes);
  }
  if (def.eventListeners) {
    if (!template.eventListeners) {
      template.eventListeners = {};
    }
    extendObjectValueArray(template.eventListeners, def.eventListeners);
  }
  if (def.text) {
    template.text.push(...def.text);
  }
  if (def.children && def.children.length) {
    if (template.children.length != def.children.length) {
      throw new CKEditorError("ui-template-extend-children-mismatch", template);
    }
    let childIndex = 0;
    for (const childDef of def.children) {
      extendTemplate(template.children[childIndex++], childDef);
    }
  }
}
function isFalsy(value) {
  return !value && value !== 0;
}
function isView(item) {
  return item instanceof View;
}
function isTemplate(item) {
  return item instanceof Template;
}
function isViewCollection(item) {
  return item instanceof ViewCollection;
}
function isNamespaced(attrValue) {
  return isObject_default(attrValue[0]) && attrValue[0].ns;
}
function getEmptyRevertData() {
  return {
    children: [],
    bindings: [],
    attributes: {}
  };
}
function shouldExtend(attrName) {
  return attrName == "class" || attrName == "style";
}

// node_modules/@ckeditor/ckeditor5-ui/src/view.js
import "/var/www/html/manorama/node_modules/@ckeditor/ckeditor5-ui/theme/globals/globals.css";
var View = class extends DomEmitterMixin(ObservableMixin()) {
  /**
   * Creates an instance of the {@link module:ui/view~View} class.
   *
   * Also see {@link #render}.
   *
   * @param locale The localization services instance.
   */
  constructor(locale) {
    super();
    this.element = null;
    this.isRendered = false;
    this.locale = locale;
    this.t = locale && locale.t;
    this._viewCollections = new Collection();
    this._unboundChildren = this.createCollection();
    this._viewCollections.on("add", (evt, collection) => {
      collection.locale = locale;
      collection.t = locale && locale.t;
    });
    this.decorate("render");
  }
  /**
   * Shorthand for {@link module:ui/template~Template.bind}, a binding
   * {@link module:ui/template~BindChain interface} pre–configured for the view instance.
   *
   * It provides {@link module:ui/template~BindChain#to `to()`} and
   * {@link module:ui/template~BindChain#if `if()`} methods that initialize bindings with
   * observable attributes and attach DOM listeners.
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor( locale ) {
   * 		super( locale );
   *
   * 		const bind = this.bindTemplate;
   *
   * 		// These {@link module:utils/observablemixin~Observable observable} attributes will control
   * 		// the state of the view in DOM.
   * 		this.set( {
   * 			elementClass: 'foo',
   * 		 	isEnabled: true
   * 		 } );
   *
   * 		this.setTemplate( {
   * 			tag: 'p',
   *
   * 			attributes: {
   * 				// The class HTML attribute will follow elementClass
   * 				// and isEnabled view attributes.
   * 				class: [
   * 					bind.to( 'elementClass' )
   * 					bind.if( 'isEnabled', 'present-when-enabled' )
   * 				]
   * 			},
   *
   * 			on: {
   * 				// The view will fire the "clicked" event upon clicking <p> in DOM.
   * 				click: bind.to( 'clicked' )
   * 			}
   * 		} );
   * 	}
   * }
   * ```
   */
  get bindTemplate() {
    if (this._bindTemplate) {
      return this._bindTemplate;
    }
    return this._bindTemplate = Template.bind(this, this);
  }
  /**
   * Creates a new collection of views, which can be used as
   * {@link module:ui/template~Template#children} of this view.
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor( locale ) {
   * 		super( locale );
   *
   * 		const child = new ChildView( locale );
   * 		this.items = this.createCollection( [ child ] );
   *
   * 		this.setTemplate( {
   * 			tag: 'p',
   *
   * 			// `items` collection will render here.
   * 			children: this.items
   * 		} );
   * 	}
   * }
   *
   * const view = new SampleView( locale );
   * view.render();
   *
   * // It will append <p><child#element></p> to the <body>.
   * document.body.appendChild( view.element );
   * ```
   *
   * @param views Initial views of the collection.
   * @returns A new collection of view instances.
   */
  createCollection(views) {
    const collection = new ViewCollection(views);
    this._viewCollections.add(collection);
    return collection;
  }
  /**
   * Registers a new child view under the view instance. Once registered, a child
   * view is managed by its parent, including {@link #render rendering}
   * and {@link #destroy destruction}.
   *
   * To revert this, use {@link #deregisterChild}.
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor( locale ) {
   * 		super( locale );
   *
   * 		this.childA = new SomeChildView( locale );
   * 		this.childB = new SomeChildView( locale );
   *
   * 		this.setTemplate( { tag: 'p' } );
   *
   * 		// Register the children.
   * 		this.registerChild( [ this.childA, this.childB ] );
   * 	}
   *
   * 	render() {
   * 		super.render();
   *
   * 		this.element.appendChild( this.childA.element );
   * 		this.element.appendChild( this.childB.element );
   * 	}
   * }
   *
   * const view = new SampleView( locale );
   *
   * view.render();
   *
   * // Will append <p><childA#element><b></b><childB#element></p>.
   * document.body.appendChild( view.element );
   * ```
   *
   * **Note**: There's no need to add child views if they're already referenced in the
   * {@link #template}:
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor( locale ) {
   * 		super( locale );
   *
   * 		this.childA = new SomeChildView( locale );
   * 		this.childB = new SomeChildView( locale );
   *
   * 		this.setTemplate( {
   * 			tag: 'p',
   *
   * 			// These children will be added automatically. There's no
   * 			// need to call {@link #registerChild} for any of them.
   * 			children: [ this.childA, this.childB ]
   * 		} );
   * 	}
   *
   * 	// ...
   * }
   * ```
   *
   * @param children Children views to be registered.
   */
  registerChild(children) {
    if (!isIterable(children)) {
      children = [children];
    }
    for (const child of children) {
      this._unboundChildren.add(child);
    }
  }
  /**
   * The opposite of {@link #registerChild}. Removes a child view from this view instance.
   * Once removed, the child is no longer managed by its parent, e.g. it can safely
   * become a child of another parent view.
   *
   * @see #registerChild
   * @param children Child views to be removed.
   */
  deregisterChild(children) {
    if (!isIterable(children)) {
      children = [children];
    }
    for (const child of children) {
      this._unboundChildren.remove(child);
    }
  }
  /**
   * Sets the {@link #template} of the view with with given definition.
   *
   * A shorthand for:
   *
   * ```ts
   * view.setTemplate( definition );
   * ```
   *
   * @param definition Definition of view's template.
   */
  setTemplate(definition) {
    this.template = new Template(definition);
  }
  /**
   * {@link module:ui/template~Template.extend Extends} the {@link #template} of the view with
   * with given definition.
   *
   * A shorthand for:
   *
   * ```ts
   * Template.extend( view.template, definition );
   * ```
   *
   * **Note**: Is requires the {@link #template} to be already set. See {@link #setTemplate}.
   *
   * @param definition Definition which extends the {@link #template}.
   */
  extendTemplate(definition) {
    Template.extend(this.template, definition);
  }
  /**
   * Recursively renders the view.
   *
   * Once the view is rendered:
   * * the {@link #element} becomes an HTML element out of {@link #template},
   * * the {@link #isRendered} flag is set `true`.
   *
   * **Note**: The children of the view:
   * * defined directly in the {@link #template}
   * * residing in collections created by the {@link #createCollection} method,
   * * and added by {@link #registerChild}
   * are also rendered in the process.
   *
   * In general, `render()` method is the right place to keep the code which refers to the
   * {@link #element} and should be executed at the very beginning of the view's life cycle.
   *
   * It is possible to {@link module:ui/template~Template.extend} the {@link #template} before
   * the view is rendered. To allow an early customization of the view (e.g. by its parent),
   * such references should be done in `render()`.
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor() {
   * 		this.setTemplate( {
   * 			// ...
   * 		} );
   * 	},
   *
   * 	render() {
   * 		// View#element becomes available.
   * 		super.render();
   *
   * 		// The "scroll" listener depends on #element.
   * 		this.listenTo( window, 'scroll', () => {
   * 			// A reference to #element would render the #template and make it non-extendable.
   * 			if ( window.scrollY > 0 ) {
   * 				this.element.scrollLeft = 100;
   * 			} else {
   * 				this.element.scrollLeft = 0;
   * 			}
   * 		} );
   * 	}
   * }
   *
   * const view = new SampleView();
   *
   * // Let's customize the view before it gets rendered.
   * view.extendTemplate( {
   * 	attributes: {
   * 		class: [
   * 			'additional-class'
   * 		]
   * 	}
   * } );
   *
   * // Late rendering allows customization of the view.
   * view.render();
   * ```
   */
  render() {
    if (this.isRendered) {
      throw new CKEditorError("ui-view-render-already-rendered", this);
    }
    if (this.template) {
      this.element = this.template.render();
      this.registerChild(this.template.getViews());
    }
    this.isRendered = true;
  }
  /**
   * Recursively destroys the view instance and child views added by {@link #registerChild} and
   * residing in collections created by the {@link #createCollection}.
   *
   * Destruction disables all event listeners:
   * * created on the view, e.g. `view.on( 'event', () => {} )`,
   * * defined in the {@link #template} for DOM events.
   */
  destroy() {
    this.stopListening();
    this._viewCollections.map((c) => c.destroy());
    if (this.template && this.template._revertData) {
      this.template.revert(this.element);
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/icon/iconview.js
import "/var/www/html/manorama/node_modules/@ckeditor/ckeditor5-ui/theme/components/icon/icon.css";
var IconView = class _IconView extends View {
  /**
   * @inheritDoc
   */
  constructor() {
    super();
    const bind = this.bindTemplate;
    this.set("content", "");
    this.set("viewBox", "0 0 20 20");
    this.set("fillColor", "");
    this.set("isColorInherited", true);
    this.set("isVisible", true);
    this.setTemplate({
      tag: "svg",
      ns: "http://www.w3.org/2000/svg",
      attributes: {
        class: [
          "ck",
          "ck-icon",
          bind.if("isVisible", "ck-hidden", (value) => !value),
          // Exclude icon internals from the CSS reset to allow rich (non-monochromatic) icons
          // (https://github.com/ckeditor/ckeditor5/issues/12599).
          "ck-reset_all-excluded",
          // The class to remove the dynamic color inheritance is toggleable
          // (https://github.com/ckeditor/ckeditor5/issues/12599).
          bind.if("isColorInherited", "ck-icon_inherit-color")
        ],
        viewBox: bind.to("viewBox")
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this._updateXMLContent();
    this._colorFillPaths();
    this.on("change:content", () => {
      this._updateXMLContent();
      this._colorFillPaths();
    });
    this.on("change:fillColor", () => {
      this._colorFillPaths();
    });
  }
  /**
   * Updates the {@link #element} with the value of {@link #content}.
   */
  _updateXMLContent() {
    if (this.content) {
      const parsed = new DOMParser().parseFromString(this.content.trim(), "image/svg+xml");
      const svg2 = parsed.querySelector("svg");
      const viewBox = svg2.getAttribute("viewBox");
      if (viewBox) {
        this.viewBox = viewBox;
      }
      for (const { name, value } of Array.from(svg2.attributes)) {
        if (_IconView.presentationalAttributeNames.includes(name)) {
          this.element.setAttribute(name, value);
        }
      }
      while (this.element.firstChild) {
        this.element.removeChild(this.element.firstChild);
      }
      while (svg2.childNodes.length > 0) {
        this.element.appendChild(svg2.childNodes[0]);
      }
    }
  }
  /**
   * Fills all child `path.ck-icon__fill` with the `#fillColor`.
   */
  _colorFillPaths() {
    if (this.fillColor) {
      this.element.querySelectorAll(".ck-icon__fill").forEach((path) => {
        path.style.fill = this.fillColor;
      });
    }
  }
};
IconView.presentationalAttributeNames = [
  "alignment-baseline",
  "baseline-shift",
  "clip-path",
  "clip-rule",
  "color",
  "color-interpolation",
  "color-interpolation-filters",
  "color-rendering",
  "cursor",
  "direction",
  "display",
  "dominant-baseline",
  "fill",
  "fill-opacity",
  "fill-rule",
  "filter",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "mask",
  "opacity",
  "overflow",
  "paint-order",
  "pointer-events",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "stroke",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-overflow",
  "text-rendering",
  "transform",
  "unicode-bidi",
  "vector-effect",
  "visibility",
  "white-space",
  "word-spacing",
  "writing-mode"
];
var iconview_default = IconView;

// node_modules/@ckeditor/ckeditor5-ui/src/button/buttonlabelview.js
var ButtonLabelView = class extends View {
  /**
   * @inheritDoc
   */
  constructor() {
    super();
    this.set({
      style: void 0,
      text: void 0,
      id: void 0
    });
    const bind = this.bindTemplate;
    this.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-button__label"
        ],
        style: bind.to("style"),
        id: bind.to("id")
      },
      children: [
        {
          text: bind.to("text")
        }
      ]
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/button/buttonview.js
import "/var/www/html/manorama/node_modules/@ckeditor/ckeditor5-ui/theme/components/button/button.css";
var ButtonView = class extends View {
  /**
   * Creates an instance of the button view class.
   *
   * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
   * @param labelView The instance of the button's label. If not provided, an instance of
   * {@link module:ui/button/buttonlabelview~ButtonLabelView} is used.
   */
  constructor(locale, labelView = new ButtonLabelView()) {
    super(locale);
    this._focusDelayed = null;
    const bind = this.bindTemplate;
    const ariaLabelUid = uid();
    this.set("ariaLabel", void 0);
    this.set("ariaLabelledBy", `ck-editor__aria-label_${ariaLabelUid}`);
    this.set("class", void 0);
    this.set("labelStyle", void 0);
    this.set("icon", void 0);
    this.set("isEnabled", true);
    this.set("isOn", false);
    this.set("isVisible", true);
    this.set("isToggleable", false);
    this.set("keystroke", void 0);
    this.set("label", void 0);
    this.set("role", void 0);
    this.set("tabindex", -1);
    this.set("tooltip", false);
    this.set("tooltipPosition", "s");
    this.set("type", "button");
    this.set("withText", false);
    this.set("withKeystroke", false);
    this.children = this.createCollection();
    this.labelView = this._setupLabelView(labelView);
    this.iconView = new iconview_default();
    this.iconView.extendTemplate({
      attributes: {
        class: "ck-button__icon"
      }
    });
    this.keystrokeView = this._createKeystrokeView();
    this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this));
    const template = {
      tag: "button",
      attributes: {
        class: [
          "ck",
          "ck-button",
          bind.to("class"),
          bind.if("isEnabled", "ck-disabled", (value) => !value),
          bind.if("isVisible", "ck-hidden", (value) => !value),
          bind.to("isOn", (value) => value ? "ck-on" : "ck-off"),
          bind.if("withText", "ck-button_with-text"),
          bind.if("withKeystroke", "ck-button_with-keystroke")
        ],
        role: bind.to("role"),
        type: bind.to("type", (value) => value ? value : "button"),
        tabindex: bind.to("tabindex"),
        "aria-label": bind.to("ariaLabel"),
        "aria-labelledby": bind.to("ariaLabelledBy"),
        "aria-disabled": bind.if("isEnabled", true, (value) => !value),
        "aria-pressed": bind.to("isOn", (value) => this.isToggleable ? String(!!value) : false),
        "data-cke-tooltip-text": bind.to("_tooltipString"),
        "data-cke-tooltip-position": bind.to("tooltipPosition")
      },
      children: this.children,
      on: {
        click: bind.to((evt) => {
          if (this.isEnabled) {
            this.fire("execute");
          } else {
            evt.preventDefault();
          }
        })
      }
    };
    if (env_default.isSafari) {
      if (!this._focusDelayed) {
        this._focusDelayed = delay(() => this.focus(), 0);
      }
      template.on.mousedown = bind.to(() => {
        this._focusDelayed();
      });
      template.on.mouseup = bind.to(() => {
        this._focusDelayed.cancel();
      });
    }
    this.setTemplate(template);
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    if (this.icon) {
      this.iconView.bind("content").to(this, "icon");
      this.children.add(this.iconView);
    }
    this.children.add(this.labelView);
    if (this.withKeystroke && this.keystroke) {
      this.children.add(this.keystrokeView);
    }
  }
  /**
   * Focuses the {@link #element} of the button.
   */
  focus() {
    this.element.focus();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    if (this._focusDelayed) {
      this._focusDelayed.cancel();
    }
    super.destroy();
  }
  /**
   * Binds the label view instance it with button attributes.
   */
  _setupLabelView(labelView) {
    labelView.bind("text", "style", "id").to(this, "label", "labelStyle", "ariaLabelledBy");
    return labelView;
  }
  /**
   * Creates a view that displays a keystroke next to a {@link #labelView label }
   * and binds it with button attributes.
   */
  _createKeystrokeView() {
    const keystrokeView = new View();
    keystrokeView.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-button__keystroke"
        ]
      },
      children: [
        {
          text: this.bindTemplate.to("keystroke", (text2) => getEnvKeystrokeText(text2))
        }
      ]
    });
    return keystrokeView;
  }
  /**
   * Gets the text for the tooltip from the combination of
   * {@link #tooltip}, {@link #label} and {@link #keystroke} attributes.
   *
   * @see #tooltip
   * @see #_tooltipString
   * @param tooltip Button tooltip.
   * @param label Button label.
   * @param keystroke Button keystroke.
   */
  _getTooltipString(tooltip, label, keystroke) {
    if (tooltip) {
      if (typeof tooltip == "string") {
        return tooltip;
      } else {
        if (keystroke) {
          keystroke = getEnvKeystrokeText(keystroke);
        }
        if (tooltip instanceof Function) {
          return tooltip(label, keystroke);
        } else {
          return `${label}${keystroke ? ` (${keystroke})` : ""}`;
        }
      }
    }
    return "";
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/observer.js
var Observer = class extends DomEmitterMixin() {
  /**
   * Creates an instance of the observer.
   */
  constructor(view) {
    super();
    this._isEnabled = false;
    this.view = view;
    this.document = view.document;
  }
  /**
   * The state of the observer. If it is disabled, no events will be fired.
   */
  get isEnabled() {
    return this._isEnabled;
  }
  /**
   * Enables the observer. This method is called when the observer is registered to the
   * {@link module:engine/view/view~View} and after {@link module:engine/view/view~View#forceRender rendering}
   * (all observers are {@link #disable disabled} before rendering).
   *
   * A typical use case for disabling observers is that mutation observers need to be disabled for the rendering.
   * However, a child class may not need to be disabled, so it can implement an empty method.
   *
   * @see module:engine/view/observer/observer~Observer#disable
   */
  enable() {
    this._isEnabled = true;
  }
  /**
   * Disables the observer. This method is called before
   * {@link module:engine/view/view~View#forceRender rendering} to prevent firing events during rendering.
   *
   * @see module:engine/view/observer/observer~Observer#enable
   */
  disable() {
    this._isEnabled = false;
  }
  /**
   * Disables and destroys the observer, among others removes event listeners created by the observer.
   */
  destroy() {
    this.disable();
    this.stopListening();
  }
  /**
   * Checks whether a given DOM event should be ignored (should not be turned into a synthetic view document event).
   *
   * Currently, an event will be ignored only if its target or any of its ancestors has the `data-cke-ignore-events` attribute.
   * This attribute can be used inside the structures generated by
   * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement `DowncastWriter#createUIElement()`} to ignore events
   * fired within a UI that should be excluded from CKEditor 5's realms.
   *
   * @param domTarget The DOM event target to check (usually an element, sometimes a text node and
   * potentially sometimes a document, too).
   * @returns Whether this event should be ignored by the observer.
   */
  checkShouldIgnoreEventFromTarget(domTarget) {
    if (domTarget && domTarget.nodeType === 3) {
      domTarget = domTarget.parentNode;
    }
    if (!domTarget || domTarget.nodeType !== 1) {
      return false;
    }
    return domTarget.matches("[data-cke-ignore-events], [data-cke-ignore-events] *");
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/domeventdata.js
var DomEventData = class {
  /**
   * @param view The instance of the view controller.
   * @param domEvent The DOM event.
   * @param additionalData Additional properties that the instance should contain.
   */
  constructor(view, domEvent, additionalData) {
    this.view = view;
    this.document = view.document;
    this.domEvent = domEvent;
    this.domTarget = domEvent.target;
    assignIn_default(this, additionalData);
  }
  /**
   * The tree view element representing the target.
   */
  get target() {
    return this.view.domConverter.mapDomToView(this.domTarget);
  }
  /**
   * Prevents the native's event default action.
   */
  preventDefault() {
    this.domEvent.preventDefault();
  }
  /**
   * Stops native event propagation.
   */
  stopPropagation() {
    this.domEvent.stopPropagation();
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/domeventobserver.js
var DomEventObserver = class extends Observer {
  constructor() {
    super(...arguments);
    this.useCapture = false;
  }
  /**
   * @inheritDoc
   */
  observe(domElement) {
    const types = typeof this.domEventType == "string" ? [this.domEventType] : this.domEventType;
    types.forEach((type) => {
      this.listenTo(domElement, type, (eventInfo, domEvent) => {
        if (this.isEnabled && !this.checkShouldIgnoreEventFromTarget(domEvent.target)) {
          this.onDomEvent(domEvent);
        }
      }, { useCapture: this.useCapture });
    });
  }
  /**
   * @inheritDoc
   */
  stopObserving(domElement) {
    this.stopListening(domElement);
  }
  /**
   * Calls `Document#fire()` if observer {@link #isEnabled is enabled}.
   *
   * @see module:utils/emittermixin~Emitter#fire
   * @param eventType The event type (name).
   * @param domEvent The DOM event.
   * @param additionalData The additional data which should extend the
   * {@link module:engine/view/observer/domeventdata~DomEventData event data} object.
   */
  fire(eventType, domEvent, additionalData) {
    if (this.isEnabled) {
      this.document.fire(eventType, new DomEventData(this.view, domEvent, additionalData));
    }
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/clickobserver.js
var ClickObserver = class extends DomEventObserver {
  constructor() {
    super(...arguments);
    this.domEventType = "click";
  }
  /**
   * @inheritDoc
   */
  onDomEvent(domEvent) {
    this.fire(domEvent.type, domEvent);
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/dataprocessor/basichtmlwriter.js
var BasicHtmlWriter = class {
  /**
   * Returns an HTML string created from the document fragment.
   */
  getHtml(fragment) {
    const doc = global_default.document.implementation.createHTMLDocument("");
    const container = doc.createElement("div");
    container.appendChild(fragment);
    return container.innerHTML;
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/typecheckable.js
var TypeCheckable = class {
  /* istanbul ignore next -- @preserve */
  is() {
    throw new Error("is() method is abstract");
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/node.js
var Node2 = class extends EmitterMixin(TypeCheckable) {
  /**
   * Creates a tree view node.
   *
   * @param document The document instance to which this node belongs.
   */
  constructor(document2) {
    super();
    this.document = document2;
    this.parent = null;
  }
  /**
   * Index of the node in the parent element or null if the node has no parent.
   *
   * Accessing this property throws an error if this node's parent element does not contain it.
   * This means that view tree got broken.
   */
  get index() {
    let pos;
    if (!this.parent) {
      return null;
    }
    if ((pos = this.parent.getChildIndex(this)) == -1) {
      throw new CKEditorError("view-node-not-found-in-parent", this);
    }
    return pos;
  }
  /**
   * Node's next sibling, or `null` if it is the last child.
   */
  get nextSibling() {
    const index = this.index;
    return index !== null && this.parent.getChild(index + 1) || null;
  }
  /**
   * Node's previous sibling, or `null` if it is the first child.
   */
  get previousSibling() {
    const index = this.index;
    return index !== null && this.parent.getChild(index - 1) || null;
  }
  /**
   * Top-most ancestor of the node. If the node has no parent it is the root itself.
   */
  get root() {
    let root = this;
    while (root.parent) {
      root = root.parent;
    }
    return root;
  }
  /**
   * Returns true if the node is in a tree rooted in the document (is a descendant of one of its roots).
   */
  isAttached() {
    return this.root.is("rootElement");
  }
  /**
   * Gets a path to the node. The path is an array containing indices of consecutive ancestors of this node,
   * beginning from {@link module:engine/view/node~Node#root root}, down to this node's index.
   *
   * ```ts
   * const abc = downcastWriter.createText( 'abc' );
   * const foo = downcastWriter.createText( 'foo' );
   * const h1 = downcastWriter.createElement( 'h1', null, downcastWriter.createText( 'header' ) );
   * const p = downcastWriter.createElement( 'p', null, [ abc, foo ] );
   * const div = downcastWriter.createElement( 'div', null, [ h1, p ] );
   * foo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.
   * h1.getPath(); // Returns [ 0 ].
   * div.getPath(); // Returns [].
   * ```
   *
   * @returns The path.
   */
  getPath() {
    const path = [];
    let node = this;
    while (node.parent) {
      path.unshift(node.index);
      node = node.parent;
    }
    return path;
  }
  /**
   * Returns ancestors array of this node.
   *
   * @param options Options object.
   * @param options.includeSelf When set to `true` this node will be also included in parent's array.
   * @param options.parentFirst When set to `true`, array will be sorted from node's parent to root element,
   * otherwise root element will be the first item in the array.
   * @returns Array with ancestors.
   */
  getAncestors(options = {}) {
    const ancestors = [];
    let parent = options.includeSelf ? this : this.parent;
    while (parent) {
      ancestors[options.parentFirst ? "push" : "unshift"](parent);
      parent = parent.parent;
    }
    return ancestors;
  }
  /**
   * Returns a {@link module:engine/view/element~Element} or {@link module:engine/view/documentfragment~DocumentFragment}
   * which is a common ancestor of both nodes.
   *
   * @param node The second node.
   * @param options Options object.
   * @param options.includeSelf When set to `true` both nodes will be considered "ancestors" too.
   * Which means that if e.g. node A is inside B, then their common ancestor will be B.
   */
  getCommonAncestor(node, options = {}) {
    const ancestorsA = this.getAncestors(options);
    const ancestorsB = node.getAncestors(options);
    let i = 0;
    while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {
      i++;
    }
    return i === 0 ? null : ancestorsA[i - 1];
  }
  /**
   * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,
   * in different {@link module:engine/view/documentfragment~DocumentFragment}s).
   *
   * @param node Node to compare with.
   */
  isBefore(node) {
    if (this == node) {
      return false;
    }
    if (this.root !== node.root) {
      return false;
    }
    const thisPath = this.getPath();
    const nodePath = node.getPath();
    const result = compareArrays(thisPath, nodePath);
    switch (result) {
      case "prefix":
        return true;
      case "extension":
        return false;
      default:
        return thisPath[result] < nodePath[result];
    }
  }
  /**
   * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,
   * in different {@link module:engine/view/documentfragment~DocumentFragment}s).
   *
   * @param node Node to compare with.
   */
  isAfter(node) {
    if (this == node) {
      return false;
    }
    if (this.root !== node.root) {
      return false;
    }
    return !this.isBefore(node);
  }
  /**
   * Removes node from parent.
   *
   * @internal
   */
  _remove() {
    this.parent._removeChildren(this.index);
  }
  /**
   * @internal
   * @param type Type of the change.
   * @param node Changed node.
   * @fires change
   */
  _fireChange(type, node) {
    this.fire(`change:${type}`, node);
    if (this.parent) {
      this.parent._fireChange(type, node);
    }
  }
  /**
   * Custom toJSON method to solve child-parent circular dependencies.
   *
   * @returns Clone of this object with the parent property removed.
   */
  toJSON() {
    const json = clone_default(this);
    delete json.parent;
    return json;
  }
};
Node2.prototype.is = function(type) {
  return type === "node" || type === "view:node";
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/text.js
var Text = class _Text extends Node2 {
  /**
   * Creates a tree view text node.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createText
   * @internal
   * @param document The document instance to which this text node belongs.
   * @param data The text's data.
   */
  constructor(document2, data) {
    super(document2);
    this._textData = data;
  }
  /**
   * The text content.
   */
  get data() {
    return this._textData;
  }
  /**
   * The `_data` property is controlled by a getter and a setter.
   *
   * The getter is required when using the addition assignment operator on protected property:
   *
   * ```ts
   * const foo = downcastWriter.createText( 'foo' );
   * const bar = downcastWriter.createText( 'bar' );
   *
   * foo._data += bar.data;   // executes: `foo._data = foo._data + bar.data`
   * console.log( foo.data ); // prints: 'foobar'
   * ```
   *
   * If the protected getter didn't exist, `foo._data` will return `undefined` and result of the merge will be invalid.
   *
   * The setter sets data and fires the {@link module:engine/view/node~Node#event:change:text change event}.
   *
   * @internal
   */
  get _data() {
    return this.data;
  }
  set _data(data) {
    this._fireChange("text", this);
    this._textData = data;
  }
  /**
   * Checks if this text node is similar to other text node.
   * Both nodes should have the same data to be considered as similar.
   *
   * @param otherNode Node to check if it is same as this node.
   */
  isSimilar(otherNode) {
    if (!(otherNode instanceof _Text)) {
      return false;
    }
    return this === otherNode || this.data === otherNode.data;
  }
  /**
   * Clones this node.
   *
   * @internal
   * @returns Text node that is a clone of this node.
   */
  _clone() {
    return new _Text(this.document, this.data);
  }
};
Text.prototype.is = function(type) {
  return type === "$text" || type === "view:$text" || // This are legacy values kept for backward compatibility.
  type === "text" || type === "view:text" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  type === "node" || type === "view:node";
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/textproxy.js
var TextProxy = class extends TypeCheckable {
  /**
   * Creates a text proxy.
   *
   * @internal
   * @param textNode Text node which part is represented by this text proxy.
   * @param offsetInText Offset in {@link module:engine/view/textproxy~TextProxy#textNode text node}
   * from which the text proxy starts.
   * @param length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.
   * @constructor
   */
  constructor(textNode, offsetInText, length) {
    super();
    this.textNode = textNode;
    if (offsetInText < 0 || offsetInText > textNode.data.length) {
      throw new CKEditorError("view-textproxy-wrong-offsetintext", this);
    }
    if (length < 0 || offsetInText + length > textNode.data.length) {
      throw new CKEditorError("view-textproxy-wrong-length", this);
    }
    this.data = textNode.data.substring(offsetInText, offsetInText + length);
    this.offsetInText = offsetInText;
  }
  /**
   * Offset size of this node.
   */
  get offsetSize() {
    return this.data.length;
  }
  /**
   * Flag indicating whether `TextProxy` instance covers only part of the original {@link module:engine/view/text~Text text node}
   * (`true`) or the whole text node (`false`).
   *
   * This is `false` when text proxy starts at the very beginning of {@link module:engine/view/textproxy~TextProxy#textNode textNode}
   * ({@link module:engine/view/textproxy~TextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to
   * text node size.
   */
  get isPartial() {
    return this.data.length !== this.textNode.data.length;
  }
  /**
   * Parent of this text proxy, which is same as parent of text node represented by this text proxy.
   */
  get parent() {
    return this.textNode.parent;
  }
  /**
   * Root of this text proxy, which is same as root of text node represented by this text proxy.
   */
  get root() {
    return this.textNode.root;
  }
  /**
   * {@link module:engine/view/document~Document View document} that owns this text proxy, or `null` if the text proxy is inside
   * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.
   */
  get document() {
    return this.textNode.document;
  }
  /**
   * Returns ancestors array of this text proxy.
   *
   * @param options Options object.
   * @param options.includeSelf When set to `true`, textNode will be also included in parent's array.
   * @param options.parentFirst When set to `true`, array will be sorted from text proxy parent to
   * root element, otherwise root element will be the first item in the array.
   * @returns Array with ancestors.
   */
  getAncestors(options = {}) {
    const ancestors = [];
    let parent = options.includeSelf ? this.textNode : this.parent;
    while (parent !== null) {
      ancestors[options.parentFirst ? "push" : "unshift"](parent);
      parent = parent.parent;
    }
    return ancestors;
  }
};
TextProxy.prototype.is = function(type) {
  return type === "$textProxy" || type === "view:$textProxy" || // This are legacy values kept for backward compatibility.
  type === "textProxy" || type === "view:textProxy";
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/matcher.js
var Matcher = class {
  /**
   * Creates new instance of Matcher.
   *
   * @param pattern Match patterns. See {@link module:engine/view/matcher~Matcher#add add method} for more information.
   */
  constructor(...pattern) {
    this._patterns = [];
    this.add(...pattern);
  }
  /**
   * Adds pattern or patterns to matcher instance.
   *
   * ```ts
   * // String.
   * matcher.add( 'div' );
   *
   * // Regular expression.
   * matcher.add( /^\w/ );
   *
   * // Single class.
   * matcher.add( {
   * 	classes: 'foobar'
   * } );
   * ```
   *
   * See {@link module:engine/view/matcher~MatcherPattern} for more examples.
   *
   * Multiple patterns can be added in one call:
   *
   * ```ts
   * matcher.add( 'div', { classes: 'foobar' } );
   * ```
   *
   * @param pattern Object describing pattern details. If string or regular expression
   * is provided it will be used to match element's name. Pattern can be also provided in a form
   * of a function - then this function will be called with each {@link module:engine/view/element~Element element} as a parameter.
   * Function's return value will be stored under `match` key of the object returned from
   * {@link module:engine/view/matcher~Matcher#match match} or {@link module:engine/view/matcher~Matcher#matchAll matchAll} methods.
   */
  add(...pattern) {
    for (let item of pattern) {
      if (typeof item == "string" || item instanceof RegExp) {
        item = { name: item };
      }
      this._patterns.push(item);
    }
  }
  /**
   * Matches elements for currently stored patterns. Returns match information about first found
   * {@link module:engine/view/element~Element element}, otherwise returns `null`.
   *
   * Example of returned object:
   *
   * ```ts
   * {
   * 	element: <instance of found element>,
   * 	pattern: <pattern used to match found element>,
   * 	match: {
   * 		name: true,
   * 		attributes: [ 'title', 'href' ],
   * 		classes: [ 'foo' ],
   * 		styles: [ 'color', 'position' ]
   * 	}
   * }
   * ```
   *
   * @see module:engine/view/matcher~Matcher#add
   * @see module:engine/view/matcher~Matcher#matchAll
   * @param element View element to match against stored patterns.
   */
  match(...element) {
    for (const singleElement of element) {
      for (const pattern of this._patterns) {
        const match = isElementMatching(singleElement, pattern);
        if (match) {
          return {
            element: singleElement,
            pattern,
            match
          };
        }
      }
    }
    return null;
  }
  /**
   * Matches elements for currently stored patterns. Returns array of match information with all found
   * {@link module:engine/view/element~Element elements}. If no element is found - returns `null`.
   *
   * @see module:engine/view/matcher~Matcher#add
   * @see module:engine/view/matcher~Matcher#match
   * @param element View element to match against stored patterns.
   * @returns Array with match information about found elements or `null`. For more information
   * see {@link module:engine/view/matcher~Matcher#match match method} description.
   */
  matchAll(...element) {
    const results = [];
    for (const singleElement of element) {
      for (const pattern of this._patterns) {
        const match = isElementMatching(singleElement, pattern);
        if (match) {
          results.push({
            element: singleElement,
            pattern,
            match
          });
        }
      }
    }
    return results.length > 0 ? results : null;
  }
  /**
   * Returns the name of the element to match if there is exactly one pattern added to the matcher instance
   * and it matches element name defined by `string` (not `RegExp`). Otherwise, returns `null`.
   *
   * @returns Element name trying to match.
   */
  getElementName() {
    if (this._patterns.length !== 1) {
      return null;
    }
    const pattern = this._patterns[0];
    const name = pattern.name;
    return typeof pattern != "function" && name && !(name instanceof RegExp) ? name : null;
  }
};
function isElementMatching(element, pattern) {
  if (typeof pattern == "function") {
    return pattern(element);
  }
  const match = {};
  if (pattern.name) {
    match.name = matchName(pattern.name, element.name);
    if (!match.name) {
      return null;
    }
  }
  if (pattern.attributes) {
    match.attributes = matchAttributes(pattern.attributes, element);
    if (!match.attributes) {
      return null;
    }
  }
  if (pattern.classes) {
    match.classes = matchClasses(pattern.classes, element);
    if (!match.classes) {
      return null;
    }
  }
  if (pattern.styles) {
    match.styles = matchStyles(pattern.styles, element);
    if (!match.styles) {
      return null;
    }
  }
  return match;
}
function matchName(pattern, name) {
  if (pattern instanceof RegExp) {
    return !!name.match(pattern);
  }
  return pattern === name;
}
function matchPatterns(patterns, keys, valueGetter) {
  const normalizedPatterns = normalizePatterns(patterns);
  const normalizedItems = Array.from(keys);
  const match = [];
  normalizedPatterns.forEach(([patternKey, patternValue]) => {
    normalizedItems.forEach((itemKey) => {
      if (isKeyMatched(patternKey, itemKey) && isValueMatched(patternValue, itemKey, valueGetter)) {
        match.push(itemKey);
      }
    });
  });
  if (!normalizedPatterns.length || match.length < normalizedPatterns.length) {
    return void 0;
  }
  return match;
}
function normalizePatterns(patterns) {
  if (Array.isArray(patterns)) {
    return patterns.map((pattern) => {
      if (isPlainObject_default(pattern)) {
        if (pattern.key === void 0 || pattern.value === void 0) {
          logWarning("matcher-pattern-missing-key-or-value", pattern);
        }
        return [pattern.key, pattern.value];
      }
      return [pattern, true];
    });
  }
  if (isPlainObject_default(patterns)) {
    return Object.entries(patterns);
  }
  return [[patterns, true]];
}
function isKeyMatched(patternKey, itemKey) {
  return patternKey === true || patternKey === itemKey || patternKey instanceof RegExp && itemKey.match(patternKey);
}
function isValueMatched(patternValue, itemKey, valueGetter) {
  if (patternValue === true) {
    return true;
  }
  const itemValue = valueGetter(itemKey);
  return patternValue === itemValue || patternValue instanceof RegExp && !!String(itemValue).match(patternValue);
}
function matchAttributes(patterns, element) {
  const attributeKeys = new Set(element.getAttributeKeys());
  if (isPlainObject_default(patterns)) {
    if (patterns.style !== void 0) {
      logWarning("matcher-pattern-deprecated-attributes-style-key", patterns);
    }
    if (patterns.class !== void 0) {
      logWarning("matcher-pattern-deprecated-attributes-class-key", patterns);
    }
  } else {
    attributeKeys.delete("style");
    attributeKeys.delete("class");
  }
  return matchPatterns(patterns, attributeKeys, (key) => element.getAttribute(key));
}
function matchClasses(patterns, element) {
  return matchPatterns(
    patterns,
    element.getClassNames(),
    /* istanbul ignore next -- @preserve */
    () => {
    }
  );
}
function matchStyles(patterns, element) {
  return matchPatterns(patterns, element.getStyleNames(true), (key) => element.getStyle(key));
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/stylesmap.js
var StylesMap = class {
  /**
   * Creates Styles instance.
   */
  constructor(styleProcessor) {
    this._styles = {};
    this._styleProcessor = styleProcessor;
  }
  /**
   * Returns true if style map has no styles set.
   */
  get isEmpty() {
    const entries = Object.entries(this._styles);
    return !entries.length;
  }
  /**
   * Number of styles defined.
   */
  get size() {
    if (this.isEmpty) {
      return 0;
    }
    return this.getStyleNames().length;
  }
  /**
   * Set styles map to a new value.
   *
   * ```ts
   * styles.setTo( 'border:1px solid blue;margin-top:1px;' );
   * ```
   */
  setTo(inlineStyle) {
    this.clear();
    const parsedStyles = parseInlineStyles(inlineStyle);
    for (const [key, value] of parsedStyles) {
      this._styleProcessor.toNormalizedForm(key, value, this._styles);
    }
  }
  /**
   * Checks if a given style is set.
   *
   * ```ts
   * styles.setTo( 'margin-left:1px;' );
   *
   * styles.has( 'margin-left' );    // -> true
   * styles.has( 'padding' );        // -> false
   * ```
   *
   * **Note**: This check supports normalized style names.
   *
   * ```ts
   * // Enable 'margin' shorthand processing:
   * editor.data.addStyleProcessorRules( addMarginRules );
   *
   * styles.setTo( 'margin:2px;' );
   *
   * styles.has( 'margin' );         // -> true
   * styles.has( 'margin-top' );     // -> true
   * styles.has( 'margin-left' );    // -> true
   *
   * styles.remove( 'margin-top' );
   *
   * styles.has( 'margin' );         // -> false
   * styles.has( 'margin-top' );     // -> false
   * styles.has( 'margin-left' );    // -> true
   * ```
   *
   * @param name Style name.
   */
  has(name) {
    if (this.isEmpty) {
      return false;
    }
    const styles = this._styleProcessor.getReducedForm(name, this._styles);
    const propertyDescriptor = styles.find(([property]) => property === name);
    return Array.isArray(propertyDescriptor);
  }
  set(nameOrObject, valueOrObject) {
    if (isObject_default(nameOrObject)) {
      for (const [key, value] of Object.entries(nameOrObject)) {
        this._styleProcessor.toNormalizedForm(key, value, this._styles);
      }
    } else {
      this._styleProcessor.toNormalizedForm(nameOrObject, valueOrObject, this._styles);
    }
  }
  /**
   * Removes given style.
   *
   * ```ts
   * styles.setTo( 'background:#f00;margin-right:2px;' );
   *
   * styles.remove( 'background' );
   *
   * styles.toString();   // -> 'margin-right:2px;'
   * ```
   *
   * ***Note**:* This method uses {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules
   * enabled style processor rules} to normalize passed values.
   *
   * ```ts
   * // Enable 'margin' shorthand processing:
   * editor.data.addStyleProcessorRules( addMarginRules );
   *
   * styles.setTo( 'margin:1px' );
   *
   * styles.remove( 'margin-top' );
   * styles.remove( 'margin-right' );
   *
   * styles.toString(); // -> 'margin-bottom:1px;margin-left:1px;'
   * ```
   *
   * @param name Style name.
   */
  remove(name) {
    const path = toPath(name);
    unset_default(this._styles, path);
    delete this._styles[name];
    this._cleanEmptyObjectsOnPath(path);
  }
  /**
   * Returns a normalized style object or a single value.
   *
   * ```ts
   * // Enable 'margin' shorthand processing:
   * editor.data.addStyleProcessorRules( addMarginRules );
   *
   * const styles = new Styles();
   * styles.setTo( 'margin:1px 2px 3em;' );
   *
   * styles.getNormalized( 'margin' );
   * // will log:
   * // {
   * //     top: '1px',
   * //     right: '2px',
   * //     bottom: '3em',
   * //     left: '2px'     // normalized value from margin shorthand
   * // }
   *
   * styles.getNormalized( 'margin-left' ); // -> '2px'
   * ```
   *
   * **Note**: This method will only return normalized styles if a style processor was defined.
   *
   * @param name Style name.
   */
  getNormalized(name) {
    return this._styleProcessor.getNormalized(name, this._styles);
  }
  /**
   * Returns a normalized style string. Styles are sorted by name.
   *
   * ```ts
   * styles.set( 'margin' , '1px' );
   * styles.set( 'background', '#f00' );
   *
   * styles.toString(); // -> 'background:#f00;margin:1px;'
   * ```
   *
   * **Note**: This method supports normalized styles if defined.
   *
   * ```ts
   * // Enable 'margin' shorthand processing:
   * editor.data.addStyleProcessorRules( addMarginRules );
   *
   * styles.set( 'margin' , '1px' );
   * styles.set( 'background', '#f00' );
   * styles.remove( 'margin-top' );
   * styles.remove( 'margin-right' );
   *
   * styles.toString(); // -> 'background:#f00;margin-bottom:1px;margin-left:1px;'
   * ```
   */
  toString() {
    if (this.isEmpty) {
      return "";
    }
    return this.getStylesEntries().map((arr) => arr.join(":")).sort().join(";") + ";";
  }
  /**
   * Returns property as a value string or undefined if property is not set.
   *
   * ```ts
   * // Enable 'margin' shorthand processing:
   * editor.data.addStyleProcessorRules( addMarginRules );
   *
   * const styles = new Styles();
   * styles.setTo( 'margin:1px;' );
   * styles.set( 'margin-bottom', '3em' );
   *
   * styles.getAsString( 'margin' ); // -> 'margin: 1px 1px 3em;'
   * ```
   *
   * Note, however, that all sub-values must be set for the longhand property name to return a value:
   *
   * ```ts
   * const styles = new Styles();
   * styles.setTo( 'margin:1px;' );
   * styles.remove( 'margin-bottom' );
   *
   * styles.getAsString( 'margin' ); // -> undefined
   * ```
   *
   * In the above scenario, it is not possible to return a `margin` value, so `undefined` is returned.
   * Instead, you should use:
   *
   * ```ts
   * const styles = new Styles();
   * styles.setTo( 'margin:1px;' );
   * styles.remove( 'margin-bottom' );
   *
   * for ( const styleName of styles.getStyleNames() ) {
   * 	console.log( styleName, styles.getAsString( styleName ) );
   * }
   * // 'margin-top', '1px'
   * // 'margin-right', '1px'
   * // 'margin-left', '1px'
   * ```
   *
   * In general, it is recommend to iterate over style names like in the example above. This way, you will always get all
   * the currently set style values. So, if all the 4 margin values would be set
   * the for-of loop above would yield only `'margin'`, `'1px'`:
   *
   * ```ts
   * const styles = new Styles();
   * styles.setTo( 'margin:1px;' );
   *
   * for ( const styleName of styles.getStyleNames() ) {
   * 	console.log( styleName, styles.getAsString( styleName ) );
   * }
   * // 'margin', '1px'
   * ```
   *
   * **Note**: To get a normalized version of a longhand property use the {@link #getNormalized `#getNormalized()`} method.
   */
  getAsString(propertyName) {
    if (this.isEmpty) {
      return;
    }
    if (this._styles[propertyName] && !isObject_default(this._styles[propertyName])) {
      return this._styles[propertyName];
    }
    const styles = this._styleProcessor.getReducedForm(propertyName, this._styles);
    const propertyDescriptor = styles.find(([property]) => property === propertyName);
    if (Array.isArray(propertyDescriptor)) {
      return propertyDescriptor[1];
    }
  }
  /**
   * Returns all style properties names as they would appear when using {@link #toString `#toString()`}.
   *
   * When `expand` is set to true and there's a shorthand style property set, it will also return all equivalent styles:
   *
   * ```ts
   * stylesMap.setTo( 'margin: 1em' )
   * ```
   *
   * will be expanded to:
   *
   * ```ts
   * [ 'margin', 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ]
   * ```
   *
   * @param expand Expand shorthand style properties and all return equivalent style representations.
   */
  getStyleNames(expand = false) {
    if (this.isEmpty) {
      return [];
    }
    if (expand) {
      return this._styleProcessor.getStyleNames(this._styles);
    }
    const entries = this.getStylesEntries();
    return entries.map(([key]) => key);
  }
  /**
   * Removes all styles.
   */
  clear() {
    this._styles = {};
  }
  /**
   * Returns normalized styles entries for further processing.
   */
  getStylesEntries() {
    const parsed = [];
    const keys = Object.keys(this._styles);
    for (const key of keys) {
      parsed.push(...this._styleProcessor.getReducedForm(key, this._styles));
    }
    return parsed;
  }
  /**
   * Removes empty objects upon removing an entry from internal object.
   */
  _cleanEmptyObjectsOnPath(path) {
    const pathParts = path.split(".");
    const isChildPath = pathParts.length > 1;
    if (!isChildPath) {
      return;
    }
    const parentPath = pathParts.splice(0, pathParts.length - 1).join(".");
    const parentObject = get_default(this._styles, parentPath);
    if (!parentObject) {
      return;
    }
    const isParentEmpty = !Object.keys(parentObject).length;
    if (isParentEmpty) {
      this.remove(parentPath);
    }
  }
};
function parseInlineStyles(stylesString) {
  let quoteType = null;
  let propertyNameStart = 0;
  let propertyValueStart = 0;
  let propertyName = null;
  const stylesMap = /* @__PURE__ */ new Map();
  if (stylesString === "") {
    return stylesMap;
  }
  if (stylesString.charAt(stylesString.length - 1) != ";") {
    stylesString = stylesString + ";";
  }
  for (let i = 0; i < stylesString.length; i++) {
    const char = stylesString.charAt(i);
    if (quoteType === null) {
      switch (char) {
        case ":":
          if (!propertyName) {
            propertyName = stylesString.substr(propertyNameStart, i - propertyNameStart);
            propertyValueStart = i + 1;
          }
          break;
        case '"':
        case "'":
          quoteType = char;
          break;
        case ";": {
          const propertyValue = stylesString.substr(propertyValueStart, i - propertyValueStart);
          if (propertyName) {
            stylesMap.set(propertyName.trim(), propertyValue.trim());
          }
          propertyName = null;
          propertyNameStart = i + 1;
          break;
        }
      }
    } else if (char === quoteType) {
      quoteType = null;
    }
  }
  return stylesMap;
}
function toPath(name) {
  return name.replace("-", ".");
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/element.js
var Element = class _Element extends Node2 {
  /**
   * Creates a view element.
   *
   * Attributes can be passed in various formats:
   *
   * ```ts
   * new Element( viewDocument, 'div', { class: 'editor', contentEditable: 'true' } ); // object
   * new Element( viewDocument, 'div', [ [ 'class', 'editor' ], [ 'contentEditable', 'true' ] ] ); // map-like iterator
   * new Element( viewDocument, 'div', mapOfAttributes ); // map
   * ```
   *
   * @internal
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   */
  constructor(document2, name, attrs, children) {
    super(document2);
    this._unsafeAttributesToRender = [];
    this._customProperties = /* @__PURE__ */ new Map();
    this.name = name;
    this._attrs = parseAttributes(attrs);
    this._children = [];
    if (children) {
      this._insertChild(0, children);
    }
    this._classes = /* @__PURE__ */ new Set();
    if (this._attrs.has("class")) {
      const classString = this._attrs.get("class");
      parseClasses(this._classes, classString);
      this._attrs.delete("class");
    }
    this._styles = new StylesMap(this.document.stylesProcessor);
    if (this._attrs.has("style")) {
      this._styles.setTo(this._attrs.get("style"));
      this._attrs.delete("style");
    }
  }
  /**
   * Number of element's children.
   */
  get childCount() {
    return this._children.length;
  }
  /**
   * Is `true` if there are no nodes inside this element, `false` otherwise.
   */
  get isEmpty() {
    return this._children.length === 0;
  }
  /**
   * Gets child at the given index.
   *
   * @param index Index of child.
   * @returns Child node.
   */
  getChild(index) {
    return this._children[index];
  }
  /**
   * Gets index of the given child node. Returns `-1` if child node is not found.
   *
   * @param node Child node.
   * @returns Index of the child node.
   */
  getChildIndex(node) {
    return this._children.indexOf(node);
  }
  /**
   * Gets child nodes iterator.
   *
   * @returns Child nodes iterator.
   */
  getChildren() {
    return this._children[Symbol.iterator]();
  }
  /**
   * Returns an iterator that contains the keys for attributes. Order of inserting attributes is not preserved.
   *
   * @returns Keys for attributes.
   */
  *getAttributeKeys() {
    if (this._classes.size > 0) {
      yield "class";
    }
    if (!this._styles.isEmpty) {
      yield "style";
    }
    yield* this._attrs.keys();
  }
  /**
   * Returns iterator that iterates over this element's attributes.
   *
   * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
   */
  *getAttributes() {
    yield* this._attrs.entries();
    if (this._classes.size > 0) {
      yield ["class", this.getAttribute("class")];
    }
    if (!this._styles.isEmpty) {
      yield ["style", this.getAttribute("style")];
    }
  }
  /**
   * Gets attribute by key. If attribute is not present - returns undefined.
   *
   * @param key Attribute key.
   * @returns Attribute value.
   */
  getAttribute(key) {
    if (key == "class") {
      if (this._classes.size > 0) {
        return [...this._classes].join(" ");
      }
      return void 0;
    }
    if (key == "style") {
      const inlineStyle = this._styles.toString();
      return inlineStyle == "" ? void 0 : inlineStyle;
    }
    return this._attrs.get(key);
  }
  /**
   * Returns a boolean indicating whether an attribute with the specified key exists in the element.
   *
   * @param key Attribute key.
   * @returns `true` if attribute with the specified key exists in the element, `false` otherwise.
   */
  hasAttribute(key) {
    if (key == "class") {
      return this._classes.size > 0;
    }
    if (key == "style") {
      return !this._styles.isEmpty;
    }
    return this._attrs.has(key);
  }
  /**
   * Checks if this element is similar to other element.
   * Both elements should have the same name and attributes to be considered as similar. Two similar elements
   * can contain different set of children nodes.
   */
  isSimilar(otherElement) {
    if (!(otherElement instanceof _Element)) {
      return false;
    }
    if (this === otherElement) {
      return true;
    }
    if (this.name != otherElement.name) {
      return false;
    }
    if (this._attrs.size !== otherElement._attrs.size || this._classes.size !== otherElement._classes.size || this._styles.size !== otherElement._styles.size) {
      return false;
    }
    for (const [key, value] of this._attrs) {
      if (!otherElement._attrs.has(key) || otherElement._attrs.get(key) !== value) {
        return false;
      }
    }
    for (const className of this._classes) {
      if (!otherElement._classes.has(className)) {
        return false;
      }
    }
    for (const property of this._styles.getStyleNames()) {
      if (!otherElement._styles.has(property) || otherElement._styles.getAsString(property) !== this._styles.getAsString(property)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns true if class is present.
   * If more then one class is provided - returns true only when all classes are present.
   *
   * ```ts
   * element.hasClass( 'foo' ); // Returns true if 'foo' class is present.
   * element.hasClass( 'foo', 'bar' ); // Returns true if 'foo' and 'bar' classes are both present.
   * ```
   */
  hasClass(...className) {
    for (const name of className) {
      if (!this._classes.has(name)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns iterator that contains all class names.
   */
  getClassNames() {
    return this._classes.keys();
  }
  /**
   * Returns style value for the given property mae.
   * If the style does not exist `undefined` is returned.
   *
   * **Note**: This method can work with normalized style names if
   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
   * See {@link module:engine/view/stylesmap~StylesMap#getAsString `StylesMap#getAsString()`} for details.
   *
   * For an element with style set to `'margin:1px'`:
   *
   * ```ts
   * // Enable 'margin' shorthand processing:
   * editor.data.addStyleProcessorRules( addMarginRules );
   *
   * const element = view.change( writer => {
   * 	const element = writer.createElement();
   * 	writer.setStyle( 'margin', '1px' );
   * 	writer.setStyle( 'margin-bottom', '3em' );
   *
   * 	return element;
   * } );
   *
   * element.getStyle( 'margin' ); // -> 'margin: 1px 1px 3em;'
   * ```
   */
  getStyle(property) {
    return this._styles.getAsString(property);
  }
  /**
   * Returns a normalized style object or single style value.
   *
   * For an element with style set to: margin:1px 2px 3em;
   *
   * ```ts
   * element.getNormalizedStyle( 'margin' ) );
   * ```
   *
   * will return:
   *
   * ```ts
   * {
   * 	top: '1px',
   * 	right: '2px',
   * 	bottom: '3em',
   * 	left: '2px'    // a normalized value from margin shorthand
   * }
   * ```
   *
   * and reading for single style value:
   *
   * ```ts
   * styles.getNormalizedStyle( 'margin-left' );
   * ```
   *
   * Will return a `2px` string.
   *
   * **Note**: This method will return normalized values only if
   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
   * See {@link module:engine/view/stylesmap~StylesMap#getNormalized `StylesMap#getNormalized()`} for details.
   *
   * @param property Name of CSS property
   */
  getNormalizedStyle(property) {
    return this._styles.getNormalized(property);
  }
  /**
   * Returns iterator that contains all style names.
   *
   * @param expand Expand shorthand style properties and return all equivalent style representations.
   */
  getStyleNames(expand) {
    return this._styles.getStyleNames(expand);
  }
  /**
   * Returns true if style keys are present.
   * If more then one style property is provided - returns true only when all properties are present.
   *
   * ```ts
   * element.hasStyle( 'color' ); // Returns true if 'border-top' style is present.
   * element.hasStyle( 'color', 'border-top' ); // Returns true if 'color' and 'border-top' styles are both present.
   * ```
   */
  hasStyle(...property) {
    for (const name of property) {
      if (!this._styles.has(name)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns ancestor element that match specified pattern.
   * Provided patterns should be compatible with {@link module:engine/view/matcher~Matcher Matcher} as it is used internally.
   *
   * @see module:engine/view/matcher~Matcher
   * @param patterns Patterns used to match correct ancestor. See {@link module:engine/view/matcher~Matcher}.
   * @returns Found element or `null` if no matching ancestor was found.
   */
  findAncestor(...patterns) {
    const matcher = new Matcher(...patterns);
    let parent = this.parent;
    while (parent && !parent.is("documentFragment")) {
      if (matcher.match(parent)) {
        return parent;
      }
      parent = parent.parent;
    }
    return null;
  }
  /**
   * Returns the custom property value for the given key.
   */
  getCustomProperty(key) {
    return this._customProperties.get(key);
  }
  /**
   * Returns an iterator which iterates over this element's custom properties.
   * Iterator provides `[ key, value ]` pairs for each stored property.
   */
  *getCustomProperties() {
    yield* this._customProperties.entries();
  }
  /**
   * Returns identity string based on element's name, styles, classes and other attributes.
   * Two elements that {@link #isSimilar are similar} will have same identity string.
   * It has the following format:
   *
   * ```ts
   * 'name class="class1,class2" style="style1:value1;style2:value2" attr1="val1" attr2="val2"'
   * ```
   *
   * For example:
   *
   * ```ts
   * const element = writer.createContainerElement( 'foo', {
   * 	banana: '10',
   * 	apple: '20',
   * 	style: 'color: red; border-color: white;',
   * 	class: 'baz'
   * } );
   *
   * // returns 'foo class="baz" style="border-color:white;color:red" apple="20" banana="10"'
   * element.getIdentity();
   * ```
   *
   * **Note**: Classes, styles and other attributes are sorted alphabetically.
   */
  getIdentity() {
    const classes = Array.from(this._classes).sort().join(",");
    const styles = this._styles.toString();
    const attributes = Array.from(this._attrs).map((i) => `${i[0]}="${i[1]}"`).sort().join(" ");
    return this.name + (classes == "" ? "" : ` class="${classes}"`) + (!styles ? "" : ` style="${styles}"`) + (attributes == "" ? "" : ` ${attributes}`);
  }
  /**
   * Decides whether an unsafe attribute is whitelisted and should be rendered in the editing pipeline even though filtering mechanisms
   * like {@link module:engine/view/domconverter~DomConverter#shouldRenderAttribute} say it should not.
   *
   * Unsafe attribute names can be specified when creating an element via {@link module:engine/view/downcastwriter~DowncastWriter}.
   *
   * @param attributeName The name of the attribute to be checked.
   */
  shouldRenderUnsafeAttribute(attributeName) {
    return this._unsafeAttributesToRender.includes(attributeName);
  }
  /**
   * Clones provided element.
   *
   * @internal
   * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
   * element will be cloned without any children.
   * @returns Clone of this element.
   */
  _clone(deep = false) {
    const childrenClone = [];
    if (deep) {
      for (const child of this.getChildren()) {
        childrenClone.push(child._clone(deep));
      }
    }
    const cloned = new this.constructor(this.document, this.name, this._attrs, childrenClone);
    cloned._classes = new Set(this._classes);
    cloned._styles.set(this._styles.getNormalized());
    cloned._customProperties = new Map(this._customProperties);
    cloned.getFillerOffset = this.getFillerOffset;
    cloned._unsafeAttributesToRender = this._unsafeAttributesToRender;
    return cloned;
  }
  /**
   * {@link module:engine/view/element~Element#_insertChild Insert} a child node or a list of child nodes at the end of this node
   * and sets the parent of these nodes to this element.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#insert
   * @internal
   * @param items Items to be inserted.
   * @fires change
   * @returns Number of appended nodes.
   */
  _appendChild(items) {
    return this._insertChild(this.childCount, items);
  }
  /**
   * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
   * this element.
   *
   * @internal
   * @see module:engine/view/downcastwriter~DowncastWriter#insert
   * @param index Position where nodes should be inserted.
   * @param items Items to be inserted.
   * @fires change
   * @returns Number of inserted nodes.
   */
  _insertChild(index, items) {
    this._fireChange("children", this);
    let count2 = 0;
    const nodes = normalize2(this.document, items);
    for (const node of nodes) {
      if (node.parent !== null) {
        node._remove();
      }
      node.parent = this;
      node.document = this.document;
      this._children.splice(index, 0, node);
      index++;
      count2++;
    }
    return count2;
  }
  /**
   * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#remove
   * @internal
   * @param index Number of the first node to remove.
   * @param howMany Number of nodes to remove.
   * @fires change
   * @returns The array of removed nodes.
   */
  _removeChildren(index, howMany = 1) {
    this._fireChange("children", this);
    for (let i = index; i < index + howMany; i++) {
      this._children[i].parent = null;
    }
    return this._children.splice(index, howMany);
  }
  /**
   * Adds or overwrite attribute with a specified key and value.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#setAttribute
   * @internal
   * @param key Attribute key.
   * @param value Attribute value.
   * @fires change
   */
  _setAttribute(key, value) {
    const stringValue = String(value);
    this._fireChange("attributes", this);
    if (key == "class") {
      parseClasses(this._classes, stringValue);
    } else if (key == "style") {
      this._styles.setTo(stringValue);
    } else {
      this._attrs.set(key, stringValue);
    }
  }
  /**
   * Removes attribute from the element.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#removeAttribute
   * @internal
   * @param key Attribute key.
   * @returns Returns true if an attribute existed and has been removed.
   * @fires change
   */
  _removeAttribute(key) {
    this._fireChange("attributes", this);
    if (key == "class") {
      if (this._classes.size > 0) {
        this._classes.clear();
        return true;
      }
      return false;
    }
    if (key == "style") {
      if (!this._styles.isEmpty) {
        this._styles.clear();
        return true;
      }
      return false;
    }
    return this._attrs.delete(key);
  }
  /**
   * Adds specified class.
   *
   * ```ts
   * element._addClass( 'foo' ); // Adds 'foo' class.
   * element._addClass( [ 'foo', 'bar' ] ); // Adds 'foo' and 'bar' classes.
   * ```
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#addClass
   * @internal
   * @fires change
   */
  _addClass(className) {
    this._fireChange("attributes", this);
    for (const name of toArray(className)) {
      this._classes.add(name);
    }
  }
  /**
   * Removes specified class.
   *
   * ```ts
   * element._removeClass( 'foo' );  // Removes 'foo' class.
   * element._removeClass( [ 'foo', 'bar' ] ); // Removes both 'foo' and 'bar' classes.
   * ```
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#removeClass
   * @internal
   * @fires change
   */
  _removeClass(className) {
    this._fireChange("attributes", this);
    for (const name of toArray(className)) {
      this._classes.delete(name);
    }
  }
  _setStyle(property, value) {
    this._fireChange("attributes", this);
    if (typeof property != "string") {
      this._styles.set(property);
    } else {
      this._styles.set(property, value);
    }
  }
  /**
   * Removes specified style.
   *
   * ```ts
   * element._removeStyle( 'color' );  // Removes 'color' style.
   * element._removeStyle( [ 'color', 'border-top' ] ); // Removes both 'color' and 'border-top' styles.
   * ```
   *
   * **Note**: This method can work with normalized style names if
   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
   * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#removeStyle
   * @internal
   * @fires change
   */
  _removeStyle(property) {
    this._fireChange("attributes", this);
    for (const name of toArray(property)) {
      this._styles.remove(name);
    }
  }
  /**
   * Sets a custom property. Unlike attributes, custom properties are not rendered to the DOM,
   * so they can be used to add special data to elements.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#setCustomProperty
   * @internal
   */
  _setCustomProperty(key, value) {
    this._customProperties.set(key, value);
  }
  /**
   * Removes the custom property stored under the given key.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#removeCustomProperty
   * @internal
   * @returns Returns true if property was removed.
   */
  _removeCustomProperty(key) {
    return this._customProperties.delete(key);
  }
};
Element.prototype.is = function(type, name) {
  if (!name) {
    return type === "element" || type === "view:element" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "element" || type === "view:element");
  }
};
function parseAttributes(attrs) {
  const attrsMap = toMap(attrs);
  for (const [key, value] of attrsMap) {
    if (value === null) {
      attrsMap.delete(key);
    } else if (typeof value != "string") {
      attrsMap.set(key, String(value));
    }
  }
  return attrsMap;
}
function parseClasses(classesSet, classesString) {
  const classArray = classesString.split(/\s+/);
  classesSet.clear();
  classArray.forEach((name) => classesSet.add(name));
}
function normalize2(document2, nodes) {
  if (typeof nodes == "string") {
    return [new Text(document2, nodes)];
  }
  if (!isIterable(nodes)) {
    nodes = [nodes];
  }
  return Array.from(nodes).map((node) => {
    if (typeof node == "string") {
      return new Text(document2, node);
    }
    if (node instanceof TextProxy) {
      return new Text(document2, node.data);
    }
    return node;
  });
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/uielement.js
var UIElement = class extends Element {
  /**
   * Creates new instance of UIElement.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` when third parameter is passed,
   * to inform that usage of UIElement is incorrect (adding child nodes to UIElement is forbidden).
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createUIElement
   * @internal
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   */
  constructor(document2, name, attrs, children) {
    super(document2, name, attrs, children);
    this.getFillerOffset = getFillerOffset;
  }
  /**
   * Overrides {@link module:engine/view/element~Element#_insertChild} method.
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` to prevent adding any child nodes
   * to UIElement.
   *
   * @internal
   */
  _insertChild(index, items) {
    if (items && (items instanceof Node2 || Array.from(items).length > 0)) {
      throw new CKEditorError("view-uielement-cannot-add", [this, items]);
    }
    return 0;
  }
  /**
   * Renders this {@link module:engine/view/uielement~UIElement} to DOM. This method is called by
   * {@link module:engine/view/domconverter~DomConverter}.
   * Do not use inheritance to create custom rendering method, replace `render()` method instead:
   *
   * ```ts
   * const myUIElement = downcastWriter.createUIElement( 'span' );
   * myUIElement.render = function( domDocument, domConverter ) {
   * 	const domElement = this.toDomElement( domDocument );
   *
   * 	domConverter.setContentOf( domElement, '<b>this is ui element</b>' );
   *
   * 	return domElement;
   * };
   * ```
   *
   * If changes in your UI element should trigger some editor UI update you should call
   * the {@link module:ui/editorui/editorui~EditorUI#update `editor.ui.update()`} method
   * after rendering your UI element.
   *
   * @param domConverter Instance of the DomConverter used to optimize the output.
   */
  render(domDocument, domConverter) {
    return this.toDomElement(domDocument);
  }
  /**
   * Creates DOM element based on this view UIElement.
   * Note that each time this method is called new DOM element is created.
   */
  toDomElement(domDocument) {
    const domElement = domDocument.createElement(this.name);
    for (const key of this.getAttributeKeys()) {
      domElement.setAttribute(key, this.getAttribute(key));
    }
    return domElement;
  }
};
UIElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "uiElement" || type === "view:uiElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "element" || type === "view:element" || type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "uiElement" || type === "view:uiElement" || type === "element" || type === "view:element");
  }
};
function getFillerOffset() {
  return null;
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/containerelement.js
var ContainerElement = class extends Element {
  /**
   * Creates a container element.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createContainerElement
   * @see module:engine/view/element~Element
   * @internal
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   */
  constructor(document2, name, attrs, children) {
    super(document2, name, attrs, children);
    this.getFillerOffset = getFillerOffset2;
  }
};
ContainerElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "containerElement" || type === "view:containerElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "element" || type === "view:element" || type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "containerElement" || type === "view:containerElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "element" || type === "view:element");
  }
};
function getFillerOffset2() {
  const children = [...this.getChildren()];
  const lastChild = children[this.childCount - 1];
  if (lastChild && lastChild.is("element", "br")) {
    return this.childCount;
  }
  for (const child of children) {
    if (!child.is("uiElement")) {
      return null;
    }
  }
  return this.childCount;
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/editableelement.js
var EditableElement = class extends ObservableMixin(ContainerElement) {
  /**
   * Creates an editable element.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createEditableElement
   * @internal
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   */
  constructor(document2, name, attributes, children) {
    super(document2, name, attributes, children);
    this.set("isReadOnly", false);
    this.set("isFocused", false);
    this.set("placeholder", void 0);
    this.bind("isReadOnly").to(document2);
    this.bind("isFocused").to(document2, "isFocused", (isFocused) => isFocused && document2.selection.editableElement == this);
    this.listenTo(document2.selection, "change", () => {
      this.isFocused = document2.isFocused && document2.selection.editableElement == this;
    });
  }
  destroy() {
    this.stopListening();
  }
};
EditableElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "editableElement" || type === "view:editableElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "containerElement" || type === "view:containerElement" || type === "element" || type === "view:element" || type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "editableElement" || type === "view:editableElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "containerElement" || type === "view:containerElement" || type === "element" || type === "view:element");
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/treewalker.js
var TreeWalker = class {
  /**
   * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.
   *
   * @param options Object with configuration.
   */
  constructor(options = {}) {
    if (!options.boundaries && !options.startPosition) {
      throw new CKEditorError("view-tree-walker-no-start-position", null);
    }
    if (options.direction && options.direction != "forward" && options.direction != "backward") {
      throw new CKEditorError("view-tree-walker-unknown-direction", options.startPosition, { direction: options.direction });
    }
    this.boundaries = options.boundaries || null;
    if (options.startPosition) {
      this._position = Position._createAt(options.startPosition);
    } else {
      this._position = Position._createAt(options.boundaries[options.direction == "backward" ? "end" : "start"]);
    }
    this.direction = options.direction || "forward";
    this.singleCharacters = !!options.singleCharacters;
    this.shallow = !!options.shallow;
    this.ignoreElementEnd = !!options.ignoreElementEnd;
    this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;
    this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
  }
  /**
   * Iterable interface.
   */
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Iterator position. If start position is not defined then position depends on {@link #direction}. If direction is
   * `'forward'` position starts form the beginning, when direction is `'backward'` position starts from the end.
   */
  get position() {
    return this._position;
  }
  /**
   * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.
   *
   * For example:
   *
   * ```ts
   * walker.skip( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>
   * walker.skip( value => true ); // Move the position to the end: <p>{}foo</p> -> <p>foo</p>[]
   * walker.skip( value => false ); // Do not move the position.
   * ```
   *
   * @param skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should
   * return `true` if the value should be skipped or `false` if not.
   */
  skip(skip) {
    let nextResult;
    let prevPosition;
    do {
      prevPosition = this.position;
      nextResult = this.next();
    } while (!nextResult.done && skip(nextResult.value));
    if (!nextResult.done) {
      this._position = prevPosition;
    }
  }
  /**
   * Gets the next tree walker's value.
   *
   * @returns Object implementing iterator interface, returning
   * information about taken step.
   */
  next() {
    if (this.direction == "forward") {
      return this._next();
    } else {
      return this._previous();
    }
  }
  /**
   * Makes a step forward in view. Moves the {@link #position} to the next position and returns the encountered value.
   */
  _next() {
    let position = this.position.clone();
    const previousPosition = this.position;
    const parent = position.parent;
    if (parent.parent === null && position.offset === parent.childCount) {
      return { done: true, value: void 0 };
    }
    if (parent === this._boundaryEndParent && position.offset == this.boundaries.end.offset) {
      return { done: true, value: void 0 };
    }
    let node;
    if (parent instanceof Text) {
      if (position.isAtEnd) {
        this._position = Position._createAfter(parent);
        return this._next();
      }
      node = parent.data[position.offset];
    } else {
      node = parent.getChild(position.offset);
    }
    if (node instanceof Element) {
      if (!this.shallow) {
        position = new Position(node, 0);
      } else {
        if (this.boundaries && this.boundaries.end.isBefore(position)) {
          return { done: true, value: void 0 };
        }
        position.offset++;
      }
      this._position = position;
      return this._formatReturnValue("elementStart", node, previousPosition, position, 1);
    }
    if (node instanceof Text) {
      if (this.singleCharacters) {
        position = new Position(node, 0);
        this._position = position;
        return this._next();
      }
      let charactersCount = node.data.length;
      let item;
      if (node == this._boundaryEndParent) {
        charactersCount = this.boundaries.end.offset;
        item = new TextProxy(node, 0, charactersCount);
        position = Position._createAfter(item);
      } else {
        item = new TextProxy(node, 0, node.data.length);
        position.offset++;
      }
      this._position = position;
      return this._formatReturnValue("text", item, previousPosition, position, charactersCount);
    }
    if (typeof node == "string") {
      let textLength;
      if (this.singleCharacters) {
        textLength = 1;
      } else {
        const endOffset = parent === this._boundaryEndParent ? this.boundaries.end.offset : parent.data.length;
        textLength = endOffset - position.offset;
      }
      const textProxy = new TextProxy(parent, position.offset, textLength);
      position.offset += textLength;
      this._position = position;
      return this._formatReturnValue("text", textProxy, previousPosition, position, textLength);
    }
    position = Position._createAfter(parent);
    this._position = position;
    if (this.ignoreElementEnd) {
      return this._next();
    }
    return this._formatReturnValue("elementEnd", parent, previousPosition, position);
  }
  /**
   * Makes a step backward in view. Moves the {@link #position} to the previous position and returns the encountered value.
   */
  _previous() {
    let position = this.position.clone();
    const previousPosition = this.position;
    const parent = position.parent;
    if (parent.parent === null && position.offset === 0) {
      return { done: true, value: void 0 };
    }
    if (parent == this._boundaryStartParent && position.offset == this.boundaries.start.offset) {
      return { done: true, value: void 0 };
    }
    let node;
    if (parent instanceof Text) {
      if (position.isAtStart) {
        this._position = Position._createBefore(parent);
        return this._previous();
      }
      node = parent.data[position.offset - 1];
    } else {
      node = parent.getChild(position.offset - 1);
    }
    if (node instanceof Element) {
      if (this.shallow) {
        position.offset--;
        this._position = position;
        return this._formatReturnValue("elementStart", node, previousPosition, position, 1);
      }
      position = new Position(node, node.childCount);
      this._position = position;
      if (this.ignoreElementEnd) {
        return this._previous();
      }
      return this._formatReturnValue("elementEnd", node, previousPosition, position);
    }
    if (node instanceof Text) {
      if (this.singleCharacters) {
        position = new Position(node, node.data.length);
        this._position = position;
        return this._previous();
      }
      let charactersCount = node.data.length;
      let item;
      if (node == this._boundaryStartParent) {
        const offset = this.boundaries.start.offset;
        item = new TextProxy(node, offset, node.data.length - offset);
        charactersCount = item.data.length;
        position = Position._createBefore(item);
      } else {
        item = new TextProxy(node, 0, node.data.length);
        position.offset--;
      }
      this._position = position;
      return this._formatReturnValue("text", item, previousPosition, position, charactersCount);
    }
    if (typeof node == "string") {
      let textLength;
      if (!this.singleCharacters) {
        const startOffset = parent === this._boundaryStartParent ? this.boundaries.start.offset : 0;
        textLength = position.offset - startOffset;
      } else {
        textLength = 1;
      }
      position.offset -= textLength;
      const textProxy = new TextProxy(parent, position.offset, textLength);
      this._position = position;
      return this._formatReturnValue("text", textProxy, previousPosition, position, textLength);
    }
    position = Position._createBefore(parent);
    this._position = position;
    return this._formatReturnValue("elementStart", parent, previousPosition, position, 1);
  }
  /**
   * Format returned data and adjust `previousPosition` and `nextPosition` if reach the bound of the {@link module:engine/view/text~Text}.
   *
   * @param type Type of step.
   * @param item Item between old and new position.
   * @param previousPosition Previous position of iterator.
   * @param nextPosition Next position of iterator.
   * @param length Length of the item.
   */
  _formatReturnValue(type, item, previousPosition, nextPosition, length) {
    if (item instanceof TextProxy) {
      if (item.offsetInText + item.data.length == item.textNode.data.length) {
        if (this.direction == "forward" && !(this.boundaries && this.boundaries.end.isEqual(this.position))) {
          nextPosition = Position._createAfter(item.textNode);
          this._position = nextPosition;
        } else {
          previousPosition = Position._createAfter(item.textNode);
        }
      }
      if (item.offsetInText === 0) {
        if (this.direction == "backward" && !(this.boundaries && this.boundaries.start.isEqual(this.position))) {
          nextPosition = Position._createBefore(item.textNode);
          this._position = nextPosition;
        } else {
          previousPosition = Position._createBefore(item.textNode);
        }
      }
    }
    return {
      done: false,
      value: {
        type,
        item,
        previousPosition,
        nextPosition,
        length
      }
    };
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/position.js
var Position = class _Position extends TypeCheckable {
  /**
   * Creates a position.
   *
   * @param parent Position parent.
   * @param offset Position offset.
   */
  constructor(parent, offset) {
    super();
    this.parent = parent;
    this.offset = offset;
  }
  /**
   * Node directly after the position. Equals `null` when there is no node after position or position is located
   * inside text node.
   */
  get nodeAfter() {
    if (this.parent.is("$text")) {
      return null;
    }
    return this.parent.getChild(this.offset) || null;
  }
  /**
   * Node directly before the position. Equals `null` when there is no node before position or position is located
   * inside text node.
   */
  get nodeBefore() {
    if (this.parent.is("$text")) {
      return null;
    }
    return this.parent.getChild(this.offset - 1) || null;
  }
  /**
   * Is `true` if position is at the beginning of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.
   */
  get isAtStart() {
    return this.offset === 0;
  }
  /**
   * Is `true` if position is at the end of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.
   */
  get isAtEnd() {
    const endOffset = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount;
    return this.offset === endOffset;
  }
  /**
   * Position's root, that is the root of the position's parent element.
   */
  get root() {
    return this.parent.root;
  }
  /**
   * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this position, or `null` if
   * position is not inside an editable element.
   */
  get editableElement() {
    let editable = this.parent;
    while (!(editable instanceof EditableElement)) {
      if (editable.parent) {
        editable = editable.parent;
      } else {
        return null;
      }
    }
    return editable;
  }
  /**
   * Returns a new instance of Position with offset incremented by `shift` value.
   *
   * @param shift How position offset should get changed. Accepts negative values.
   * @returns Shifted position.
   */
  getShiftedBy(shift) {
    const shifted = _Position._createAt(this);
    const offset = shifted.offset + shift;
    shifted.offset = offset < 0 ? 0 : offset;
    return shifted;
  }
  /**
   * Gets the farthest position which matches the callback using
   * {@link module:engine/view/treewalker~TreeWalker TreeWalker}.
   *
   * For example:
   *
   * ```ts
   * getLastMatchingPosition( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>
   * getLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } ); // <p>foo[]</p> -> <p>{}foo</p>
   * getLastMatchingPosition( value => false ); // Do not move the position.
   * ```
   *
   * @param skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should
   * return `true` if the value should be skipped or `false` if not.
   * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
   * @returns The position after the last item which matches the `skip` callback test.
   */
  getLastMatchingPosition(skip, options = {}) {
    options.startPosition = this;
    const treeWalker = new TreeWalker(options);
    treeWalker.skip(skip);
    return treeWalker.position;
  }
  /**
   * Returns ancestors array of this position, that is this position's parent and it's ancestors.
   *
   * @returns Array with ancestors.
   */
  getAncestors() {
    if (this.parent.is("documentFragment")) {
      return [this.parent];
    } else {
      return this.parent.getAncestors({ includeSelf: true });
    }
  }
  /**
   * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}
   * which is a common ancestor of both positions.
   */
  getCommonAncestor(position) {
    const ancestorsA = this.getAncestors();
    const ancestorsB = position.getAncestors();
    let i = 0;
    while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {
      i++;
    }
    return i === 0 ? null : ancestorsA[i - 1];
  }
  /**
   * Checks whether this position equals given position.
   *
   * @param otherPosition Position to compare with.
   * @returns True if positions are same.
   */
  isEqual(otherPosition) {
    return this.parent == otherPosition.parent && this.offset == otherPosition.offset;
  }
  /**
   * Checks whether this position is located before given position. When method returns `false` it does not mean that
   * this position is after give one. Two positions may be located inside separate roots and in that situation this
   * method will still return `false`.
   *
   * @see module:engine/view/position~Position#isAfter
   * @see module:engine/view/position~Position#compareWith
   * @param otherPosition Position to compare with.
   * @returns Returns `true` if this position is before given position.
   */
  isBefore(otherPosition) {
    return this.compareWith(otherPosition) == "before";
  }
  /**
   * Checks whether this position is located after given position. When method returns `false` it does not mean that
   * this position is before give one. Two positions may be located inside separate roots and in that situation this
   * method will still return `false`.
   *
   * @see module:engine/view/position~Position#isBefore
   * @see module:engine/view/position~Position#compareWith
   * @param otherPosition Position to compare with.
   * @returns Returns `true` if this position is after given position.
   */
  isAfter(otherPosition) {
    return this.compareWith(otherPosition) == "after";
  }
  /**
   * Checks whether this position is before, after or in same position that other position. Two positions may be also
   * different when they are located in separate roots.
   *
   * @param otherPosition Position to compare with.
   */
  compareWith(otherPosition) {
    if (this.root !== otherPosition.root) {
      return "different";
    }
    if (this.isEqual(otherPosition)) {
      return "same";
    }
    const thisPath = this.parent.is("node") ? this.parent.getPath() : [];
    const otherPath = otherPosition.parent.is("node") ? otherPosition.parent.getPath() : [];
    thisPath.push(this.offset);
    otherPath.push(otherPosition.offset);
    const result = compareArrays(thisPath, otherPath);
    switch (result) {
      case "prefix":
        return "before";
      case "extension":
        return "after";
      default:
        return thisPath[result] < otherPath[result] ? "before" : "after";
    }
  }
  /**
   * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this positions as a start position.
   *
   * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}
   */
  getWalker(options = {}) {
    options.startPosition = this;
    return new TreeWalker(options);
  }
  /**
   * Clones this position.
   */
  clone() {
    return new _Position(this.parent, this.offset);
  }
  /**
   * Creates position at the given location. The location can be specified as:
   *
   * * a {@link module:engine/view/position~Position position},
   * * parent element and offset (offset defaults to `0`),
   * * parent element and `'end'` (sets position at the end of that element),
   * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
   *
   * This method is a shortcut to other constructors such as:
   *
   * * {@link module:engine/view/position~Position._createBefore},
   * * {@link module:engine/view/position~Position._createAfter}.
   *
   * @internal
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
   */
  static _createAt(itemOrPosition, offset) {
    if (itemOrPosition instanceof _Position) {
      return new this(itemOrPosition.parent, itemOrPosition.offset);
    } else {
      const node = itemOrPosition;
      if (offset == "end") {
        offset = node.is("$text") ? node.data.length : node.childCount;
      } else if (offset == "before") {
        return this._createBefore(node);
      } else if (offset == "after") {
        return this._createAfter(node);
      } else if (offset !== 0 && !offset) {
        throw new CKEditorError("view-createpositionat-offset-required", node);
      }
      return new _Position(node, offset);
    }
  }
  /**
   * Creates a new position after given view item.
   *
   * @internal
   * @param item View item after which the position should be located.
   */
  static _createAfter(item) {
    if (item.is("$textProxy")) {
      return new _Position(item.textNode, item.offsetInText + item.data.length);
    }
    if (!item.parent) {
      throw new CKEditorError("view-position-after-root", item, { root: item });
    }
    return new _Position(item.parent, item.index + 1);
  }
  /**
   * Creates a new position before given view item.
   *
   * @internal
   * @param item View item before which the position should be located.
   */
  static _createBefore(item) {
    if (item.is("$textProxy")) {
      return new _Position(item.textNode, item.offsetInText);
    }
    if (!item.parent) {
      throw new CKEditorError("view-position-before-root", item, { root: item });
    }
    return new _Position(item.parent, item.index);
  }
};
Position.prototype.is = function(type) {
  return type === "position" || type === "view:position";
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/range.js
var Range = class _Range extends TypeCheckable {
  /**
   * Creates a range spanning from `start` position to `end` position.
   *
   * **Note:** Constructor creates it's own {@link module:engine/view/position~Position} instances basing on passed values.
   *
   * @param start Start position.
   * @param end End position. If not set, range will be collapsed at the `start` position.
   */
  constructor(start, end = null) {
    super();
    this.start = start.clone();
    this.end = end ? end.clone() : start.clone();
  }
  /**
   * Iterable interface.
   *
   * Iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns
   * them together with additional information like length or {@link module:engine/view/position~Position positions},
   * grouped as {@link module:engine/view/treewalker~TreeWalkerValue}.
   *
   * This iterator uses {@link module:engine/view/treewalker~TreeWalker TreeWalker} with `boundaries` set to this range and
   * `ignoreElementEnd` option
   * set to `true`.
   */
  *[Symbol.iterator]() {
    yield* new TreeWalker({ boundaries: this, ignoreElementEnd: true });
  }
  /**
   * Returns whether the range is collapsed, that is it start and end positions are equal.
   */
  get isCollapsed() {
    return this.start.isEqual(this.end);
  }
  /**
   * Returns whether this range is flat, that is if {@link module:engine/view/range~Range#start start} position and
   * {@link module:engine/view/range~Range#end end} position are in the same {@link module:engine/view/position~Position#parent parent}.
   */
  get isFlat() {
    return this.start.parent === this.end.parent;
  }
  /**
   * Range root element.
   */
  get root() {
    return this.start.root;
  }
  /**
   * Creates a maximal range that has the same content as this range but is expanded in both ways (at the beginning
   * and at the end).
   *
   * For example:
   *
   * ```html
   * <p>Foo</p><p><b>{Bar}</b></p> -> <p>Foo</p>[<p><b>Bar</b>]</p>
   * <p><b>foo</b>{bar}<span></span></p> -> <p><b>foo[</b>bar<span></span>]</p>
   * ```
   *
   * Note that in the sample above:
   *
   * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},
   * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},
   * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.
   *
   * @returns Enlarged range.
   */
  getEnlarged() {
    let start = this.start.getLastMatchingPosition(enlargeTrimSkip, { direction: "backward" });
    let end = this.end.getLastMatchingPosition(enlargeTrimSkip);
    if (start.parent.is("$text") && start.isAtStart) {
      start = Position._createBefore(start.parent);
    }
    if (end.parent.is("$text") && end.isAtEnd) {
      end = Position._createAfter(end.parent);
    }
    return new _Range(start, end);
  }
  /**
   * Creates a minimum range that has the same content as this range but is trimmed in both ways (at the beginning
   * and at the end).
   *
   * For example:
   *
   * ```html
   * <p>Foo</p>[<p><b>Bar</b>]</p> -> <p>Foo</p><p><b>{Bar}</b></p>
   * <p><b>foo[</b>bar<span></span>]</p> -> <p><b>foo</b>{bar}<span></span></p>
   * ```
   *
   * Note that in the sample above:
   *
   * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},
   * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},
   * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.
   *
   * @returns Shrunk range.
   */
  getTrimmed() {
    let start = this.start.getLastMatchingPosition(enlargeTrimSkip);
    if (start.isAfter(this.end) || start.isEqual(this.end)) {
      return new _Range(start, start);
    }
    let end = this.end.getLastMatchingPosition(enlargeTrimSkip, { direction: "backward" });
    const nodeAfterStart = start.nodeAfter;
    const nodeBeforeEnd = end.nodeBefore;
    if (nodeAfterStart && nodeAfterStart.is("$text")) {
      start = new Position(nodeAfterStart, 0);
    }
    if (nodeBeforeEnd && nodeBeforeEnd.is("$text")) {
      end = new Position(nodeBeforeEnd, nodeBeforeEnd.data.length);
    }
    return new _Range(start, end);
  }
  /**
   * Two ranges are equal if their start and end positions are equal.
   *
   * @param otherRange Range to compare with.
   * @returns `true` if ranges are equal, `false` otherwise
   */
  isEqual(otherRange) {
    return this == otherRange || this.start.isEqual(otherRange.start) && this.end.isEqual(otherRange.end);
  }
  /**
   * Checks whether this range contains given {@link module:engine/view/position~Position position}.
   *
   * @param position Position to check.
   * @returns `true` if given {@link module:engine/view/position~Position position} is contained in this range, `false` otherwise.
   */
  containsPosition(position) {
    return position.isAfter(this.start) && position.isBefore(this.end);
  }
  /**
   * Checks whether this range contains given {@link module:engine/view/range~Range range}.
   *
   * @param otherRange Range to check.
   * @param loose Whether the check is loose or strict. If the check is strict (`false`), compared range cannot
   * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or
   * even be equal to this range. Note that collapsed ranges are always compared in strict mode.
   * @returns `true` if given {@link module:engine/view/range~Range range} boundaries are contained by this range, `false`
   * otherwise.
   */
  containsRange(otherRange, loose = false) {
    if (otherRange.isCollapsed) {
      loose = false;
    }
    const containsStart = this.containsPosition(otherRange.start) || loose && this.start.isEqual(otherRange.start);
    const containsEnd = this.containsPosition(otherRange.end) || loose && this.end.isEqual(otherRange.end);
    return containsStart && containsEnd;
  }
  /**
   * Computes which part(s) of this {@link module:engine/view/range~Range range} is not a part of given
   * {@link module:engine/view/range~Range range}.
   * Returned array contains zero, one or two {@link module:engine/view/range~Range ranges}.
   *
   * Examples:
   *
   * ```ts
   * let foo = downcastWriter.createText( 'foo' );
   * let img = downcastWriter.createContainerElement( 'img' );
   * let bar = downcastWriter.createText( 'bar' );
   * let p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );
   *
   * let range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // "o", img, "b" are in range.
   * let otherRange = view.createRange( // "oo", img, "ba" are in range.
   * 	view.createPositionAt( foo, 1 ),
   * 	view.createPositionAt( bar, 2 )
   * );
   * let transformed = range.getDifference( otherRange );
   * // transformed array has no ranges because `otherRange` contains `range`
   *
   * otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // "oo", img are in range.
   * transformed = range.getDifference( otherRange );
   * // transformed array has one range: from ( p, 2 ) to ( bar, 1 )
   *
   * otherRange = view.createRange( view.createPositionAt( p, 1 ), view.createPositionAt( p, 2 ) ); // img is in range.
   * transformed = range.getDifference( otherRange );
   * // transformed array has two ranges: from ( foo, 1 ) to ( p, 1 ) and from ( p, 2 ) to ( bar, 1 )
   * ```
   *
   * @param otherRange Range to differentiate against.
   * @returns The difference between ranges.
   */
  getDifference(otherRange) {
    const ranges = [];
    if (this.isIntersecting(otherRange)) {
      if (this.containsPosition(otherRange.start)) {
        ranges.push(new _Range(this.start, otherRange.start));
      }
      if (this.containsPosition(otherRange.end)) {
        ranges.push(new _Range(otherRange.end, this.end));
      }
    } else {
      ranges.push(this.clone());
    }
    return ranges;
  }
  /**
   * Returns an intersection of this {@link module:engine/view/range~Range range} and given {@link module:engine/view/range~Range range}.
   * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.
   *
   * Examples:
   *
   * ```ts
   * let foo = downcastWriter.createText( 'foo' );
   * let img = downcastWriter.createContainerElement( 'img' );
   * let bar = downcastWriter.createText( 'bar' );
   * let p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );
   *
   * let range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // "o", img, "b" are in range.
   * let otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // "oo", img are in range.
   * let transformed = range.getIntersection( otherRange ); // range from ( foo, 1 ) to ( p, 2 ).
   *
   * otherRange = view.createRange( view.createPositionAt( bar, 1 ), view.createPositionAt( bar, 3 ); "ar" is in range.
   * transformed = range.getIntersection( otherRange ); // null - no common part.
   * ```
   *
   * @param otherRange Range to check for intersection.
   * @returns A common part of given ranges or `null` if ranges have no common part.
   */
  getIntersection(otherRange) {
    if (this.isIntersecting(otherRange)) {
      let commonRangeStart = this.start;
      let commonRangeEnd = this.end;
      if (this.containsPosition(otherRange.start)) {
        commonRangeStart = otherRange.start;
      }
      if (this.containsPosition(otherRange.end)) {
        commonRangeEnd = otherRange.end;
      }
      return new _Range(commonRangeStart, commonRangeEnd);
    }
    return null;
  }
  /**
   * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.
   *
   * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
   */
  getWalker(options = {}) {
    options.boundaries = this;
    return new TreeWalker(options);
  }
  /**
   * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}
   * which is a common ancestor of range's both ends (in which the entire range is contained).
   */
  getCommonAncestor() {
    return this.start.getCommonAncestor(this.end);
  }
  /**
   * Returns an {@link module:engine/view/element~Element Element} contained by the range.
   * The element will be returned when it is the **only** node within the range and **fully–contained**
   * at the same time.
   */
  getContainedElement() {
    if (this.isCollapsed) {
      return null;
    }
    let nodeAfterStart = this.start.nodeAfter;
    let nodeBeforeEnd = this.end.nodeBefore;
    if (this.start.parent.is("$text") && this.start.isAtEnd && this.start.parent.nextSibling) {
      nodeAfterStart = this.start.parent.nextSibling;
    }
    if (this.end.parent.is("$text") && this.end.isAtStart && this.end.parent.previousSibling) {
      nodeBeforeEnd = this.end.parent.previousSibling;
    }
    if (nodeAfterStart && nodeAfterStart.is("element") && nodeAfterStart === nodeBeforeEnd) {
      return nodeAfterStart;
    }
    return null;
  }
  /**
   * Clones this range.
   */
  clone() {
    return new _Range(this.start, this.end);
  }
  /**
   * Returns an iterator that iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns
   * them.
   *
   * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option
   * set to `true`. However it returns only {@link module:engine/view/item~Item items},
   * not {@link module:engine/view/treewalker~TreeWalkerValue}.
   *
   * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for
   * a full list of available options.
   *
   * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
   */
  *getItems(options = {}) {
    options.boundaries = this;
    options.ignoreElementEnd = true;
    const treeWalker = new TreeWalker(options);
    for (const value of treeWalker) {
      yield value.item;
    }
  }
  /**
   * Returns an iterator that iterates over all {@link module:engine/view/position~Position positions} that are boundaries or
   * contained in this range.
   *
   * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only
   * {@link module:engine/view/position~Position positions}, not {@link module:engine/view/treewalker~TreeWalkerValue}.
   *
   * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for
   * a full list of available options.
   *
   * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
   */
  *getPositions(options = {}) {
    options.boundaries = this;
    const treeWalker = new TreeWalker(options);
    yield treeWalker.position;
    for (const value of treeWalker) {
      yield value.nextPosition;
    }
  }
  /**
   * Checks and returns whether this range intersects with the given range.
   *
   * @param otherRange Range to compare with.
   * @returns True if ranges intersect.
   */
  isIntersecting(otherRange) {
    return this.start.isBefore(otherRange.end) && this.end.isAfter(otherRange.start);
  }
  /**
   * Creates a range from the given parents and offsets.
   *
   * @internal
   * @param startElement Start position parent element.
   * @param startOffset Start position offset.
   * @param endElement End position parent element.
   * @param endOffset End position offset.
   * @returns Created range.
   */
  static _createFromParentsAndOffsets(startElement, startOffset, endElement, endOffset) {
    return new this(new Position(startElement, startOffset), new Position(endElement, endOffset));
  }
  /**
   * Creates a new range, spreading from specified {@link module:engine/view/position~Position position} to a position moved by
   * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.
   *
   * @internal
   * @param position Beginning of the range.
   * @param shift How long the range should be.
   */
  static _createFromPositionAndShift(position, shift) {
    const start = position;
    const end = position.getShiftedBy(shift);
    return shift > 0 ? new this(start, end) : new this(end, start);
  }
  /**
   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * @internal
   * @param element Element which is a parent for the range.
   */
  static _createIn(element) {
    return this._createFromParentsAndOffsets(element, 0, element, element.childCount);
  }
  /**
   * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
   *
   * @internal
   */
  static _createOn(item) {
    const size = item.is("$textProxy") ? item.offsetSize : 1;
    return this._createFromPositionAndShift(Position._createBefore(item), size);
  }
};
Range.prototype.is = function(type) {
  return type === "range" || type === "view:range";
};
function enlargeTrimSkip(value) {
  if (value.item.is("attributeElement") || value.item.is("uiElement")) {
    return true;
  }
  return false;
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/documentselection.js
var DocumentSelection = class extends EmitterMixin(TypeCheckable) {
  constructor(...args) {
    super();
    this._selection = new Selection();
    this._selection.delegate("change").to(this);
    if (args.length) {
      this._selection.setTo(...args);
    }
  }
  /**
   * Returns true if selection instance is marked as `fake`.
   *
   * @see #_setTo
   */
  get isFake() {
    return this._selection.isFake;
  }
  /**
   * Returns fake selection label.
   *
   * @see #_setTo
   */
  get fakeSelectionLabel() {
    return this._selection.fakeSelectionLabel;
  }
  /**
   * Selection anchor. Anchor may be described as a position where the selection starts. Together with
   * {@link #focus focus} they define the direction of selection, which is important
   * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.
   * It may be a bit unintuitive when there are multiple ranges in selection.
   *
   * @see #focus
   */
  get anchor() {
    return this._selection.anchor;
  }
  /**
   * Selection focus. Focus is a position where the selection ends.
   *
   * @see #anchor
   */
  get focus() {
    return this._selection.focus;
  }
  /**
   * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
   * collapsed.
   */
  get isCollapsed() {
    return this._selection.isCollapsed;
  }
  /**
   * Returns number of ranges in selection.
   */
  get rangeCount() {
    return this._selection.rangeCount;
  }
  /**
   * Specifies whether the {@link #focus} precedes {@link #anchor}.
   */
  get isBackward() {
    return this._selection.isBackward;
  }
  /**
   * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this selection, or `null`
   * if the selection is not inside an editable element.
   */
  get editableElement() {
    return this._selection.editableElement;
  }
  /**
   * Used for the compatibility with the {@link module:engine/view/selection~Selection#isEqual} method.
   *
   * @internal
   */
  get _ranges() {
    return this._selection._ranges;
  }
  /**
   * Returns an iterable that contains copies of all ranges added to the selection.
   */
  *getRanges() {
    yield* this._selection.getRanges();
  }
  /**
   * Returns copy of the first range in the selection. First range is the one which
   * {@link module:engine/view/range~Range#start start} position {@link module:engine/view/position~Position#isBefore is before} start
   * position of all other ranges (not to confuse with the first range added to the selection).
   * Returns `null` if no ranges are added to selection.
   */
  getFirstRange() {
    return this._selection.getFirstRange();
  }
  /**
   * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~Range#end end}
   * position {@link module:engine/view/position~Position#isAfter is after} end position of all other ranges (not to confuse
   * with the last range added to the selection). Returns `null` if no ranges are added to selection.
   */
  getLastRange() {
    return this._selection.getLastRange();
  }
  /**
   * Returns copy of the first position in the selection. First position is the position that
   * {@link module:engine/view/position~Position#isBefore is before} any other position in the selection ranges.
   * Returns `null` if no ranges are added to selection.
   */
  getFirstPosition() {
    return this._selection.getFirstPosition();
  }
  /**
   * Returns copy of the last position in the selection. Last position is the position that
   * {@link module:engine/view/position~Position#isAfter is after} any other position in the selection ranges.
   * Returns `null` if no ranges are added to selection.
   */
  getLastPosition() {
    return this._selection.getLastPosition();
  }
  /**
   * Returns the selected element. {@link module:engine/view/element~Element Element} is considered as selected if there is only
   * one range in the selection, and that range contains exactly one element.
   * Returns `null` if there is no selected element.
   */
  getSelectedElement() {
    return this._selection.getSelectedElement();
  }
  /**
   * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,
   * same number of ranges and all ranges from one selection equal to a range from other selection.
   *
   * @param otherSelection Selection to compare with.
   * @returns `true` if selections are equal, `false` otherwise.
   */
  isEqual(otherSelection) {
    return this._selection.isEqual(otherSelection);
  }
  /**
   * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same
   * number of ranges, and all {@link module:engine/view/range~Range#getTrimmed trimmed} ranges from one selection are
   * equal to any trimmed range from other selection.
   *
   * @param otherSelection Selection to compare with.
   * @returns `true` if selections are similar, `false` otherwise.
   */
  isSimilar(otherSelection) {
    return this._selection.isSimilar(otherSelection);
  }
  /**
   * Sets this selection's ranges and direction to the specified location based on the given
   * {@link module:engine/view/selection~Selectable selectable}.
   *
   * ```ts
   * // Sets selection to the given range.
   * const range = writer.createRange( start, end );
   * documentSelection._setTo( range );
   *
   * // Sets selection to given ranges.
   * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( start2, end2 ) ];
   * documentSelection._setTo( range );
   *
   * // Sets selection to the other selection.
   * const otherSelection = writer.createSelection();
   * documentSelection._setTo( otherSelection );
   *
   * // Sets collapsed selection at the given position.
   * const position = writer.createPositionAt( root, offset );
   * documentSelection._setTo( position );
   *
   * // Sets collapsed selection at the position of given item and offset.
   * documentSelection._setTo( paragraph, offset );
   * ```
   *
   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * ```ts
   * documentSelection._setTo( paragraph, 'in' );
   * ```
   *
   * Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.
   *
   * ```ts
   * documentSelection._setTo( paragraph, 'on' );
   *
   * // Clears selection. Removes all ranges.
   * documentSelection._setTo( null );
   * ```
   *
   * `Selection#_setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.
   *
   * ```ts
   * // Sets selection as backward.
   * documentSelection._setTo( range, { backward: true } );
   * ```
   *
   * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
   * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
   * represented in other way, for example by applying proper CSS class.
   *
   * Additionally fake's selection label can be provided. It will be used to des cribe fake selection in DOM
   * (and be  properly handled by screen readers).
   *
   * ```ts
   * // Creates fake selection with label.
   * documentSelection._setTo( range, { fake: true, label: 'foo' } );
   * ```
   *
   * @internal
   * @fires change
   */
  _setTo(...args) {
    this._selection.setTo(...args);
  }
  /**
   * Moves {@link #focus} to the specified location.
   *
   * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}
   * parameters.
   *
   * @internal
   * @fires change
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
   */
  _setFocus(itemOrPosition, offset) {
    this._selection.setFocus(itemOrPosition, offset);
  }
};
DocumentSelection.prototype.is = function(type) {
  return type === "selection" || type == "documentSelection" || type == "view:selection" || type == "view:documentSelection";
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/selection.js
var Selection = class _Selection extends EmitterMixin(TypeCheckable) {
  /**
   * Creates new selection instance.
   *
   * **Note**: The selection constructor is available as a factory method:
   *
   * * {@link module:engine/view/view~View#createSelection `View#createSelection()`},
   * * {@link module:engine/view/upcastwriter~UpcastWriter#createSelection `UpcastWriter#createSelection()`}.
   *
   * ```ts
   * // Creates empty selection without ranges.
   * const selection = writer.createSelection();
   *
   * // Creates selection at the given range.
   * const range = writer.createRange( start, end );
   * const selection = writer.createSelection( range );
   *
   * // Creates selection at the given ranges
   * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
   * const selection = writer.createSelection( ranges );
   *
   * // Creates selection from the other selection.
   * const otherSelection = writer.createSelection();
   * const selection = writer.createSelection( otherSelection );
   *
   * // Creates selection from the document selection.
   * const selection = writer.createSelection( editor.editing.view.document.selection );
   *
   * // Creates selection at the given position.
   * const position = writer.createPositionFromPath( root, path );
   * const selection = writer.createSelection( position );
   *
   * // Creates collapsed selection at the position of given item and offset.
   * const paragraph = writer.createContainerElement( 'paragraph' );
   * const selection = writer.createSelection( paragraph, offset );
   *
   * // Creates a range inside an {@link module:engine/view/element~Element element} which starts before the
   * // first child of that element and ends after the last child of that element.
   * const selection = writer.createSelection( paragraph, 'in' );
   *
   * // Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends
   * // just after the item.
   * const selection = writer.createSelection( paragraph, 'on' );
   * ```
   *
   * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.
   *
   * ```ts
   * // Creates backward selection.
   * const selection = writer.createSelection( range, { backward: true } );
   * ```
   *
   * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
   * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
   * represented in other way, for example by applying proper CSS class.
   *
   * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM
   * (and be  properly handled by screen readers).
   *
   * ```ts
   * // Creates fake selection with label.
   * const selection = writer.createSelection( range, { fake: true, label: 'foo' } );
   * ```
   *
   * @internal
   */
  constructor(...args) {
    super();
    this._ranges = [];
    this._lastRangeBackward = false;
    this._isFake = false;
    this._fakeSelectionLabel = "";
    if (args.length) {
      this.setTo(...args);
    }
  }
  /**
   * Returns true if selection instance is marked as `fake`.
   *
   * @see #setTo
   */
  get isFake() {
    return this._isFake;
  }
  /**
   * Returns fake selection label.
   *
   * @see #setTo
   */
  get fakeSelectionLabel() {
    return this._fakeSelectionLabel;
  }
  /**
   * Selection anchor. Anchor may be described as a position where the selection starts. Together with
   * {@link #focus focus} they define the direction of selection, which is important
   * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.
   * It may be a bit unintuitive when there are multiple ranges in selection.
   *
   * @see #focus
   */
  get anchor() {
    if (!this._ranges.length) {
      return null;
    }
    const range = this._ranges[this._ranges.length - 1];
    const anchor = this._lastRangeBackward ? range.end : range.start;
    return anchor.clone();
  }
  /**
   * Selection focus. Focus is a position where the selection ends.
   *
   * @see #anchor
   */
  get focus() {
    if (!this._ranges.length) {
      return null;
    }
    const range = this._ranges[this._ranges.length - 1];
    const focus = this._lastRangeBackward ? range.start : range.end;
    return focus.clone();
  }
  /**
   * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
   * collapsed.
   */
  get isCollapsed() {
    return this.rangeCount === 1 && this._ranges[0].isCollapsed;
  }
  /**
   * Returns number of ranges in selection.
   */
  get rangeCount() {
    return this._ranges.length;
  }
  /**
   * Specifies whether the {@link #focus} precedes {@link #anchor}.
   */
  get isBackward() {
    return !this.isCollapsed && this._lastRangeBackward;
  }
  /**
   * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this selection, or `null`
   * if the selection is not inside an editable element.
   */
  get editableElement() {
    if (this.anchor) {
      return this.anchor.editableElement;
    }
    return null;
  }
  /**
   * Returns an iterable that contains copies of all ranges added to the selection.
   */
  *getRanges() {
    for (const range of this._ranges) {
      yield range.clone();
    }
  }
  /**
   * Returns copy of the first range in the selection. First range is the one which
   * {@link module:engine/view/range~Range#start start} position {@link module:engine/view/position~Position#isBefore is before} start
   * position of all other ranges (not to confuse with the first range added to the selection).
   * Returns `null` if no ranges are added to selection.
   */
  getFirstRange() {
    let first2 = null;
    for (const range of this._ranges) {
      if (!first2 || range.start.isBefore(first2.start)) {
        first2 = range;
      }
    }
    return first2 ? first2.clone() : null;
  }
  /**
   * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~Range#end end}
   * position {@link module:engine/view/position~Position#isAfter is after} end position of all other ranges (not to confuse
   * with the last range added to the selection). Returns `null` if no ranges are added to selection.
   */
  getLastRange() {
    let last = null;
    for (const range of this._ranges) {
      if (!last || range.end.isAfter(last.end)) {
        last = range;
      }
    }
    return last ? last.clone() : null;
  }
  /**
   * Returns copy of the first position in the selection. First position is the position that
   * {@link module:engine/view/position~Position#isBefore is before} any other position in the selection ranges.
   * Returns `null` if no ranges are added to selection.
   */
  getFirstPosition() {
    const firstRange = this.getFirstRange();
    return firstRange ? firstRange.start.clone() : null;
  }
  /**
   * Returns copy of the last position in the selection. Last position is the position that
   * {@link module:engine/view/position~Position#isAfter is after} any other position in the selection ranges.
   * Returns `null` if no ranges are added to selection.
   */
  getLastPosition() {
    const lastRange = this.getLastRange();
    return lastRange ? lastRange.end.clone() : null;
  }
  /**
   * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,
   * same number of ranges and all ranges from one selection equal to a range from other selection.
   *
   * @param otherSelection Selection to compare with.
   * @returns `true` if selections are equal, `false` otherwise.
   */
  isEqual(otherSelection) {
    if (this.isFake != otherSelection.isFake) {
      return false;
    }
    if (this.isFake && this.fakeSelectionLabel != otherSelection.fakeSelectionLabel) {
      return false;
    }
    if (this.rangeCount != otherSelection.rangeCount) {
      return false;
    } else if (this.rangeCount === 0) {
      return true;
    }
    if (!this.anchor.isEqual(otherSelection.anchor) || !this.focus.isEqual(otherSelection.focus)) {
      return false;
    }
    for (const thisRange of this._ranges) {
      let found = false;
      for (const otherRange of otherSelection._ranges) {
        if (thisRange.isEqual(otherRange)) {
          found = true;
          break;
        }
      }
      if (!found) {
        return false;
      }
    }
    return true;
  }
  /**
   * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same
   * number of ranges, and all {@link module:engine/view/range~Range#getTrimmed trimmed} ranges from one selection are
   * equal to any trimmed range from other selection.
   *
   * @param otherSelection Selection to compare with.
   * @returns `true` if selections are similar, `false` otherwise.
   */
  isSimilar(otherSelection) {
    if (this.isBackward != otherSelection.isBackward) {
      return false;
    }
    const numOfRangesA = count(this.getRanges());
    const numOfRangesB = count(otherSelection.getRanges());
    if (numOfRangesA != numOfRangesB) {
      return false;
    }
    if (numOfRangesA == 0) {
      return true;
    }
    for (let rangeA of this.getRanges()) {
      rangeA = rangeA.getTrimmed();
      let found = false;
      for (let rangeB of otherSelection.getRanges()) {
        rangeB = rangeB.getTrimmed();
        if (rangeA.start.isEqual(rangeB.start) && rangeA.end.isEqual(rangeB.end)) {
          found = true;
          break;
        }
      }
      if (!found) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns the selected element. {@link module:engine/view/element~Element Element} is considered as selected if there is only
   * one range in the selection, and that range contains exactly one element.
   * Returns `null` if there is no selected element.
   */
  getSelectedElement() {
    if (this.rangeCount !== 1) {
      return null;
    }
    return this.getFirstRange().getContainedElement();
  }
  /**
   * Sets this selection's ranges and direction to the specified location based on the given
   * {@link module:engine/view/selection~Selectable selectable}.
   *
   * ```ts
   * // Sets selection to the given range.
   * const range = writer.createRange( start, end );
   * selection.setTo( range );
   *
   * // Sets selection to given ranges.
   * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
   * selection.setTo( range );
   *
   * // Sets selection to the other selection.
   * const otherSelection = writer.createSelection();
   * selection.setTo( otherSelection );
   *
   * // Sets selection to contents of DocumentSelection.
   * selection.setTo( editor.editing.view.document.selection );
   *
   * // Sets collapsed selection at the given position.
   * const position = writer.createPositionAt( root, path );
   * selection.setTo( position );
   *
   * // Sets collapsed selection at the position of given item and offset.
   * selection.setTo( paragraph, offset );
   * ```
   *
   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * ```ts
   * selection.setTo( paragraph, 'in' );
   * ```
   *
   * Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.
   *
   * ```ts
   * selection.setTo( paragraph, 'on' );
   *
   * // Clears selection. Removes all ranges.
   * selection.setTo( null );
   * ```
   *
   * `Selection#setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.
   *
   * ```ts
   * // Sets selection as backward.
   * selection.setTo( range, { backward: true } );
   * ```
   *
   * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
   * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
   * represented in other way, for example by applying proper CSS class.
   *
   * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM
   * (and be  properly handled by screen readers).
   *
   * ```ts
   * // Creates fake selection with label.
   * selection.setTo( range, { fake: true, label: 'foo' } );
   * ```
   *
   * @fires change
   */
  setTo(...args) {
    let [selectable, placeOrOffset, options] = args;
    if (typeof placeOrOffset == "object") {
      options = placeOrOffset;
      placeOrOffset = void 0;
    }
    if (selectable === null) {
      this._setRanges([]);
      this._setFakeOptions(options);
    } else if (selectable instanceof _Selection || selectable instanceof DocumentSelection) {
      this._setRanges(selectable.getRanges(), selectable.isBackward);
      this._setFakeOptions({ fake: selectable.isFake, label: selectable.fakeSelectionLabel });
    } else if (selectable instanceof Range) {
      this._setRanges([selectable], options && options.backward);
      this._setFakeOptions(options);
    } else if (selectable instanceof Position) {
      this._setRanges([new Range(selectable)]);
      this._setFakeOptions(options);
    } else if (selectable instanceof Node2) {
      const backward = !!options && !!options.backward;
      let range;
      if (placeOrOffset === void 0) {
        throw new CKEditorError("view-selection-setto-required-second-parameter", this);
      } else if (placeOrOffset == "in") {
        range = Range._createIn(selectable);
      } else if (placeOrOffset == "on") {
        range = Range._createOn(selectable);
      } else {
        range = new Range(Position._createAt(selectable, placeOrOffset));
      }
      this._setRanges([range], backward);
      this._setFakeOptions(options);
    } else if (isIterable(selectable)) {
      this._setRanges(selectable, options && options.backward);
      this._setFakeOptions(options);
    } else {
      throw new CKEditorError("view-selection-setto-not-selectable", this);
    }
    this.fire("change");
  }
  /**
   * Moves {@link #focus} to the specified location.
   *
   * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}
   * parameters.
   *
   * @fires change
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
   */
  setFocus(itemOrPosition, offset) {
    if (this.anchor === null) {
      throw new CKEditorError("view-selection-setfocus-no-ranges", this);
    }
    const newFocus = Position._createAt(itemOrPosition, offset);
    if (newFocus.compareWith(this.focus) == "same") {
      return;
    }
    const anchor = this.anchor;
    this._ranges.pop();
    if (newFocus.compareWith(anchor) == "before") {
      this._addRange(new Range(newFocus, anchor), true);
    } else {
      this._addRange(new Range(anchor, newFocus));
    }
    this.fire("change");
  }
  /**
   * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array
   * is treated like the last added range and is used to set {@link #anchor anchor} and {@link #focus focus}.
   * Accepts a flag describing in which way the selection is made.
   *
   * @param newRanges Iterable object of ranges to set.
   * @param isLastBackward Flag describing if last added range was selected forward - from start to end
   * (`false`) or backward - from end to start (`true`). Defaults to `false`.
   */
  _setRanges(newRanges, isLastBackward = false) {
    newRanges = Array.from(newRanges);
    this._ranges = [];
    for (const range of newRanges) {
      this._addRange(range);
    }
    this._lastRangeBackward = !!isLastBackward;
  }
  /**
   * Sets this selection instance to be marked as `fake`. A fake selection does not render as browser native selection
   * over selected elements and is hidden to the user. This way, no native selection UI artifacts are displayed to
   * the user and selection over elements can be represented in other way, for example by applying proper CSS class.
   *
   * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM (and be
   * properly handled by screen readers).
   */
  _setFakeOptions(options = {}) {
    this._isFake = !!options.fake;
    this._fakeSelectionLabel = options.fake ? options.label || "" : "";
  }
  /**
   * Adds a range to the selection. Added range is copied. This means that passed range is not saved in the
   * selection instance and you can safely operate on it.
   *
   * Accepts a flag describing in which way the selection is made - passed range might be selected from
   * {@link module:engine/view/range~Range#start start} to {@link module:engine/view/range~Range#end end}
   * or from {@link module:engine/view/range~Range#end end} to {@link module:engine/view/range~Range#start start}.
   * The flag is used to set {@link #anchor anchor} and {@link #focus focus} properties.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects
   * with ranges already stored in Selection instance.
   */
  _addRange(range, isBackward = false) {
    if (!(range instanceof Range)) {
      throw new CKEditorError("view-selection-add-range-not-range", this);
    }
    this._pushRange(range);
    this._lastRangeBackward = !!isBackward;
  }
  /**
   * Adds range to selection - creates copy of given range so it can be safely used and modified.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects
   * with ranges already stored in selection instance.
   */
  _pushRange(range) {
    for (const storedRange of this._ranges) {
      if (range.isIntersecting(storedRange)) {
        throw new CKEditorError("view-selection-range-intersects", this, { addedRange: range, intersectingRange: storedRange });
      }
    }
    this._ranges.push(new Range(range.start, range.end));
  }
};
Selection.prototype.is = function(type) {
  return type === "selection" || type === "view:selection";
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/documentfragment.js
var DocumentFragment = class extends EmitterMixin(TypeCheckable) {
  /**
   * Creates new DocumentFragment instance.
   *
   * @internal
   * @param document The document to which this document fragment belongs.
   * @param children A list of nodes to be inserted into the created document fragment.
   */
  constructor(document2, children) {
    super();
    this._children = [];
    this._customProperties = /* @__PURE__ */ new Map();
    this.document = document2;
    if (children) {
      this._insertChild(0, children);
    }
  }
  /**
   * Iterable interface.
   *
   * Iterates over nodes added to this document fragment.
   */
  [Symbol.iterator]() {
    return this._children[Symbol.iterator]();
  }
  /**
   * Number of child nodes in this document fragment.
   */
  get childCount() {
    return this._children.length;
  }
  /**
   * Is `true` if there are no nodes inside this document fragment, `false` otherwise.
   */
  get isEmpty() {
    return this.childCount === 0;
  }
  /**
   * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.
   */
  get root() {
    return this;
  }
  /**
   * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.
   */
  get parent() {
    return null;
  }
  /**
   * Artificial element name. Returns `undefined`. Added for compatibility reasons.
   */
  get name() {
    return void 0;
  }
  /**
   * Artificial element getFillerOffset. Returns `undefined`. Added for compatibility reasons.
   */
  get getFillerOffset() {
    return void 0;
  }
  /**
   * Returns the custom property value for the given key.
   */
  getCustomProperty(key) {
    return this._customProperties.get(key);
  }
  /**
   * Returns an iterator which iterates over this document fragment's custom properties.
   * Iterator provides `[ key, value ]` pairs for each stored property.
   */
  *getCustomProperties() {
    yield* this._customProperties.entries();
  }
  /**
   * {@link module:engine/view/documentfragment~DocumentFragment#_insertChild Insert} a child node or a list of child nodes at the end
   * and sets the parent of these nodes to this fragment.
   *
   * @internal
   * @param items Items to be inserted.
   * @returns Number of appended nodes.
   */
  _appendChild(items) {
    return this._insertChild(this.childCount, items);
  }
  /**
   * Gets child at the given index.
   *
   * @param index Index of child.
   * @returns Child node.
   */
  getChild(index) {
    return this._children[index];
  }
  /**
   * Gets index of the given child node. Returns `-1` if child node is not found.
   *
   * @param node Child node.
   * @returns Index of the child node.
   */
  getChildIndex(node) {
    return this._children.indexOf(node);
  }
  /**
   * Gets child nodes iterator.
   *
   * @returns Child nodes iterator.
   */
  getChildren() {
    return this._children[Symbol.iterator]();
  }
  /**
   * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
   * this fragment.
   *
   * @internal
   * @param index Position where nodes should be inserted.
   * @param items Items to be inserted.
   * @returns Number of inserted nodes.
   */
  _insertChild(index, items) {
    this._fireChange("children", this);
    let count2 = 0;
    const nodes = normalize3(this.document, items);
    for (const node of nodes) {
      if (node.parent !== null) {
        node._remove();
      }
      node.parent = this;
      this._children.splice(index, 0, node);
      index++;
      count2++;
    }
    return count2;
  }
  /**
   * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
   *
   * @internal
   * @param index Number of the first node to remove.
   * @param howMany Number of nodes to remove.
   * @returns The array of removed nodes.
   */
  _removeChildren(index, howMany = 1) {
    this._fireChange("children", this);
    for (let i = index; i < index + howMany; i++) {
      this._children[i].parent = null;
    }
    return this._children.splice(index, howMany);
  }
  /**
   * Fires `change` event with given type of the change.
   *
   * @internal
   * @param type Type of the change.
   * @param node Changed node.
   */
  _fireChange(type, node) {
    this.fire("change:" + type, node);
  }
  /**
   * Sets a custom property. They can be used to add special data to elements.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#setCustomProperty
   * @internal
   */
  _setCustomProperty(key, value) {
    this._customProperties.set(key, value);
  }
  /**
   * Removes the custom property stored under the given key.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#removeCustomProperty
   * @internal
   * @returns Returns true if property was removed.
   */
  _removeCustomProperty(key) {
    return this._customProperties.delete(key);
  }
};
DocumentFragment.prototype.is = function(type) {
  return type === "documentFragment" || type === "view:documentFragment";
};
function normalize3(document2, nodes) {
  if (typeof nodes == "string") {
    return [new Text(document2, nodes)];
  }
  if (!isIterable(nodes)) {
    nodes = [nodes];
  }
  return Array.from(nodes).map((node) => {
    if (typeof node == "string") {
      return new Text(document2, node);
    }
    if (node instanceof TextProxy) {
      return new Text(document2, node.data);
    }
    return node;
  });
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/filler.js
var NBSP_FILLER = (domDocument) => domDocument.createTextNode(" ");
var MARKED_NBSP_FILLER = (domDocument) => {
  const span = domDocument.createElement("span");
  span.dataset.ckeFiller = "true";
  span.innerText = " ";
  return span;
};
var BR_FILLER = (domDocument) => {
  const fillerBr = domDocument.createElement("br");
  fillerBr.dataset.ckeFiller = "true";
  return fillerBr;
};
var INLINE_FILLER_LENGTH = 7;
var INLINE_FILLER = "⁠".repeat(INLINE_FILLER_LENGTH);
function startsWithFiller(domNode) {
  if (typeof domNode == "string") {
    return domNode.substr(0, INLINE_FILLER_LENGTH) === INLINE_FILLER;
  }
  return isText(domNode) && domNode.data.substr(0, INLINE_FILLER_LENGTH) === INLINE_FILLER;
}
function isInlineFiller(domText) {
  return domText.data.length == INLINE_FILLER_LENGTH && startsWithFiller(domText);
}
function getDataWithoutFiller(domText) {
  const data = typeof domText == "string" ? domText : domText.data;
  if (startsWithFiller(domText)) {
    return data.slice(INLINE_FILLER_LENGTH);
  }
  return data;
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/domconverter.js
var BR_FILLER_REF = BR_FILLER(global_default.document);
var NBSP_FILLER_REF = NBSP_FILLER(global_default.document);
var MARKED_NBSP_FILLER_REF = MARKED_NBSP_FILLER(global_default.document);
var UNSAFE_ATTRIBUTE_NAME_PREFIX = "data-ck-unsafe-attribute-";
var UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE = "data-ck-unsafe-element";
var DomConverter = class {
  /**
   * Creates a DOM converter.
   *
   * @param document The view document instance.
   * @param options An object with configuration options.
   * @param options.blockFillerMode The type of the block filler to use.
   * Default value depends on the options.renderingMode:
   *  'nbsp' when options.renderingMode == 'data',
   *  'br' when options.renderingMode == 'editing'.
   * @param options.renderingMode Whether to leave the View-to-DOM conversion result unchanged
   * or improve editing experience by filtering out interactive data.
   */
  constructor(document2, { blockFillerMode, renderingMode = "editing" } = {}) {
    this._domToViewMapping = /* @__PURE__ */ new WeakMap();
    this._viewToDomMapping = /* @__PURE__ */ new WeakMap();
    this._fakeSelectionMapping = /* @__PURE__ */ new WeakMap();
    this._rawContentElementMatcher = new Matcher();
    this._inlineObjectElementMatcher = new Matcher();
    this._elementsWithTemporaryCustomProperties = /* @__PURE__ */ new Set();
    this.document = document2;
    this.renderingMode = renderingMode;
    this.blockFillerMode = blockFillerMode || (renderingMode === "editing" ? "br" : "nbsp");
    this.preElements = ["pre"];
    this.blockElements = [
      "address",
      "article",
      "aside",
      "blockquote",
      "caption",
      "center",
      "dd",
      "details",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "legend",
      "li",
      "main",
      "menu",
      "nav",
      "ol",
      "p",
      "pre",
      "section",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "tr",
      "ul"
    ];
    this.inlineObjectElements = [
      "object",
      "iframe",
      "input",
      "button",
      "textarea",
      "select",
      "option",
      "video",
      "embed",
      "audio",
      "img",
      "canvas"
    ];
    this.unsafeElements = ["script", "style"];
    this._domDocument = this.renderingMode === "editing" ? global_default.document : global_default.document.implementation.createHTMLDocument("");
  }
  /**
   * Binds a given DOM element that represents fake selection to a **position** of a
   * {@link module:engine/view/documentselection~DocumentSelection document selection}.
   * Document selection copy is stored and can be retrieved by the
   * {@link module:engine/view/domconverter~DomConverter#fakeSelectionToView} method.
   */
  bindFakeSelection(domElement, viewDocumentSelection) {
    this._fakeSelectionMapping.set(domElement, new Selection(viewDocumentSelection));
  }
  /**
   * Returns a {@link module:engine/view/selection~Selection view selection} instance corresponding to a given
   * DOM element that represents fake selection. Returns `undefined` if binding to the given DOM element does not exist.
   */
  fakeSelectionToView(domElement) {
    return this._fakeSelectionMapping.get(domElement);
  }
  /**
   * Binds DOM and view elements, so it will be possible to get corresponding elements using
   * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and
   * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.
   *
   * @param domElement The DOM element to bind.
   * @param viewElement The view element to bind.
   */
  bindElements(domElement, viewElement) {
    this._domToViewMapping.set(domElement, viewElement);
    this._viewToDomMapping.set(viewElement, domElement);
  }
  /**
   * Unbinds a given DOM element from the view element it was bound to. Unbinding is deep, meaning that all children of
   * the DOM element will be unbound too.
   *
   * @param domElement The DOM element to unbind.
   */
  unbindDomElement(domElement) {
    const viewElement = this._domToViewMapping.get(domElement);
    if (viewElement) {
      this._domToViewMapping.delete(domElement);
      this._viewToDomMapping.delete(viewElement);
      for (const child of Array.from(domElement.children)) {
        this.unbindDomElement(child);
      }
    }
  }
  /**
   * Binds DOM and view document fragments, so it will be possible to get corresponding document fragments using
   * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and
   * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.
   *
   * @param domFragment The DOM document fragment to bind.
   * @param viewFragment The view document fragment to bind.
   */
  bindDocumentFragments(domFragment, viewFragment) {
    this._domToViewMapping.set(domFragment, viewFragment);
    this._viewToDomMapping.set(viewFragment, domFragment);
  }
  /**
   * Decides whether a given pair of attribute key and value should be passed further down the pipeline.
   *
   * @param elementName Element name in lower case.
   */
  shouldRenderAttribute(attributeKey, attributeValue, elementName) {
    if (this.renderingMode === "data") {
      return true;
    }
    attributeKey = attributeKey.toLowerCase();
    if (attributeKey.startsWith("on")) {
      return false;
    }
    if (attributeKey === "srcdoc" && attributeValue.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)) {
      return false;
    }
    if (elementName === "img" && (attributeKey === "src" || attributeKey === "srcset")) {
      return true;
    }
    if (elementName === "source" && attributeKey === "srcset") {
      return true;
    }
    if (attributeValue.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i)) {
      return false;
    }
    return true;
  }
  /**
   * Set `domElement`'s content using provided `html` argument. Apply necessary filtering for the editing pipeline.
   *
   * @param domElement DOM element that should have `html` set as its content.
   * @param html Textual representation of the HTML that will be set on `domElement`.
   */
  setContentOf(domElement, html2) {
    if (this.renderingMode === "data") {
      domElement.innerHTML = html2;
      return;
    }
    const document2 = new DOMParser().parseFromString(html2, "text/html");
    const fragment = document2.createDocumentFragment();
    const bodyChildNodes = document2.body.childNodes;
    while (bodyChildNodes.length > 0) {
      fragment.appendChild(bodyChildNodes[0]);
    }
    const treeWalker = document2.createTreeWalker(fragment, NodeFilter.SHOW_ELEMENT);
    const nodes = [];
    let currentNode;
    while (currentNode = treeWalker.nextNode()) {
      nodes.push(currentNode);
    }
    for (const currentNode2 of nodes) {
      for (const attributeName of currentNode2.getAttributeNames()) {
        this.setDomElementAttribute(currentNode2, attributeName, currentNode2.getAttribute(attributeName));
      }
      const elementName = currentNode2.tagName.toLowerCase();
      if (this._shouldRenameElement(elementName)) {
        _logUnsafeElement(elementName);
        currentNode2.replaceWith(this._createReplacementDomElement(elementName, currentNode2));
      }
    }
    while (domElement.firstChild) {
      domElement.firstChild.remove();
    }
    domElement.append(fragment);
  }
  /**
   * Converts the view to the DOM. For all text nodes, not bound elements and document fragments new items will
   * be created. For bound elements and document fragments the method will return corresponding items.
   *
   * @param viewNode View node or document fragment to transform.
   * @param options Conversion options.
   * @param options.bind Determines whether new elements will be bound.
   * @param options.withChildren If `false`, node's and document fragment's children will not be converted.
   * @returns Converted node or DocumentFragment.
   */
  viewToDom(viewNode, options = {}) {
    if (viewNode.is("$text")) {
      const textData = this._processDataFromViewText(viewNode);
      return this._domDocument.createTextNode(textData);
    } else {
      const viewElementOrFragment = viewNode;
      if (this.mapViewToDom(viewElementOrFragment)) {
        if (viewElementOrFragment.getCustomProperty("editingPipeline:doNotReuseOnce")) {
          this._elementsWithTemporaryCustomProperties.add(viewElementOrFragment);
        } else {
          return this.mapViewToDom(viewElementOrFragment);
        }
      }
      let domElement;
      if (viewElementOrFragment.is("documentFragment")) {
        domElement = this._domDocument.createDocumentFragment();
        if (options.bind) {
          this.bindDocumentFragments(domElement, viewElementOrFragment);
        }
      } else if (viewElementOrFragment.is("uiElement")) {
        if (viewElementOrFragment.name === "$comment") {
          domElement = this._domDocument.createComment(viewElementOrFragment.getCustomProperty("$rawContent"));
        } else {
          domElement = viewElementOrFragment.render(this._domDocument, this);
        }
        if (options.bind) {
          this.bindElements(domElement, viewElementOrFragment);
        }
        return domElement;
      } else {
        if (this._shouldRenameElement(viewElementOrFragment.name)) {
          _logUnsafeElement(viewElementOrFragment.name);
          domElement = this._createReplacementDomElement(viewElementOrFragment.name);
        } else if (viewElementOrFragment.hasAttribute("xmlns")) {
          domElement = this._domDocument.createElementNS(viewElementOrFragment.getAttribute("xmlns"), viewElementOrFragment.name);
        } else {
          domElement = this._domDocument.createElement(viewElementOrFragment.name);
        }
        if (viewElementOrFragment.is("rawElement")) {
          viewElementOrFragment.render(domElement, this);
        }
        if (options.bind) {
          this.bindElements(domElement, viewElementOrFragment);
        }
        for (const key of viewElementOrFragment.getAttributeKeys()) {
          this.setDomElementAttribute(domElement, key, viewElementOrFragment.getAttribute(key), viewElementOrFragment);
        }
      }
      if (options.withChildren !== false) {
        for (const child of this.viewChildrenToDom(viewElementOrFragment, options)) {
          domElement.appendChild(child);
        }
      }
      return domElement;
    }
  }
  /**
   * Sets the attribute on a DOM element.
   *
   * **Note**: To remove the attribute, use {@link #removeDomElementAttribute}.
   *
   * @param domElement The DOM element the attribute should be set on.
   * @param key The name of the attribute.
   * @param value The value of the attribute.
   * @param relatedViewElement The view element related to the `domElement` (if there is any).
   * It helps decide whether the attribute set is unsafe. For instance, view elements created via the
   * {@link module:engine/view/downcastwriter~DowncastWriter} methods can allow certain attributes that would normally be filtered out.
   */
  setDomElementAttribute(domElement, key, value, relatedViewElement) {
    const shouldRenderAttribute = this.shouldRenderAttribute(key, value, domElement.tagName.toLowerCase()) || relatedViewElement && relatedViewElement.shouldRenderUnsafeAttribute(key);
    if (!shouldRenderAttribute) {
      logWarning("domconverter-unsafe-attribute-detected", { domElement, key, value });
    }
    if (!isValidAttributeName(key)) {
      logWarning("domconverter-invalid-attribute-detected", { domElement, key, value });
      return;
    }
    if (domElement.hasAttribute(key) && !shouldRenderAttribute) {
      domElement.removeAttribute(key);
    } else if (domElement.hasAttribute(UNSAFE_ATTRIBUTE_NAME_PREFIX + key) && shouldRenderAttribute) {
      domElement.removeAttribute(UNSAFE_ATTRIBUTE_NAME_PREFIX + key);
    }
    domElement.setAttribute(shouldRenderAttribute ? key : UNSAFE_ATTRIBUTE_NAME_PREFIX + key, value);
  }
  /**
   * Removes an attribute from a DOM element.
   *
   * **Note**: To set the attribute, use {@link #setDomElementAttribute}.
   *
   * @param domElement The DOM element the attribute should be removed from.
   * @param key The name of the attribute.
   */
  removeDomElementAttribute(domElement, key) {
    if (key == UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE) {
      return;
    }
    domElement.removeAttribute(key);
    domElement.removeAttribute(UNSAFE_ATTRIBUTE_NAME_PREFIX + key);
  }
  /**
   * Converts children of the view element to DOM using the
   * {@link module:engine/view/domconverter~DomConverter#viewToDom} method.
   * Additionally, this method adds block {@link module:engine/view/filler filler} to the list of children, if needed.
   *
   * @param viewElement Parent view element.
   * @param options See {@link module:engine/view/domconverter~DomConverter#viewToDom} options parameter.
   * @returns DOM nodes.
   */
  *viewChildrenToDom(viewElement, options = {}) {
    const fillerPositionOffset = viewElement.getFillerOffset && viewElement.getFillerOffset();
    let offset = 0;
    for (const childView of viewElement.getChildren()) {
      if (fillerPositionOffset === offset) {
        yield this._getBlockFiller();
      }
      const transparentRendering = childView.is("element") && !!childView.getCustomProperty("dataPipeline:transparentRendering") && !first(childView.getAttributes());
      if (transparentRendering && this.renderingMode == "data") {
        yield* this.viewChildrenToDom(childView, options);
      } else {
        if (transparentRendering) {
          logWarning("domconverter-transparent-rendering-unsupported-in-editing-pipeline", { viewElement: childView });
        }
        yield this.viewToDom(childView, options);
      }
      offset++;
    }
    if (fillerPositionOffset === offset) {
      yield this._getBlockFiller();
    }
  }
  /**
   * Converts view {@link module:engine/view/range~Range} to DOM range.
   * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.
   *
   * @param viewRange View range.
   * @returns DOM range.
   */
  viewRangeToDom(viewRange) {
    const domStart = this.viewPositionToDom(viewRange.start);
    const domEnd = this.viewPositionToDom(viewRange.end);
    const domRange = this._domDocument.createRange();
    domRange.setStart(domStart.parent, domStart.offset);
    domRange.setEnd(domEnd.parent, domEnd.offset);
    return domRange;
  }
  /**
   * Converts view {@link module:engine/view/position~Position} to DOM parent and offset.
   *
   * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.
   * If the converted position is directly before inline filler it is moved inside the filler.
   *
   * @param viewPosition View position.
   * @returns DOM position or `null` if view position could not be converted to DOM.
   * DOM position has two properties:
   * * `parent` - DOM position parent.
   * * `offset` - DOM position offset.
   */
  viewPositionToDom(viewPosition) {
    const viewParent = viewPosition.parent;
    if (viewParent.is("$text")) {
      const domParent = this.findCorrespondingDomText(viewParent);
      if (!domParent) {
        return null;
      }
      let offset = viewPosition.offset;
      if (startsWithFiller(domParent)) {
        offset += INLINE_FILLER_LENGTH;
      }
      return { parent: domParent, offset };
    } else {
      let domParent, domBefore, domAfter;
      if (viewPosition.offset === 0) {
        domParent = this.mapViewToDom(viewParent);
        if (!domParent) {
          return null;
        }
        domAfter = domParent.childNodes[0];
      } else {
        const nodeBefore = viewPosition.nodeBefore;
        domBefore = nodeBefore.is("$text") ? this.findCorrespondingDomText(nodeBefore) : this.mapViewToDom(nodeBefore);
        if (!domBefore) {
          return null;
        }
        domParent = domBefore.parentNode;
        domAfter = domBefore.nextSibling;
      }
      if (isText(domAfter) && startsWithFiller(domAfter)) {
        return { parent: domAfter, offset: INLINE_FILLER_LENGTH };
      }
      const offset = domBefore ? indexOf(domBefore) + 1 : 0;
      return { parent: domParent, offset };
    }
  }
  /**
   * Converts DOM to view. For all text nodes, not bound elements and document fragments new items will
   * be created. For bound elements and document fragments function will return corresponding items. For
   * {@link module:engine/view/filler fillers} `null` will be returned.
   * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.
   *
   * @param domNode DOM node or document fragment to transform.
   * @param options Conversion options.
   * @param options.bind Determines whether new elements will be bound. False by default.
   * @param options.withChildren If `true`, node's and document fragment's children will be converted too. True by default.
   * @param options.keepOriginalCase If `false`, node's tag name will be converted to lower case. False by default.
   * @param options.skipComments If `false`, comment nodes will be converted to `$comment`
   * {@link module:engine/view/uielement~UIElement view UI elements}. False by default.
   * @returns Converted node or document fragment or `null` if DOM node is a {@link module:engine/view/filler filler}
   * or the given node is an empty text node.
   */
  domToView(domNode, options = {}) {
    const inlineNodes = [];
    const generator = this._domToView(domNode, options, inlineNodes);
    const node = generator.next().value;
    if (!node) {
      return null;
    }
    generator.next();
    this._processDomInlineNodes(null, inlineNodes, options);
    if (node.is("$text") && node.data.length == 0) {
      return null;
    }
    return node;
  }
  /**
   * Converts children of the DOM element to view nodes using
   * the {@link module:engine/view/domconverter~DomConverter#domToView} method.
   * Additionally this method omits block {@link module:engine/view/filler filler}, if it exists in the DOM parent.
   *
   * @param domElement Parent DOM element.
   * @param options See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.
   * @param inlineNodes An array that will be populated with inline nodes. It's used internally for whitespace processing.
   * @returns View nodes.
   */
  *domChildrenToView(domElement, options = {}, inlineNodes = []) {
    for (let i = 0; i < domElement.childNodes.length; i++) {
      const domChild = domElement.childNodes[i];
      const generator = this._domToView(domChild, options, inlineNodes);
      const viewChild = generator.next().value;
      if (viewChild !== null) {
        if (this._isBlockViewElement(viewChild)) {
          this._processDomInlineNodes(domElement, inlineNodes, options);
        }
        yield viewChild;
        generator.next();
      }
    }
    this._processDomInlineNodes(domElement, inlineNodes, options);
  }
  /**
   * Converts DOM selection to view {@link module:engine/view/selection~Selection}.
   * Ranges which cannot be converted will be omitted.
   *
   * @param domSelection DOM selection.
   * @returns View selection.
   */
  domSelectionToView(domSelection) {
    if (isGeckoRestrictedDomSelection(domSelection)) {
      return new Selection([]);
    }
    if (domSelection.rangeCount === 1) {
      let container = domSelection.getRangeAt(0).startContainer;
      if (isText(container)) {
        container = container.parentNode;
      }
      const viewSelection = this.fakeSelectionToView(container);
      if (viewSelection) {
        return viewSelection;
      }
    }
    const isBackward = this.isDomSelectionBackward(domSelection);
    const viewRanges = [];
    for (let i = 0; i < domSelection.rangeCount; i++) {
      const domRange = domSelection.getRangeAt(i);
      const viewRange = this.domRangeToView(domRange);
      if (viewRange) {
        viewRanges.push(viewRange);
      }
    }
    return new Selection(viewRanges, { backward: isBackward });
  }
  /**
   * Converts DOM Range to view {@link module:engine/view/range~Range}.
   * If the start or end position can not be converted `null` is returned.
   *
   * @param domRange DOM range.
   * @returns View range.
   */
  domRangeToView(domRange) {
    const viewStart = this.domPositionToView(domRange.startContainer, domRange.startOffset);
    const viewEnd = this.domPositionToView(domRange.endContainer, domRange.endOffset);
    if (viewStart && viewEnd) {
      return new Range(viewStart, viewEnd);
    }
    return null;
  }
  /**
   * Converts DOM parent and offset to view {@link module:engine/view/position~Position}.
   *
   * If the position is inside a {@link module:engine/view/filler filler} which has no corresponding view node,
   * position of the filler will be converted and returned.
   *
   * If the position is inside DOM element rendered by {@link module:engine/view/uielement~UIElement}
   * that position will be converted to view position before that UIElement.
   *
   * If structures are too different and it is not possible to find corresponding position then `null` will be returned.
   *
   * @param domParent DOM position parent.
   * @param domOffset DOM position offset. You can skip it when converting the inline filler node.
   * @returns View position.
   */
  domPositionToView(domParent, domOffset = 0) {
    if (this.isBlockFiller(domParent)) {
      return this.domPositionToView(domParent.parentNode, indexOf(domParent));
    }
    const viewElement = this.mapDomToView(domParent);
    if (viewElement && (viewElement.is("uiElement") || viewElement.is("rawElement"))) {
      return Position._createBefore(viewElement);
    }
    if (isText(domParent)) {
      if (isInlineFiller(domParent)) {
        return this.domPositionToView(domParent.parentNode, indexOf(domParent));
      }
      const viewParent = this.findCorrespondingViewText(domParent);
      let offset = domOffset;
      if (!viewParent) {
        return null;
      }
      if (startsWithFiller(domParent)) {
        offset -= INLINE_FILLER_LENGTH;
        offset = offset < 0 ? 0 : offset;
      }
      return new Position(viewParent, offset);
    } else {
      if (domOffset === 0) {
        const viewParent = this.mapDomToView(domParent);
        if (viewParent) {
          return new Position(viewParent, 0);
        }
      } else {
        const domBefore = domParent.childNodes[domOffset - 1];
        if (isText(domBefore) && isInlineFiller(domBefore) || domBefore && this.isBlockFiller(domBefore)) {
          return this.domPositionToView(domBefore.parentNode, indexOf(domBefore));
        }
        const viewBefore = isText(domBefore) ? this.findCorrespondingViewText(domBefore) : this.mapDomToView(domBefore);
        if (viewBefore && viewBefore.parent) {
          return new Position(viewBefore.parent, viewBefore.index + 1);
        }
      }
      return null;
    }
  }
  /**
   * Returns corresponding view {@link module:engine/view/element~Element Element} or
   * {@link module:engine/view/documentfragment~DocumentFragment} for provided DOM element or
   * document fragment. If there is no view item {@link module:engine/view/domconverter~DomConverter#bindElements bound}
   * to the given DOM - `undefined` is returned.
   *
   * For all DOM elements rendered by a {@link module:engine/view/uielement~UIElement} or
   * a {@link module:engine/view/rawelement~RawElement}, the parent `UIElement` or `RawElement` will be returned.
   *
   * @param domElementOrDocumentFragment DOM element or document fragment.
   * @returns Corresponding view element, document fragment or `undefined` if no element was bound.
   */
  mapDomToView(domElementOrDocumentFragment) {
    const hostElement = this.getHostViewElement(domElementOrDocumentFragment);
    return hostElement || this._domToViewMapping.get(domElementOrDocumentFragment);
  }
  /**
   * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},
   * corresponding text node is returned based on the sibling or parent.
   *
   * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used
   * to find the corresponding text node.
   *
   * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}
   * element, it is used to find the corresponding text node.
   *
   * For all text nodes rendered by a {@link module:engine/view/uielement~UIElement} or
   * a {@link module:engine/view/rawelement~RawElement}, the parent `UIElement` or `RawElement` will be returned.
   *
   * Otherwise `null` is returned.
   *
   * Note that for the block or inline {@link module:engine/view/filler filler} this method returns `null`.
   *
   * @param domText DOM text node.
   * @returns Corresponding view text node or `null`, if it was not possible to find a corresponding node.
   */
  findCorrespondingViewText(domText) {
    if (isInlineFiller(domText)) {
      return null;
    }
    const hostElement = this.getHostViewElement(domText);
    if (hostElement) {
      return hostElement;
    }
    const previousSibling = domText.previousSibling;
    if (previousSibling) {
      if (!this.isElement(previousSibling)) {
        return null;
      }
      const viewElement = this.mapDomToView(previousSibling);
      if (viewElement) {
        const nextSibling = viewElement.nextSibling;
        if (nextSibling instanceof Text) {
          return nextSibling;
        } else {
          return null;
        }
      }
    } else {
      const viewElement = this.mapDomToView(domText.parentNode);
      if (viewElement) {
        const firstChild = viewElement.getChild(0);
        if (firstChild instanceof Text) {
          return firstChild;
        } else {
          return null;
        }
      }
    }
    return null;
  }
  mapViewToDom(documentFragmentOrElement) {
    return this._viewToDomMapping.get(documentFragmentOrElement);
  }
  /**
   * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},
   * corresponding text node is returned based on the sibling or parent.
   *
   * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used
   * to find the corresponding text node.
   *
   * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}
   * element, it is used to find the corresponding text node.
   *
   * Otherwise `null` is returned.
   *
   * @param viewText View text node.
   * @returns Corresponding DOM text node or `null`, if it was not possible to find a corresponding node.
   */
  findCorrespondingDomText(viewText) {
    const previousSibling = viewText.previousSibling;
    if (previousSibling && this.mapViewToDom(previousSibling)) {
      return this.mapViewToDom(previousSibling).nextSibling;
    }
    if (!previousSibling && viewText.parent && this.mapViewToDom(viewText.parent)) {
      return this.mapViewToDom(viewText.parent).childNodes[0];
    }
    return null;
  }
  /**
   * Focuses DOM editable that is corresponding to provided {@link module:engine/view/editableelement~EditableElement}.
   */
  focus(viewEditable) {
    const domEditable = this.mapViewToDom(viewEditable);
    if (domEditable && domEditable.ownerDocument.activeElement !== domEditable) {
      const { scrollX, scrollY } = global_default.window;
      const scrollPositions = [];
      forEachDomElementAncestor(domEditable, (node) => {
        const { scrollLeft, scrollTop } = node;
        scrollPositions.push([scrollLeft, scrollTop]);
      });
      domEditable.focus();
      forEachDomElementAncestor(domEditable, (node) => {
        const [scrollLeft, scrollTop] = scrollPositions.shift();
        node.scrollLeft = scrollLeft;
        node.scrollTop = scrollTop;
      });
      global_default.window.scrollTo(scrollX, scrollY);
    }
  }
  /**
   * Remove DOM selection from blurred editable, so it won't interfere with clicking on dropdowns (especially on iOS).
   *
   * @internal
   */
  _clearDomSelection() {
    const domEditable = this.mapViewToDom(this.document.selection.editableElement);
    if (!domEditable) {
      return;
    }
    const domSelection = domEditable.ownerDocument.defaultView.getSelection();
    const newViewSelection = this.domSelectionToView(domSelection);
    const selectionInEditable = newViewSelection && newViewSelection.rangeCount > 0;
    if (selectionInEditable) {
      domSelection.removeAllRanges();
    }
  }
  /**
   * Returns `true` when `node.nodeType` equals `Node.ELEMENT_NODE`.
   *
   * @param node Node to check.
   */
  isElement(node) {
    return node && node.nodeType == Node.ELEMENT_NODE;
  }
  /**
   * Returns `true` when `node.nodeType` equals `Node.DOCUMENT_FRAGMENT_NODE`.
   *
   * @param node Node to check.
   */
  isDocumentFragment(node) {
    return node && node.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
  }
  /**
   * Checks if the node is an instance of the block filler for this DOM converter.
   *
   * ```ts
   * const converter = new DomConverter( viewDocument, { blockFillerMode: 'br' } );
   *
   * converter.isBlockFiller( BR_FILLER( document ) ); // true
   * converter.isBlockFiller( NBSP_FILLER( document ) ); // false
   * ```
   *
   * **Note:**: For the `'nbsp'` mode the method also checks context of a node so it cannot be a detached node.
   *
   * **Note:** A special case in the `'nbsp'` mode exists where the `<br>` in `<p><br></p>` is treated as a block filler.
   *
   * @param domNode DOM node to check.
   * @returns True if a node is considered a block filler for given mode.
   */
  isBlockFiller(domNode) {
    if (this.blockFillerMode == "br") {
      return domNode.isEqualNode(BR_FILLER_REF);
    }
    if (domNode.tagName === "BR" && hasBlockParent(domNode, this.blockElements) && domNode.parentNode.childNodes.length === 1) {
      return true;
    }
    return domNode.isEqualNode(MARKED_NBSP_FILLER_REF) || isNbspBlockFiller(domNode, this.blockElements);
  }
  /**
   * Returns `true` if given selection is a backward selection, that is, if it's `focus` is before `anchor`.
   *
   * @param DOM Selection instance to check.
   */
  isDomSelectionBackward(selection) {
    if (selection.isCollapsed) {
      return false;
    }
    const range = this._domDocument.createRange();
    try {
      range.setStart(selection.anchorNode, selection.anchorOffset);
      range.setEnd(selection.focusNode, selection.focusOffset);
    } catch (e) {
      return false;
    }
    const backward = range.collapsed;
    range.detach();
    return backward;
  }
  /**
   * Returns a parent {@link module:engine/view/uielement~UIElement} or {@link module:engine/view/rawelement~RawElement}
   * that hosts the provided DOM node. Returns `null` if there is no such parent.
   */
  getHostViewElement(domNode) {
    const ancestors = getAncestors(domNode);
    ancestors.pop();
    while (ancestors.length) {
      const domNode2 = ancestors.pop();
      const viewNode = this._domToViewMapping.get(domNode2);
      if (viewNode && (viewNode.is("uiElement") || viewNode.is("rawElement"))) {
        return viewNode;
      }
    }
    return null;
  }
  /**
   * Checks if the given selection's boundaries are at correct places.
   *
   * The following places are considered as incorrect for selection boundaries:
   *
   * * before or in the middle of an inline filler sequence,
   * * inside a DOM element which represents {@link module:engine/view/uielement~UIElement a view UI element},
   * * inside a DOM element which represents {@link module:engine/view/rawelement~RawElement a view raw element}.
   *
   * @param domSelection The DOM selection object to be checked.
   * @returns `true` if the given selection is at a correct place, `false` otherwise.
   */
  isDomSelectionCorrect(domSelection) {
    return this._isDomSelectionPositionCorrect(domSelection.anchorNode, domSelection.anchorOffset) && this._isDomSelectionPositionCorrect(domSelection.focusNode, domSelection.focusOffset);
  }
  /**
   * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data
   * and not processed during the conversion from DOM nodes to view elements.
   *
   * This is affecting how {@link module:engine/view/domconverter~DomConverter#domToView} and
   * {@link module:engine/view/domconverter~DomConverter#domChildrenToView} process DOM nodes.
   *
   * The raw data can be later accessed by a
   * {@link module:engine/view/element~Element#getCustomProperty custom property of a view element} called `"$rawContent"`.
   *
   * @param pattern Pattern matching a view element whose content should
   * be treated as raw data.
   */
  registerRawContentMatcher(pattern) {
    this._rawContentElementMatcher.add(pattern);
  }
  /**
   * Registers a {@link module:engine/view/matcher~MatcherPattern} for inline object view elements.
   *
   * This is affecting how {@link module:engine/view/domconverter~DomConverter#domToView} and
   * {@link module:engine/view/domconverter~DomConverter#domChildrenToView} process DOM nodes.
   *
   * This is an extension of a simple {@link #inlineObjectElements} array of element names.
   *
   * @param pattern Pattern matching a view element which should be treated as an inline object.
   */
  registerInlineObjectMatcher(pattern) {
    this._inlineObjectElementMatcher.add(pattern);
  }
  /**
   * Clear temporary custom properties.
   *
   * @internal
   */
  _clearTemporaryCustomProperties() {
    for (const element of this._elementsWithTemporaryCustomProperties) {
      element._removeCustomProperty("editingPipeline:doNotReuseOnce");
    }
    this._elementsWithTemporaryCustomProperties.clear();
  }
  /**
   * Returns the block {@link module:engine/view/filler filler} node based on the current {@link #blockFillerMode} setting.
   */
  _getBlockFiller() {
    switch (this.blockFillerMode) {
      case "nbsp":
        return NBSP_FILLER(this._domDocument);
      case "markedNbsp":
        return MARKED_NBSP_FILLER(this._domDocument);
      case "br":
        return BR_FILLER(this._domDocument);
    }
  }
  /**
   * Checks if the given DOM position is a correct place for selection boundary. See {@link #isDomSelectionCorrect}.
   *
   * @param domParent Position parent.
   * @param offset Position offset.
   * @returns `true` if given position is at a correct place for selection boundary, `false` otherwise.
   */
  _isDomSelectionPositionCorrect(domParent, offset) {
    if (isText(domParent) && startsWithFiller(domParent) && offset < INLINE_FILLER_LENGTH) {
      return false;
    }
    if (this.isElement(domParent) && startsWithFiller(domParent.childNodes[offset])) {
      return false;
    }
    const viewParent = this.mapDomToView(domParent);
    if (viewParent && (viewParent.is("uiElement") || viewParent.is("rawElement"))) {
      return false;
    }
    return true;
  }
  /**
   * Internal generator for {@link #domToView}. Also used by {@link #domChildrenToView}.
   * Separates DOM nodes conversion from whitespaces processing.
   *
   * @param domNode DOM node or document fragment to transform.
   * @param inlineNodes An array of recently encountered inline nodes truncated to the block element boundaries.
   * Used later to process whitespaces.
   */
  *_domToView(domNode, options, inlineNodes) {
    if (this.isBlockFiller(domNode)) {
      return null;
    }
    const hostElement = this.getHostViewElement(domNode);
    if (hostElement) {
      return hostElement;
    }
    if (isComment(domNode) && options.skipComments) {
      return null;
    }
    if (isText(domNode)) {
      if (isInlineFiller(domNode)) {
        return null;
      } else {
        const textData = domNode.data;
        if (textData === "") {
          return null;
        }
        const textNode = new Text(this.document, textData);
        inlineNodes.push(textNode);
        return textNode;
      }
    } else {
      let viewElement = this.mapDomToView(domNode);
      if (viewElement) {
        if (this._isInlineObjectElement(viewElement)) {
          inlineNodes.push(viewElement);
        }
        return viewElement;
      }
      if (this.isDocumentFragment(domNode)) {
        viewElement = new DocumentFragment(this.document);
        if (options.bind) {
          this.bindDocumentFragments(domNode, viewElement);
        }
      } else {
        viewElement = this._createViewElement(domNode, options);
        if (options.bind) {
          this.bindElements(domNode, viewElement);
        }
        const attrs = domNode.attributes;
        if (attrs) {
          for (let l = attrs.length, i = 0; i < l; i++) {
            viewElement._setAttribute(attrs[i].name, attrs[i].value);
          }
        }
        if (this._isViewElementWithRawContent(viewElement, options)) {
          viewElement._setCustomProperty("$rawContent", domNode.innerHTML);
          if (!this._isBlockViewElement(viewElement)) {
            inlineNodes.push(viewElement);
          }
          return viewElement;
        }
        if (isComment(domNode)) {
          viewElement._setCustomProperty("$rawContent", domNode.data);
          return viewElement;
        }
      }
      yield viewElement;
      const nestedInlineNodes = [];
      if (options.withChildren !== false) {
        for (const child of this.domChildrenToView(domNode, options, nestedInlineNodes)) {
          viewElement._appendChild(child);
        }
      }
      if (this._isInlineObjectElement(viewElement)) {
        inlineNodes.push(viewElement);
      } else {
        for (const inlineNode of nestedInlineNodes) {
          inlineNodes.push(inlineNode);
        }
      }
    }
  }
  /**
   * Internal helper that walks the list of inline view nodes already generated from DOM nodes
   * and handles whitespaces and NBSPs.
   *
   * @param domParent The DOM parent of the given inline nodes. This should be a document fragment or
   * a block element to whitespace processing start cleaning.
   * @param inlineNodes An array of recently encountered inline nodes truncated to the block element boundaries.
   */
  _processDomInlineNodes(domParent, inlineNodes, options) {
    if (!inlineNodes.length) {
      return;
    }
    if (domParent && !this.isDocumentFragment(domParent) && !this._isBlockDomElement(domParent)) {
      return;
    }
    let prevNodeEndsWithSpace = false;
    for (let i = 0; i < inlineNodes.length; i++) {
      const node = inlineNodes[i];
      if (!node.is("$text")) {
        prevNodeEndsWithSpace = false;
        continue;
      }
      let data;
      let nodeEndsWithSpace = false;
      if (_hasViewParentOfType(node, this.preElements)) {
        data = getDataWithoutFiller(node.data);
      } else {
        data = node.data.replace(/[ \n\t\r]{1,}/g, " ");
        nodeEndsWithSpace = /[^\S\u00A0]/.test(data.charAt(data.length - 1));
        const prevNode = i > 0 ? inlineNodes[i - 1] : null;
        const nextNode = i + 1 < inlineNodes.length ? inlineNodes[i + 1] : null;
        const shouldLeftTrim = !prevNode || prevNode.is("element") && prevNode.name == "br" || prevNodeEndsWithSpace;
        const shouldRightTrim = nextNode ? false : !startsWithFiller(node.data);
        if (options.withChildren !== false) {
          if (shouldLeftTrim) {
            data = data.replace(/^ /, "");
          }
          if (shouldRightTrim) {
            data = data.replace(/ $/, "");
          }
        }
        data = getDataWithoutFiller(data);
        data = data.replace(/ \u00A0/g, "  ");
        const isNextNodeInlineObjectElement = nextNode && nextNode.is("element") && nextNode.name != "br";
        const isNextNodeStartingWithSpace = nextNode && nextNode.is("$text") && nextNode.data.charAt(0) == " ";
        if (/[ \u00A0]\u00A0$/.test(data) || !nextNode || isNextNodeInlineObjectElement || isNextNodeStartingWithSpace) {
          data = data.replace(/\u00A0$/, " ");
        }
        if (shouldLeftTrim || prevNode && prevNode.is("element") && prevNode.name != "br") {
          data = data.replace(/^\u00A0/, " ");
        }
      }
      if (data.length == 0 && node.parent) {
        node._remove();
        inlineNodes.splice(i, 1);
        i--;
      } else {
        node._data = data;
        prevNodeEndsWithSpace = nodeEndsWithSpace;
      }
    }
    inlineNodes.length = 0;
  }
  /**
   * Takes text data from a given {@link module:engine/view/text~Text#data} and processes it so
   * it is correctly displayed in the DOM.
   *
   * Following changes are done:
   *
   * * a space at the beginning is changed to `&nbsp;` if this is the first text node in its container
   * element or if a previous text node ends with a space character,
   * * space at the end of the text node is changed to `&nbsp;` if there are two spaces at the end of a node or if next node
   * starts with a space or if it is the last text node in its container,
   * * remaining spaces are replaced to a chain of spaces and `&nbsp;` (e.g. `'x   x'` becomes `'x &nbsp; x'`).
   *
   * Content of {@link #preElements} is not processed.
   *
   * @param node View text node to process.
   * @returns Processed text data.
   */
  _processDataFromViewText(node) {
    let data = node.data;
    if (node.getAncestors().some((parent) => this.preElements.includes(parent.name))) {
      return data;
    }
    if (data.charAt(0) == " ") {
      const prevNode = this._getTouchingInlineViewNode(node, false);
      const prevEndsWithSpace = prevNode && prevNode.is("$textProxy") && this._nodeEndsWithSpace(prevNode);
      if (prevEndsWithSpace || !prevNode) {
        data = " " + data.substr(1);
      }
    }
    if (data.charAt(data.length - 1) == " ") {
      const nextNode = this._getTouchingInlineViewNode(node, true);
      const nextStartsWithSpace = nextNode && nextNode.is("$textProxy") && nextNode.data.charAt(0) == " ";
      if (data.charAt(data.length - 2) == " " || !nextNode || nextStartsWithSpace) {
        data = data.substr(0, data.length - 1) + " ";
      }
    }
    return data.replace(/ {2}/g, "  ");
  }
  /**
   * Checks whether given node ends with a space character after changing appropriate space characters to `&nbsp;`s.
   *
   * @param  node Node to check.
   * @returns `true` if given `node` ends with space, `false` otherwise.
   */
  _nodeEndsWithSpace(node) {
    if (node.getAncestors().some((parent) => this.preElements.includes(parent.name))) {
      return false;
    }
    const data = this._processDataFromViewText(node);
    return data.charAt(data.length - 1) == " ";
  }
  /**
   * Helper function. For given {@link module:engine/view/text~Text view text node}, it finds previous or next sibling
   * that is contained in the same container element. If there is no such sibling, `null` is returned.
   *
   * @param node Reference node.
   * @returns Touching text node, an inline object
   * or `null` if there is no next or previous touching text node.
   */
  _getTouchingInlineViewNode(node, getNext) {
    const treeWalker = new TreeWalker({
      startPosition: getNext ? Position._createAfter(node) : Position._createBefore(node),
      direction: getNext ? "forward" : "backward"
    });
    for (const value of treeWalker) {
      if (value.item.is("element", "br")) {
        return null;
      } else if (this._isInlineObjectElement(value.item)) {
        return value.item;
      } else if (value.item.is("containerElement")) {
        return null;
      } else if (value.item.is("$textProxy")) {
        return value.item;
      }
    }
    return null;
  }
  /**
   * Returns `true` if a DOM node belongs to {@link #blockElements}. `false` otherwise.
   */
  _isBlockDomElement(node) {
    return this.isElement(node) && this.blockElements.includes(node.tagName.toLowerCase());
  }
  /**
   * Returns `true` if a view node belongs to {@link #blockElements}. `false` otherwise.
   */
  _isBlockViewElement(node) {
    return node.is("element") && this.blockElements.includes(node.name);
  }
  /**
   * Returns `true` if a DOM node belongs to {@link #inlineObjectElements}. `false` otherwise.
   */
  _isInlineObjectElement(node) {
    if (!node.is("element")) {
      return false;
    }
    return node.name == "br" || this.inlineObjectElements.includes(node.name) || !!this._inlineObjectElementMatcher.match(node);
  }
  /**
   * Creates view element basing on the node type.
   *
   * @param node DOM node to check.
   * @param options Conversion options. See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.
   */
  _createViewElement(node, options) {
    if (isComment(node)) {
      return new UIElement(this.document, "$comment");
    }
    const viewName = options.keepOriginalCase ? node.tagName : node.tagName.toLowerCase();
    return new Element(this.document, viewName);
  }
  /**
   * Checks if view element's content should be treated as a raw data.
   *
   * @param viewElement View element to check.
   * @param options Conversion options. See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.
   */
  _isViewElementWithRawContent(viewElement, options) {
    return options.withChildren !== false && viewElement.is("element") && !!this._rawContentElementMatcher.match(viewElement);
  }
  /**
   * Checks whether a given element name should be renamed in a current rendering mode.
   *
   * @param elementName The name of view element.
   */
  _shouldRenameElement(elementName) {
    const name = elementName.toLowerCase();
    return this.renderingMode === "editing" && this.unsafeElements.includes(name);
  }
  /**
   * Return a <span> element with a special attribute holding the name of the original element.
   * Optionally, copy all the attributes of the original element if that element is provided.
   *
   * @param elementName The name of view element.
   * @param originalDomElement The original DOM element to copy attributes and content from.
   */
  _createReplacementDomElement(elementName, originalDomElement) {
    const newDomElement = this._domDocument.createElement("span");
    newDomElement.setAttribute(UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE, elementName);
    if (originalDomElement) {
      while (originalDomElement.firstChild) {
        newDomElement.appendChild(originalDomElement.firstChild);
      }
      for (const attributeName of originalDomElement.getAttributeNames()) {
        newDomElement.setAttribute(attributeName, originalDomElement.getAttribute(attributeName));
      }
    }
    return newDomElement;
  }
};
function _hasViewParentOfType(node, types) {
  return node.getAncestors().some((parent) => parent.is("element") && types.includes(parent.name));
}
function forEachDomElementAncestor(element, callback) {
  let node = element;
  while (node) {
    callback(node);
    node = node.parentElement;
  }
}
function isNbspBlockFiller(domNode, blockElements) {
  const isNBSP = domNode.isEqualNode(NBSP_FILLER_REF);
  return isNBSP && hasBlockParent(domNode, blockElements) && domNode.parentNode.childNodes.length === 1;
}
function hasBlockParent(domNode, blockElements) {
  const parent = domNode.parentNode;
  return !!parent && !!parent.tagName && blockElements.includes(parent.tagName.toLowerCase());
}
function _logUnsafeElement(elementName) {
  if (elementName === "script") {
    logWarning("domconverter-unsafe-script-element-detected");
  }
  if (elementName === "style") {
    logWarning("domconverter-unsafe-style-element-detected");
  }
}
function isGeckoRestrictedDomSelection(domSelection) {
  if (!env_default.isGecko) {
    return false;
  }
  if (!domSelection.rangeCount) {
    return false;
  }
  const container = domSelection.getRangeAt(0).startContainer;
  try {
    Object.prototype.toString.call(container);
  } catch (error) {
    return true;
  }
  return false;
}

// node_modules/@ckeditor/ckeditor5-engine/src/dataprocessor/htmldataprocessor.js
var HtmlDataProcessor = class {
  /**
   * Creates a new instance of the HTML data processor class.
   *
   * @param document The view document instance.
   */
  constructor(document2) {
    this.skipComments = true;
    this.domParser = new DOMParser();
    this.domConverter = new DomConverter(document2, { renderingMode: "data" });
    this.htmlWriter = new BasicHtmlWriter();
  }
  /**
   * Converts a provided {@link module:engine/view/documentfragment~DocumentFragment document fragment}
   * to data format &ndash; in this case to an HTML string.
   *
   * @returns HTML string.
   */
  toData(viewFragment) {
    const domFragment = this.domConverter.viewToDom(viewFragment);
    return this.htmlWriter.getHtml(domFragment);
  }
  /**
   * Converts the provided HTML string to a view tree.
   *
   * @param data An HTML string.
   * @returns A converted view element.
   */
  toView(data) {
    const domFragment = this._toDom(data);
    return this.domConverter.domToView(domFragment, { skipComments: this.skipComments });
  }
  /**
   * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data
   * and not processed during the conversion from the DOM to the view elements.
   *
   * The raw data can be later accessed by a
   * {@link module:engine/view/element~Element#getCustomProperty custom property of a view element} called `"$rawContent"`.
   *
   * @param pattern Pattern matching all view elements whose content should be treated as raw data.
   */
  registerRawContentMatcher(pattern) {
    this.domConverter.registerRawContentMatcher(pattern);
  }
  /**
   * If the processor is set to use marked fillers, it will insert `&nbsp;` fillers wrapped in `<span>` elements
   * (`<span data-cke-filler="true">&nbsp;</span>`) instead of regular `&nbsp;` characters.
   *
   * This mode allows for a more precise handling of the block fillers (so they do not leak into the editor content) but
   * bloats the editor data with additional markup.
   *
   * This mode may be required by some features and will be turned on by them automatically.
   *
   * @param type Whether to use the default or the marked `&nbsp;` block fillers.
   */
  useFillerType(type) {
    this.domConverter.blockFillerMode = type == "marked" ? "markedNbsp" : "nbsp";
  }
  /**
   * Converts an HTML string to its DOM representation. Returns a document fragment containing nodes parsed from
   * the provided data.
   */
  _toDom(data) {
    if (!data.match(/<(?:html|body|head|meta)(?:\s[^>]*)?>/i)) {
      data = `<body>${data}</body>`;
    }
    const document2 = this.domParser.parseFromString(data, "text/html");
    const fragment = document2.createDocumentFragment();
    const bodyChildNodes = document2.body.childNodes;
    while (bodyChildNodes.length > 0) {
      fragment.appendChild(bodyChildNodes[0]);
    }
    return fragment;
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/dataprocessor/xmldataprocessor.js
var XmlDataProcessor = class {
  /**
   * Creates a new instance of the XML data processor class.
   *
   * @param document The view document instance.
   * @param options Configuration options.
   * @param options.namespaces A list of namespaces allowed to use in the XML input.
   */
  constructor(document2, options = {}) {
    this.skipComments = true;
    this.namespaces = options.namespaces || [];
    this.domParser = new DOMParser();
    this.domConverter = new DomConverter(document2, { renderingMode: "data" });
    this.htmlWriter = new BasicHtmlWriter();
  }
  /**
   * Converts the provided {@link module:engine/view/documentfragment~DocumentFragment document fragment}
   * to data format &ndash; in this case an XML string.
   *
   * @returns An XML string.
   */
  toData(viewFragment) {
    const domFragment = this.domConverter.viewToDom(viewFragment);
    return this.htmlWriter.getHtml(domFragment);
  }
  /**
   * Converts the provided XML string to a view tree.
   *
   * @param data An XML string.
   * @returns A converted view element.
   */
  toView(data) {
    const domFragment = this._toDom(data);
    return this.domConverter.domToView(domFragment, {
      keepOriginalCase: true,
      skipComments: this.skipComments
    });
  }
  /**
   * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data
   * and not processed during the conversion from XML to view elements.
   *
   * The raw data can be later accessed by a
   * {@link module:engine/view/element~Element#getCustomProperty custom property of a view element} called `"$rawContent"`.
   *
   * @param pattern Pattern matching all view elements whose content should be treated as raw data.
   */
  registerRawContentMatcher(pattern) {
    this.domConverter.registerRawContentMatcher(pattern);
  }
  /**
   * If the processor is set to use marked fillers, it will insert `&nbsp;` fillers wrapped in `<span>` elements
   * (`<span data-cke-filler="true">&nbsp;</span>`) instead of regular `&nbsp;` characters.
   *
   * This mode allows for a more precise handling of block fillers (so they do not leak into editor content) but
   * bloats the editor data with additional markup.
   *
   * This mode may be required by some features and will be turned on by them automatically.
   *
   * @param type Whether to use the default or the marked `&nbsp;` block fillers.
   */
  useFillerType(type) {
    this.domConverter.blockFillerMode = type == "marked" ? "markedNbsp" : "nbsp";
  }
  /**
   * Converts an XML string to its DOM representation. Returns a document fragment containing nodes parsed from
   * the provided data.
   */
  _toDom(data) {
    const namespaces = this.namespaces.map((nsp) => `xmlns:${nsp}="nsp"`).join(" ");
    data = `<xml ${namespaces}>${data}</xml>`;
    const parsedDocument = this.domParser.parseFromString(data, "text/xml");
    const parserError = parsedDocument.querySelector("parsererror");
    if (parserError) {
      throw new Error("Parse error - " + parserError.textContent);
    }
    const fragment = parsedDocument.createDocumentFragment();
    const nodes = parsedDocument.documentElement.childNodes;
    while (nodes.length > 0) {
      fragment.appendChild(nodes[0]);
    }
    return fragment;
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/upcastwriter.js
var UpcastWriter = class {
  /**
   * @param document The view document instance in which this upcast writer operates.
   */
  constructor(document2) {
    this.document = document2;
  }
  /**
   * Creates a new {@link module:engine/view/documentfragment~DocumentFragment} instance.
   *
   * @param children A list of nodes to be inserted into the created document fragment.
   * @returns The created document fragment.
   */
  createDocumentFragment(children) {
    return new DocumentFragment(this.document, children);
  }
  /**
   * Creates a new {@link module:engine/view/element~Element} instance.
   *
   * Attributes can be passed in various formats:
   *
   * ```ts
   * upcastWriter.createElement( 'div', { class: 'editor', contentEditable: 'true' } ); // object
   * upcastWriter.createElement( 'div', [ [ 'class', 'editor' ], [ 'contentEditable', 'true' ] ] ); // map-like iterator
   * upcastWriter.createElement( 'div', mapOfAttributes ); // map
   * ```
   *
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   * @returns Created element.
   */
  createElement(name, attrs, children) {
    return new Element(this.document, name, attrs, children);
  }
  /**
   * Creates a new {@link module:engine/view/text~Text} instance.
   *
   * @param data The text's data.
   * @returns The created text node.
   */
  createText(data) {
    return new Text(this.document, data);
  }
  /**
   * Clones the provided element.
   *
   * @see module:engine/view/element~Element#_clone
   * @param element Element to be cloned.
   * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
   * element will be cloned without any children.
   * @returns Clone of this element.
   */
  clone(element, deep = false) {
    return element._clone(deep);
  }
  /**
   * Appends a child node or a list of child nodes at the end of this node
   * and sets the parent of these nodes to this element.
   *
   * @see module:engine/view/element~Element#_appendChild
   * @param items Items to be inserted.
   * @param element Element to which items will be appended.
   * @returns Number of appended nodes.
   */
  appendChild(items, element) {
    return element._appendChild(items);
  }
  /**
   * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
   * this element.
   *
   * @see module:engine/view/element~Element#_insertChild
   * @param index Offset at which nodes should be inserted.
   * @param items Items to be inserted.
   * @param element Element to which items will be inserted.
   * @returns Number of inserted nodes.
   */
  insertChild(index, items, element) {
    return element._insertChild(index, items);
  }
  /**
   * Removes the given number of child nodes starting at the given index and set the parent of these nodes to `null`.
   *
   * @see module:engine/view/element~Element#_removeChildren
   * @param index Offset from which nodes will be removed.
   * @param howMany Number of nodes to remove.
   * @param element Element which children will be removed.
   * @returns The array containing removed nodes.
   */
  removeChildren(index, howMany, element) {
    return element._removeChildren(index, howMany);
  }
  /**
   * Removes given element from the view structure. Will not have effect on detached elements.
   *
   * @param element Element which will be removed.
   * @returns The array containing removed nodes.
   */
  remove(element) {
    const parent = element.parent;
    if (parent) {
      return this.removeChildren(parent.getChildIndex(element), 1, parent);
    }
    return [];
  }
  /**
   * Replaces given element with the new one in the view structure. Will not have effect on detached elements.
   *
   * @param oldElement Element which will be replaced.
   * @param newElement Element which will be inserted in the place of the old element.
   * @returns Whether old element was successfully replaced.
   */
  replace(oldElement, newElement) {
    const parent = oldElement.parent;
    if (parent) {
      const index = parent.getChildIndex(oldElement);
      this.removeChildren(index, 1, parent);
      this.insertChild(index, newElement, parent);
      return true;
    }
    return false;
  }
  /**
   * Removes given element from view structure and places its children in its position.
   * It does nothing if element has no parent.
   *
   * @param element Element to unwrap.
   */
  unwrapElement(element) {
    const parent = element.parent;
    if (parent) {
      const index = parent.getChildIndex(element);
      this.remove(element);
      this.insertChild(index, element.getChildren(), parent);
    }
  }
  /**
   * Renames element by creating a copy of a given element but with its name changed and then moving contents of the
   * old element to the new one.
   *
   * Since this function creates a new element and removes the given one, the new element is returned to keep reference.
   *
   * @param newName New element name.
   * @param  element Element to be renamed.
   * @returns New element or null if the old element was not replaced (happens for detached elements).
   */
  rename(newName, element) {
    const newElement = new Element(this.document, newName, element.getAttributes(), element.getChildren());
    return this.replace(element, newElement) ? newElement : null;
  }
  /**
   * Adds or overwrites element's attribute with a specified key and value.
   *
   * ```ts
   * writer.setAttribute( 'href', 'http://ckeditor.com', linkElement );
   * ```
   *
   * @see module:engine/view/element~Element#_setAttribute
   * @param key Attribute key.
   * @param value Attribute value.
   * @param element Element for which attribute will be set.
   */
  setAttribute(key, value, element) {
    element._setAttribute(key, value);
  }
  /**
   * Removes attribute from the element.
   *
   * ```ts
   * writer.removeAttribute( 'href', linkElement );
   * ```
   *
   * @see module:engine/view/element~Element#_removeAttribute
   * @param key Attribute key.
   * @param element Element from which attribute will be removed.
   */
  removeAttribute(key, element) {
    element._removeAttribute(key);
  }
  /**
   * Adds specified class to the element.
   *
   * ```ts
   * writer.addClass( 'foo', linkElement );
   * writer.addClass( [ 'foo', 'bar' ], linkElement );
   * ```
   *
   * @see module:engine/view/element~Element#_addClass
   * @param className Single class name or array of class names which will be added.
   * @param element Element for which class will be added.
   */
  addClass(className, element) {
    element._addClass(className);
  }
  /**
   * Removes specified class from the element.
   *
   * ```ts
   * writer.removeClass( 'foo', linkElement );
   * writer.removeClass( [ 'foo', 'bar' ], linkElement );
   * ```
   *
   * @see module:engine/view/element~Element#_removeClass
   * @param className Single class name or array of class names which will be removed.
   * @param element Element from which class will be removed.
   */
  removeClass(className, element) {
    element._removeClass(className);
  }
  setStyle(property, valueOrElement, element) {
    if (isPlainObject_default(property) && element === void 0) {
      valueOrElement._setStyle(property);
    } else {
      element._setStyle(property, valueOrElement);
    }
  }
  /**
   * Removes specified style from the element.
   *
   * ```ts
   * writer.removeStyle( 'color', element );  // Removes 'color' style.
   * writer.removeStyle( [ 'color', 'border-top' ], element ); // Removes both 'color' and 'border-top' styles.
   * ```
   *
   * **Note**: This method can work with normalized style names if
   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
   * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.
   *
   * @see module:engine/view/element~Element#_removeStyle
   * @param property Style property name or names to be removed.
   * @param element Element from which style will be removed.
   */
  removeStyle(property, element) {
    element._removeStyle(property);
  }
  /**
   * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,
   * so they can be used to add special data to elements.
   *
   * @see module:engine/view/element~Element#_setCustomProperty
   * @param key Custom property name/key.
   * @param value Custom property value to be stored.
   * @param element Element for which custom property will be set.
   */
  setCustomProperty(key, value, element) {
    element._setCustomProperty(key, value);
  }
  /**
   * Removes a custom property stored under the given key.
   *
   * @see module:engine/view/element~Element#_removeCustomProperty
   * @param key Name/key of the custom property to be removed.
   * @param element Element from which the custom property will be removed.
   * @returns Returns true if property was removed.
   */
  removeCustomProperty(key, element) {
    return element._removeCustomProperty(key);
  }
  /**
   * Creates position at the given location. The location can be specified as:
   *
   * * a {@link module:engine/view/position~Position position},
   * * parent element and offset (offset defaults to `0`),
   * * parent element and `'end'` (sets position at the end of that element),
   * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
   *
   * This method is a shortcut to other constructors such as:
   *
   * * {@link #createPositionBefore},
   * * {@link #createPositionAfter},
   *
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
   */
  createPositionAt(itemOrPosition, offset) {
    return Position._createAt(itemOrPosition, offset);
  }
  /**
   * Creates a new position after given view item.
   *
   * @param item View item after which the position should be located.
   */
  createPositionAfter(item) {
    return Position._createAfter(item);
  }
  /**
   * Creates a new position before given view item.
   *
   * @param item View item before which the position should be located.
   */
  createPositionBefore(item) {
    return Position._createBefore(item);
  }
  /**
   * Creates a range spanning from `start` position to `end` position.
   *
   * **Note:** This factory method creates it's own {@link module:engine/view/position~Position} instances basing on passed values.
   *
   * @param start Start position.
   * @param end End position. If not set, range will be collapsed at `start` position.
   */
  createRange(start, end) {
    return new Range(start, end);
  }
  /**
   * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
   */
  createRangeOn(item) {
    return Range._createOn(item);
  }
  /**
   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * @param element Element which is a parent for the range.
   */
  createRangeIn(element) {
    return Range._createIn(element);
  }
  createSelection(...args) {
    return new Selection(...args);
  }
};

// node_modules/dompurify/dist/purify.es.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class2) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class3) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class3)
        _setPrototypeOf(instance, Class3.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var hasOwnProperty = Object.hasOwnProperty;
var setPrototypeOf = Object.setPrototypeOf;
var isFrozen = Object.isFrozen;
var getPrototypeOf = Object.getPrototypeOf;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var freeze = Object.freeze;
var seal = Object.seal;
var create = Object.create;
var _ref = typeof Reflect !== "undefined" && Reflect;
var apply = _ref.apply;
var construct = _ref.construct;
if (!apply) {
  apply = function apply2(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}
if (!freeze) {
  freeze = function freeze2(x) {
    return x;
  };
}
if (!seal) {
  seal = function seal2(x) {
    return x;
  };
}
if (!construct) {
  construct = function construct2(Func, args) {
    return _construct(Func, _toConsumableArray(args));
  };
}
var arrayForEach = unapply(Array.prototype.forEach);
var arrayPop = unapply(Array.prototype.pop);
var arrayPush = unapply(Array.prototype.push);
var stringToLowerCase = unapply(String.prototype.toLowerCase);
var stringToString = unapply(String.prototype.toString);
var stringMatch = unapply(String.prototype.match);
var stringReplace = unapply(String.prototype.replace);
var stringIndexOf = unapply(String.prototype.indexOf);
var stringTrim = unapply(String.prototype.trim);
var regExpTest = unapply(RegExp.prototype.test);
var typeErrorCreate = unconstruct(TypeError);
function unapply(func) {
  return function(thisArg) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return apply(func, thisArg, args);
  };
}
function unconstruct(func) {
  return function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return construct(func, args);
  };
}
function addToSet(set, array, transformCaseFunc) {
  var _transformCaseFunc;
  transformCaseFunc = (_transformCaseFunc = transformCaseFunc) !== null && _transformCaseFunc !== void 0 ? _transformCaseFunc : stringToLowerCase;
  if (setPrototypeOf) {
    setPrototypeOf(set, null);
  }
  var l = array.length;
  while (l--) {
    var element = array[l];
    if (typeof element === "string") {
      var lcElement = transformCaseFunc(element);
      if (lcElement !== element) {
        if (!isFrozen(array)) {
          array[l] = lcElement;
        }
        element = lcElement;
      }
    }
    set[element] = true;
  }
  return set;
}
function clone2(object) {
  var newObject = create(null);
  var property;
  for (property in object) {
    if (apply(hasOwnProperty, object, [property]) === true) {
      newObject[property] = object[property];
    }
  }
  return newObject;
}
function lookupGetter(object, prop) {
  while (object !== null) {
    var desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === "function") {
        return unapply(desc.value);
      }
    }
    object = getPrototypeOf(object);
  }
  function fallbackValue(element) {
    console.warn("fallback value for", element);
    return null;
  }
  return fallbackValue;
}
var html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
var svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
var mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]);
var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
var text = freeze(["#text"]);
var html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
var svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
var mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
var TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
var IS_ALLOWED_URI = seal(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
);
var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
var ATTR_WHITESPACE = seal(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
);
var DOCTYPE_NAME = seal(/^html$/i);
var getGlobal = function getGlobal2() {
  return typeof window === "undefined" ? null : window;
};
var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, document2) {
  if (_typeof(trustedTypes) !== "object" || typeof trustedTypes.createPolicy !== "function") {
    return null;
  }
  var suffix = null;
  var ATTR_NAME = "data-tt-policy-suffix";
  if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {
    suffix = document2.currentScript.getAttribute(ATTR_NAME);
  }
  var policyName = "dompurify" + (suffix ? "#" + suffix : "");
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML: function createHTML(html2) {
        return html2;
      },
      createScriptURL: function createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_) {
    console.warn("TrustedTypes policy " + policyName + " could not be created.");
    return null;
  }
};
function createDOMPurify() {
  var window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  var DOMPurify = function DOMPurify2(root) {
    return createDOMPurify(root);
  };
  DOMPurify.version = "2.4.7";
  DOMPurify.removed = [];
  if (!window2 || !window2.document || window2.document.nodeType !== 9) {
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  var originalDocument = window2.document;
  var document2 = window2.document;
  var DocumentFragment2 = window2.DocumentFragment, HTMLTemplateElement = window2.HTMLTemplateElement, Node3 = window2.Node, Element2 = window2.Element, NodeFilter2 = window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window2.HTMLFormElement, DOMParser2 = window2.DOMParser, trustedTypes = window2.trustedTypes;
  var ElementPrototype = Element2.prototype;
  var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
  var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
  var getChildNodes = lookupGetter(ElementPrototype, "childNodes");
  var getParentNode = lookupGetter(ElementPrototype, "parentNode");
  if (typeof HTMLTemplateElement === "function") {
    var template = document2.createElement("template");
    if (template.content && template.content.ownerDocument) {
      document2 = template.content.ownerDocument;
    }
  }
  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
  var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML("") : "";
  var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
  var importNode = originalDocument.importNode;
  var documentMode = {};
  try {
    documentMode = clone2(document2).documentMode ? document2.documentMode : {};
  } catch (_) {
  }
  var hooks = {};
  DOMPurify.isSupported = typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== void 0 && documentMode !== 9;
  var MUSTACHE_EXPR$1 = MUSTACHE_EXPR, ERB_EXPR$1 = ERB_EXPR, TMPLIT_EXPR$1 = TMPLIT_EXPR, DATA_ATTR$1 = DATA_ATTR, ARIA_ATTR$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
  var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
  var ALLOWED_TAGS = null;
  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text)));
  var ALLOWED_ATTR = null;
  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));
  var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  var FORBID_TAGS = null;
  var FORBID_ATTR = null;
  var ALLOW_ARIA_ATTR = true;
  var ALLOW_DATA_ATTR = true;
  var ALLOW_UNKNOWN_PROTOCOLS = false;
  var ALLOW_SELF_CLOSE_IN_ATTR = true;
  var SAFE_FOR_TEMPLATES = false;
  var WHOLE_DOCUMENT = false;
  var SET_CONFIG = false;
  var FORCE_BODY = false;
  var RETURN_DOM = false;
  var RETURN_DOM_FRAGMENT = false;
  var RETURN_TRUSTED_TYPE = false;
  var SANITIZE_DOM = true;
  var SANITIZE_NAMED_PROPS = false;
  var SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
  var KEEP_CONTENT = true;
  var IN_PLACE = false;
  var USE_PROFILES = {};
  var FORBID_CONTENTS = null;
  var DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  var DATA_URI_TAGS = null;
  var DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  var URI_SAFE_ATTRIBUTES = null;
  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
  var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
  var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
  var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  var NAMESPACE = HTML_NAMESPACE;
  var IS_EMPTY_INPUT = false;
  var ALLOWED_NAMESPACES = null;
  var DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
  var PARSER_MEDIA_TYPE;
  var SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
  var DEFAULT_PARSER_MEDIA_TYPE = "text/html";
  var transformCaseFunc;
  var CONFIG = null;
  var formElement = document2.createElement("form");
  var isRegexOrFunction = function isRegexOrFunction2(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  var _parseConfig = function _parseConfig2(cfg) {
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    if (!cfg || _typeof(cfg) !== "object") {
      cfg = {};
    }
    cfg = clone2(cfg);
    PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
    transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
    ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    ALLOWED_NAMESPACES = "ALLOWED_NAMESPACES" in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
    URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(
      clone2(DEFAULT_URI_SAFE_ATTRIBUTES),
      // eslint-disable-line indent
      cfg.ADD_URI_SAFE_ATTR,
      // eslint-disable-line indent
      transformCaseFunc
      // eslint-disable-line indent
    ) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(
      clone2(DEFAULT_DATA_URI_TAGS),
      // eslint-disable-line indent
      cfg.ADD_DATA_URI_TAGS,
      // eslint-disable-line indent
      transformCaseFunc
      // eslint-disable-line indent
    ) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
    FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
    USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
    RETURN_DOM = cfg.RETURN_DOM || false;
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
    FORCE_BODY = cfg.FORCE_BODY || false;
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
    IN_PLACE = cfg.IN_PLACE || false;
    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, _toConsumableArray(text));
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$1);
        addToSet(ALLOWED_ATTR, html);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl$1);
        addToSet(ALLOWED_ATTR, mathMl);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone2(ALLOWED_TAGS);
      }
      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone2(ALLOWED_ATTR);
      }
      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone2(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }
    if (KEEP_CONTENT) {
      ALLOWED_TAGS["#text"] = true;
    }
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
    }
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ["tbody"]);
      delete FORBID_TAGS.tbody;
    }
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
  var HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]);
  var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
  var ALL_SVG_TAGS = addToSet({}, svg$1);
  addToSet(ALL_SVG_TAGS, svgFilters);
  addToSet(ALL_SVG_TAGS, svgDisallowed);
  var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
  var _checkValidNamespace = function _checkValidNamespace2(element) {
    var parent = getParentNode(element);
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: NAMESPACE,
        tagName: "template"
      };
    }
    var tagName = stringToLowerCase(element.tagName);
    var parentTagName = stringToLowerCase(parent.tagName);
    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
      return false;
    }
    if (element.namespaceURI === SVG_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "svg";
      }
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "math";
      }
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
      }
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
      return true;
    }
    return false;
  };
  var _forceRemove = function _forceRemove2(node) {
    arrayPush(DOMPurify.removed, {
      element: node
    });
    try {
      node.parentNode.removeChild(node);
    } catch (_) {
      try {
        node.outerHTML = emptyHTML;
      } catch (_2) {
        node.remove();
      }
    }
  };
  var _removeAttribute = function _removeAttribute2(name, node) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node.getAttributeNode(name),
        from: node
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node
      });
    }
    node.removeAttribute(name);
    if (name === "is" && !ALLOWED_ATTR[name]) {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node);
        } catch (_) {
        }
      } else {
        try {
          node.setAttribute(name, "");
        } catch (_) {
        }
      }
    }
  };
  var _initDocument = function _initDocument2(dirty) {
    var doc;
    var leadingWhitespace;
    if (FORCE_BODY) {
      dirty = "<remove></remove>" + dirty;
    } else {
      var matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
    }
    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_) {
      }
    }
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, "template", null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
      } catch (_) {
      }
    }
    var body = doc.body || doc.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
    }
    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };
  var _createIterator = function _createIterator2(root) {
    return createNodeIterator.call(
      root.ownerDocument || root,
      root,
      // eslint-disable-next-line no-bitwise
      NodeFilter2.SHOW_ELEMENT | NodeFilter2.SHOW_COMMENT | NodeFilter2.SHOW_TEXT,
      null,
      false
    );
  };
  var _isClobbered = function _isClobbered2(elm) {
    return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function" || typeof elm.hasChildNodes !== "function");
  };
  var _isNode = function _isNode2(object) {
    return _typeof(Node3) === "object" ? object instanceof Node3 : object && _typeof(object) === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
  };
  var _executeHook = function _executeHook2(entryPoint, currentNode, data) {
    if (!hooks[entryPoint]) {
      return;
    }
    arrayForEach(hooks[entryPoint], function(hook) {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  };
  var _sanitizeElements = function _sanitizeElements2(currentNode) {
    var content;
    _executeHook("beforeSanitizeElements", currentNode, null);
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
      _forceRemove(currentNode);
      return true;
    }
    var tagName = transformCaseFunc(currentNode.nodeName);
    _executeHook("uponSanitizeElement", currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))
          return false;
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))
          return false;
      }
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        var parentNode = getParentNode(currentNode) || currentNode.parentNode;
        var childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          var childCount = childNodes.length;
          for (var i = childCount - 1; i >= 0; --i) {
            parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
      content = currentNode.textContent;
      content = stringReplace(content, MUSTACHE_EXPR$1, " ");
      content = stringReplace(content, ERB_EXPR$1, " ");
      content = stringReplace(content, TMPLIT_EXPR$1, " ");
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, {
          element: currentNode.cloneNode()
        });
        currentNode.textContent = content;
      }
    }
    _executeHook("afterSanitizeElements", currentNode, null);
    return false;
  };
  var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
    if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
      return false;
    }
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName))
      ;
    else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName))
      ;
    else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (
        // First condition does a very basic check if a) it's basically a valid custom element tagname AND
        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
        _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
      )
        ;
      else {
        return false;
      }
    } else if (URI_SAFE_ATTRIBUTES[lcName])
      ;
    else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
      ;
    else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag])
      ;
    else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
      ;
    else if (value) {
      return false;
    } else
      ;
    return true;
  };
  var _basicCustomElementTest = function _basicCustomElementTest2(tagName) {
    return tagName.indexOf("-") > 0;
  };
  var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
    var attr;
    var value;
    var lcName;
    var l;
    _executeHook("beforeSanitizeAttributes", currentNode, null);
    var attributes = currentNode.attributes;
    if (!attributes) {
      return;
    }
    var hookEvent = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR
    };
    l = attributes.length;
    while (l--) {
      attr = attributes[l];
      var _attr = attr, name = _attr.name, namespaceURI = _attr.namespaceURI;
      value = name === "value" ? attr.value : stringTrim(attr.value);
      lcName = transformCaseFunc(name);
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = void 0;
      _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
      value = hookEvent.attrValue;
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      _removeAttribute(name, currentNode);
      if (!hookEvent.keepAttr) {
        continue;
      }
      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (SAFE_FOR_TEMPLATES) {
        value = stringReplace(value, MUSTACHE_EXPR$1, " ");
        value = stringReplace(value, ERB_EXPR$1, " ");
        value = stringReplace(value, TMPLIT_EXPR$1, " ");
      }
      var lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }
      if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
        _removeAttribute(name, currentNode);
        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }
      if (trustedTypesPolicy && _typeof(trustedTypes) === "object" && typeof trustedTypes.getAttributeType === "function") {
        if (namespaceURI)
          ;
        else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case "TrustedHTML": {
              value = trustedTypesPolicy.createHTML(value);
              break;
            }
            case "TrustedScriptURL": {
              value = trustedTypesPolicy.createScriptURL(value);
              break;
            }
          }
        }
      }
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name, value);
        } else {
          currentNode.setAttribute(name, value);
        }
        arrayPop(DOMPurify.removed);
      } catch (_) {
      }
    }
    _executeHook("afterSanitizeAttributes", currentNode, null);
  };
  var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
    var shadowNode;
    var shadowIterator = _createIterator(fragment);
    _executeHook("beforeSanitizeShadowDOM", fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      _executeHook("uponSanitizeShadowNode", shadowNode, null);
      if (_sanitizeElements(shadowNode)) {
        continue;
      }
      if (shadowNode.content instanceof DocumentFragment2) {
        _sanitizeShadowDOM2(shadowNode.content);
      }
      _sanitizeAttributes(shadowNode);
    }
    _executeHook("afterSanitizeShadowDOM", fragment, null);
  };
  DOMPurify.sanitize = function(dirty) {
    var cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var body;
    var importedNode;
    var currentNode;
    var oldNode;
    var returnNode;
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = "<!-->";
    }
    if (typeof dirty !== "string" && !_isNode(dirty)) {
      if (typeof dirty.toString === "function") {
        dirty = dirty.toString();
        if (typeof dirty !== "string") {
          throw typeErrorCreate("dirty is not a string, aborting");
        }
      } else {
        throw typeErrorCreate("toString is not a function");
      }
    }
    if (!DOMPurify.isSupported) {
      if (_typeof(window2.toStaticHTML) === "object" || typeof window2.toStaticHTML === "function") {
        if (typeof dirty === "string") {
          return window2.toStaticHTML(dirty);
        }
        if (_isNode(dirty)) {
          return window2.toStaticHTML(dirty.outerHTML);
        }
      }
      return dirty;
    }
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    DOMPurify.removed = [];
    if (typeof dirty === "string") {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      if (dirty.nodeName) {
        var tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
        }
      }
    } else if (dirty instanceof Node3) {
      body = _initDocument("<!---->");
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
        body = importedNode;
      } else if (importedNode.nodeName === "HTML") {
        body = importedNode;
      } else {
        body.appendChild(importedNode);
      }
    } else {
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf("<") === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      body = _initDocument(dirty);
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
      }
    }
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
    while (currentNode = nodeIterator.nextNode()) {
      if (currentNode.nodeType === 3 && currentNode === oldNode) {
        continue;
      }
      if (_sanitizeElements(currentNode)) {
        continue;
      }
      if (currentNode.content instanceof DocumentFragment2) {
        _sanitizeShadowDOM(currentNode.content);
      }
      _sanitizeAttributes(currentNode);
      oldNode = currentNode;
    }
    oldNode = null;
    if (IN_PLACE) {
      return dirty;
    }
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmod) {
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
    }
    if (SAFE_FOR_TEMPLATES) {
      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, " ");
      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, " ");
      serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR$1, " ");
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function(cfg) {
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function() {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function(tag, attr, value) {
    if (!CONFIG) {
      _parseConfig({});
    }
    var lcTag = transformCaseFunc(tag);
    var lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function(entryPoint, hookFunction) {
    if (typeof hookFunction !== "function") {
      return;
    }
    hooks[entryPoint] = hooks[entryPoint] || [];
    arrayPush(hooks[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function(entryPoint) {
    if (hooks[entryPoint]) {
      return arrayPop(hooks[entryPoint]);
    }
  };
  DOMPurify.removeHooks = function(entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint] = [];
    }
  };
  DOMPurify.removeAllHooks = function() {
    hooks = {};
  };
  return DOMPurify;
}
var purify = createDOMPurify();

// node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/src/constants.js
var Constants = class {
  /**
   * Safe XML entities.
   * @type {Object}
   */
  static get safeXmlCharactersEntities() {
    return {
      tagOpener: "&laquo;",
      tagCloser: "&raquo;",
      doubleQuote: "&uml;",
      realDoubleQuote: "&quot;"
    };
  }
  /**
   * Blackboard invalid safe characters.
   * @type {Object}
   */
  static get safeBadBlackboardCharacters() {
    return {
      ltElement: "«mo»<«/mo»",
      gtElement: "«mo»>«/mo»",
      ampElement: "«mo»&«/mo»"
    };
  }
  /**
   * Blackboard valid safe characters.
   * @type{Object}
   */
  static get safeGoodBlackboardCharacters() {
    return {
      ltElement: "«mo»§lt;«/mo»",
      gtElement: "«mo»§gt;«/mo»",
      ampElement: "«mo»§amp;«/mo»"
    };
  }
  /**
   * Standard XML special characters.
   * @type {Object}
   */
  static get xmlCharacters() {
    return {
      id: "xmlCharacters",
      tagOpener: "<",
      // Hex: \x3C.
      tagCloser: ">",
      // Hex: \x3E.
      doubleQuote: '"',
      // Hex: \x22.
      ampersand: "&",
      // Hex: \x26.
      quote: "'"
      // Hex: \x27.
    };
  }
  /**
  * Safe XML special characters. This characters are used instead the standard
  * the standard to parse the  MathML if safeXML save mode is enable. Each XML
  * special character have a UTF-8 representation.
  * @type {Object}
  */
  static get safeXmlCharacters() {
    return {
      id: "safeXmlCharacters",
      tagOpener: "«",
      // Hex: \xAB.
      tagCloser: "»",
      // Hex: \xBB.
      doubleQuote: "¨",
      // Hex: \xA8.
      ampersand: "§",
      // Hex: \xA7.
      quote: "`",
      // Hex: \x60.
      realDoubleQuote: "¨"
    };
  }
};

// node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/src/mathml.js
var MathML = class _MathML {
  /**
   * Checks if the mathml at position i is inside an HTML attribute or not.
   * @param {string} content - a string containing MathML code.
   * @param {number} i -  search index.
   * @return {boolean} true if is inside an HTML attribute. false otherwise.
   */
  static isMathmlInAttribute(content, i) {
    const mathAtt = `['"][\\s]*=[\\s]*[\\w-]+`;
    const attContent = `"[^"]*"|'[^']*'`;
    const att = `[\\s]*(${attContent})[\\s]*=[\\s]*[\\w-]+[\\s]*`;
    const atts = `('${att}')*`;
    const regex = `^${mathAtt}${atts}[\\s]+gmi<`;
    const expression = new RegExp(regex);
    const actualContent = content.substring(0, i);
    const reversed = actualContent.split("").reverse().join("");
    const exists = expression.test(reversed);
    return exists;
  }
  /**
   * Decodes an encoded MathML with standard XML tags.
   * We use these entities because IE doesn't support html entities
   * on its attributes sometimes. Yes, sometimes.
   * @param {string} input - string to be decoded.
   * @return {string} decoded string.
   */
  static safeXmlDecode(input) {
    let { tagOpener } = Constants.safeXmlCharactersEntities;
    let { tagCloser } = Constants.safeXmlCharactersEntities;
    let { doubleQuote } = Constants.safeXmlCharactersEntities;
    let { realDoubleQuote } = Constants.safeXmlCharactersEntities;
    input = input.split(tagOpener).join(Constants.safeXmlCharacters.tagOpener);
    input = input.split(tagCloser).join(Constants.safeXmlCharacters.tagCloser);
    input = input.split(doubleQuote).join(Constants.safeXmlCharacters.doubleQuote);
    input = input.split(realDoubleQuote).join(Constants.safeXmlCharacters.realDoubleQuote);
    const { ltElement } = Constants.safeBadBlackboardCharacters;
    const { gtElement } = Constants.safeBadBlackboardCharacters;
    const { ampElement } = Constants.safeBadBlackboardCharacters;
    if ("_wrs_blackboard" in window && window._wrs_blackboard) {
      input = input.split(ltElement).join(Constants.safeGoodBlackboardCharacters.ltElement);
      input = input.split(gtElement).join(Constants.safeGoodBlackboardCharacters.gtElement);
      input = input.split(ampElement).join(Constants.safeGoodBlackboardCharacters.ampElement);
    }
    ({ tagOpener } = Constants.safeXmlCharacters);
    ({ tagCloser } = Constants.safeXmlCharacters);
    ({ doubleQuote } = Constants.safeXmlCharacters);
    ({ realDoubleQuote } = Constants.safeXmlCharacters);
    const { ampersand } = Constants.safeXmlCharacters;
    const { quote } = Constants.safeXmlCharacters;
    input = input.split(tagOpener).join(Constants.xmlCharacters.tagOpener);
    input = input.split(tagCloser).join(Constants.xmlCharacters.tagCloser);
    input = input.split(doubleQuote).join(Constants.xmlCharacters.doubleQuote);
    input = input.split(ampersand).join(Constants.xmlCharacters.ampersand);
    input = input.split(quote).join(Constants.xmlCharacters.quote);
    let returnValue = "";
    let currentEntity = null;
    for (let i = 0; i < input.length; i += 1) {
      const character = input.charAt(i);
      if (currentEntity == null) {
        if (character === "$") {
          currentEntity = "";
        } else {
          returnValue += character;
        }
      } else if (character === ";") {
        returnValue += `&${currentEntity}`;
        currentEntity = null;
      } else if (character.match(/([a-zA-Z0-9#._-] | '-')/)) {
        currentEntity += character;
      } else {
        returnValue += `$${currentEntity}`;
        currentEntity = null;
        i -= 1;
      }
    }
    return returnValue;
  }
  /**
   * Encodes a MathML with standard XML tags to a MMathML encoded with safe XML tags.
   * We use these entities because IE doesn't support html entities on its attributes sometimes.
   * @param {string} input - input string to be encoded
   * @returns {string} encoded string.
   */
  static safeXmlEncode(input) {
    const { tagOpener } = Constants.xmlCharacters;
    const { tagCloser } = Constants.xmlCharacters;
    const { doubleQuote } = Constants.xmlCharacters;
    const { ampersand } = Constants.xmlCharacters;
    const { quote } = Constants.xmlCharacters;
    input = input.split(tagOpener).join(Constants.safeXmlCharacters.tagOpener);
    input = input.split(tagCloser).join(Constants.safeXmlCharacters.tagCloser);
    input = input.split(doubleQuote).join(Constants.safeXmlCharacters.doubleQuote);
    input = input.split(ampersand).join(Constants.safeXmlCharacters.ampersand);
    input = input.split(quote).join(Constants.safeXmlCharacters.quote);
    return input;
  }
  /**
   * Converts special symbols (> 128) to entities and replaces all textual
   * entities by its number entities.
   * @param {string} mathml - MathML string containing - or not - special symbols
   * @returns {string} MathML with all textual entities replaced.
   */
  static mathMLEntities(mathml) {
    let toReturn = "";
    for (let i = 0; i < mathml.length; i += 1) {
      const character = mathml.charAt(i);
      if (mathml.codePointAt(i) > 128) {
        toReturn += `&#${mathml.codePointAt(i)};`;
        if (mathml.codePointAt(i) > 65535) {
          i += 1;
        }
      } else if (character === "&") {
        const end = mathml.indexOf(";", i + 1);
        if (end >= 0) {
          const container = document.createElement("span");
          container.innerHTML = mathml.substring(i, end + 1);
          toReturn += `&#${Util.fixedCharCodeAt(container.textContent || container.innerText, 0)};`;
          i = end;
        } else {
          toReturn += character;
        }
      } else {
        toReturn += character;
      }
    }
    return toReturn;
  }
  /**
   * Add a custom editor name with the prefix wrs_ to a MathML class attribute.
   * @param {string} mathml - a MathML string created with a custom editor, like chemistry.
   * @param {string} customEditor - custom editor name.
   * @returns {string} MathML string with his class containing the editor toolbar string.
   */
  static addCustomEditorClassAttribute(mathml, customEditor) {
    let toReturn = "";
    const start = mathml.indexOf("<math");
    if (start === 0) {
      const end = mathml.indexOf(">");
      if (mathml.indexOf("class") === -1) {
        toReturn = `${mathml.substr(start, end)} class="wrs_${customEditor}">`;
        toReturn += mathml.substr(end + 1, mathml.length);
        return toReturn;
      }
    }
    return mathml;
  }
  /**
   * Remove a custom editor name from the MathML class attribute.
   * @param {string} mathml - a MathML string.
   * @param {string} customEditor - custom editor name.
   * @returns {string} The input MathML without customEditor name in his class.
   */
  static removeCustomEditorClassAttribute(mathml, customEditor) {
    if (mathml.indexOf("class") === -1 || mathml.indexOf(`wrs_${customEditor}`) === -1) {
      return mathml;
    }
    if (mathml.indexOf(` class="wrs_${customEditor}"`) !== -1) {
      return mathml.replace(` class="wrs_${customEditor}"`, "");
    } else if (mathml.indexOf(`class="wrs_${customEditor}"`) !== -1) {
      return mathml.replace(`class="wrs_${customEditor}"`, "");
    }
    return mathml.replace(`wrs_${customEditor}`, "");
  }
  /**
   * Adds annotation tag in MathML element.
   * @param {String} mathml - valid MathML.
   * @param {String} content - value to put inside annotation tag.
   * @param {String} annotationEncoding - annotation encoding.
   * @returns {String} - 'mathml' with an annotation that contains
   * 'content' and encoding 'encoding'.
   */
  static addAnnotation(mathml, content, annotationEncoding) {
    const containsAnnotation = mathml.indexOf("<annotation");
    let mathmlWithAnnotation = "";
    if (containsAnnotation !== -1) {
      const closeSemanticsIndex = mathml.indexOf("</semantics>");
      mathmlWithAnnotation = `${mathml.substring(0, closeSemanticsIndex)}<annotation encoding="${annotationEncoding}">${content}</annotation>${mathml.substring(closeSemanticsIndex)}`;
    } else if (_MathML.isEmpty(mathml)) {
      const endIndexInline = mathml.indexOf("/>");
      const endIndexNonInline = mathml.indexOf(">");
      const endIndex = endIndexNonInline === endIndexInline ? endIndexInline : endIndexNonInline;
      mathmlWithAnnotation = `${mathml.substring(0, endIndex)}><semantics><annotation encoding="${annotationEncoding}">${content}</annotation></semantics></math>`;
    } else {
      const beginMathMLContent = mathml.indexOf(">") + 1;
      const endMathmlContent = mathml.lastIndexOf("</math>");
      const mathmlContent = mathml.substring(beginMathMLContent, endMathmlContent);
      mathmlWithAnnotation = `${mathml.substring(0, beginMathMLContent)}<semantics><mrow>${mathmlContent}</mrow><annotation encoding="${annotationEncoding}">${content}</annotation></semantics></math>`;
    }
    return mathmlWithAnnotation;
  }
  /**
   * Removes specific annotation tag in MathML element.
   * In case of remove the unique annotation, also is removed semantics tag.
   * @param {String} mathml - valid MathML.
   * @param {String} annotationEncoding - annotation encoding to remove.
   * @returns {String} - 'mathml' without the annotation encoding specified.
   */
  static removeAnnotation(mathml, annotationEncoding) {
    let mathmlWithoutAnnotation = mathml;
    const openAnnotationTag = `<annotation encoding="${annotationEncoding}">`;
    const closeAnnotationTag = "</annotation>";
    const startAnnotationIndex = mathml.indexOf(openAnnotationTag);
    if (startAnnotationIndex !== -1) {
      let differentAnnotationFound = false;
      let differentAnnotationIndex = mathml.indexOf("<annotation");
      while (differentAnnotationIndex !== -1) {
        if (differentAnnotationIndex !== startAnnotationIndex) {
          differentAnnotationFound = true;
        }
        differentAnnotationIndex = mathml.indexOf("<annotation", differentAnnotationIndex + 1);
      }
      if (differentAnnotationFound) {
        const closeIndex = mathml.indexOf(closeAnnotationTag, startAnnotationIndex);
        const endAnnotationIndex = closeIndex + closeAnnotationTag.length;
        const startIndex = mathml.substring(0, startAnnotationIndex);
        mathmlWithoutAnnotation = startIndex + mathml.substring(endAnnotationIndex);
      } else {
        mathmlWithoutAnnotation = _MathML.removeSemantics(mathml);
      }
    }
    return mathmlWithoutAnnotation;
  }
  /**
   * Removes semantics tag to mathml.
   * When using Hand to create formulas, it adds the mrow tag due to the semantics one, this one is also removed.
   * @param {string} mathml - MathML string.
   * @returns {string} - 'mathml' without semantics tag.
   */
  static removeSemantics(mathml) {
    const semanticsStartingTagRegex = /<semantics>\s*?(<mrow>)?/gm;
    const semanticsEndingTagRegex = /(<\/mrow>)?\s*<annotation[\W\w]*?<\/semantics>/gm;
    return mathml.replace(semanticsStartingTagRegex, "").replace(semanticsEndingTagRegex, "");
  }
  /**
   * Transforms all xml mathml occurrences that contain semantics to the same
   * xml mathml occurrences without semantics.
   * @param {string} text - string that can contain xml mathml occurrences.
   * @param {Constants} [characters] - Constant object containing xmlCharacters
   * or safeXmlCharacters relation.
   * xmlCharacters by default.
   * @returns {string} - 'text' with all xml mathml occurrences without annotation tag.
   */
  static removeSemanticsOcurrences(text2, characters = Constants.xmlCharacters) {
    const mathTagStart = `${characters.tagOpener}math`;
    const mathTagEnd = `${characters.tagOpener}/math${characters.tagCloser}`;
    const mathTagEndline = `/${characters.tagCloser}`;
    const { tagCloser } = characters;
    const semanticsTagStart = `${characters.tagOpener}semantics${characters.tagCloser}`;
    const annotationTagStart = `${characters.tagOpener}annotation encoding=`;
    let output = "";
    let start = text2.indexOf(mathTagStart);
    let end = 0;
    while (start !== -1) {
      output += text2.substring(end, start);
      const mathTagEndIndex = text2.indexOf(mathTagEnd, start);
      const mathTagEndlineIndex = text2.indexOf(mathTagEndline, start);
      const firstTagCloser = text2.indexOf(tagCloser, start);
      if (mathTagEndIndex !== -1) {
        end = mathTagEndIndex;
      } else if (mathTagEndlineIndex === firstTagCloser - 1) {
        end = mathTagEndlineIndex;
      }
      const semanticsIndex = text2.indexOf(semanticsTagStart, start);
      if (semanticsIndex !== -1) {
        const mmlTagStart = text2.substring(start, semanticsIndex);
        const annotationIndex = text2.indexOf(annotationTagStart, start);
        if (annotationIndex !== -1) {
          const startIndex = semanticsIndex + semanticsTagStart.length;
          const mmlContent = text2.substring(startIndex, annotationIndex);
          output += mmlTagStart + mmlContent + mathTagEnd;
          start = text2.indexOf(mathTagStart, start + mathTagStart.length);
          end += mathTagEnd.length;
        } else {
          end = start;
          start = text2.indexOf(mathTagStart, start + mathTagStart.length);
        }
      } else {
        end = start;
        start = text2.indexOf(mathTagStart, start + mathTagStart.length);
      }
    }
    output += text2.substring(end, text2.length);
    return output;
  }
  /**
   * Returns true if a MathML contains a certain class.
   * @param {string} mathML - input MathML.
   * @param {string} className - className.
   * @returns {boolean} true if the input MathML contains the input class.
   * false otherwise.
   * @static
   */
  static containClass(mathML, className) {
    const classIndex = mathML.indexOf("class");
    if (classIndex === -1) {
      return false;
    }
    const classTagEndIndex = mathML.indexOf(">", classIndex);
    const classTag = mathML.substring(classIndex, classTagEndIndex);
    if (classTag.indexOf(className) !== -1) {
      return true;
    }
    return false;
  }
  /**
   * Returns true if mathml is empty. Otherwise, false.
   * @param {string} mathml - valid MathML with standard XML tags.
   * @returns {boolean} - true if mathml is empty. Otherwise, false.
   */
  static isEmpty(mathml) {
    const closeTag = ">";
    const closeTagInline = "/>";
    const firstCloseTagIndex = mathml.indexOf(closeTag);
    const firstCloseTagInlineIndex = mathml.indexOf(closeTagInline);
    let empty = false;
    if (firstCloseTagInlineIndex !== -1) {
      if (firstCloseTagInlineIndex === firstCloseTagIndex - 1) {
        empty = true;
      }
    }
    if (!empty) {
      const mathTagEndRegex = new RegExp("</(.+:)?math>");
      const mathTagEndArray = mathTagEndRegex.exec(mathml);
      if (mathTagEndArray) {
        empty = firstCloseTagIndex + 1 === mathTagEndArray.index;
      }
    }
    return empty;
  }
  /**
   * Encodes html entities inside properties.
   * @param {String} mathml - valid MathML with standard XML tags.
   * @returns {String} - 'mathml' with property entities encoded.
   */
  static encodeProperties(mathml) {
    const regex = /\w+=".*?"/g;
    const replacer = (match) => {
      const quoteIndex = match.indexOf('"');
      const propertyValue = match.substring(quoteIndex + 1, match.length - 1);
      const propertyValueEncoded = Util.htmlEntities(propertyValue);
      const matchEncoded = `${match.substring(0, quoteIndex + 1)}${propertyValueEncoded}"`;
      return matchEncoded;
    };
    const mathmlEncoded = mathml.replace(regex, replacer);
    return mathmlEncoded;
  }
};

// node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/src/configuration.js
var Configuration = class _Configuration {
  /**
   * Adds a properties object to {@link Configuration.properties}.
   * @param {Object} properties - properties to append to current properties.
   */
  static addConfiguration(properties) {
    Object.assign(_Configuration.properties, properties);
  }
  /**
  * Static property.
  * The configuration properties object.
  * @private
  * @type {Object}
  */
  static get properties() {
    return _Configuration._properties;
  }
  /**
   * Static property setter.
   * Set configuration properties.
   * @param {Object} value - The property value.
   * @ignore
   */
  static set properties(value) {
    _Configuration._properties = value;
  }
  /**
   * Returns the value of a property key.
   * @param {String} key - Property key
   * @returns {String} Property value
   */
  static get(key) {
    if (!Object.prototype.hasOwnProperty.call(_Configuration.properties, key)) {
      if (Object.prototype.hasOwnProperty.call(_Configuration.properties, "_wrs_conf_")) {
        return _Configuration.properties[`_wrs_conf_${key}`];
      }
      return false;
    }
    return _Configuration.properties[key];
  }
  /**
   * Adds a new property to Configuration class.
   * @param {String} key - Property key.
   * @param {Object} value - Property value.
   */
  static set(key, value) {
    _Configuration.properties[key] = value;
  }
  /**
   * Updates a property object value with new values.
   * @param {String} key - The property key to be updated.
   * @param {Object} propertyValue - Object containing the new values.
   */
  static update(key, propertyValue) {
    if (!_Configuration.get(key)) {
      _Configuration.set(key, propertyValue);
    } else {
      const updateProperty = Object.assign(_Configuration.get(key), propertyValue);
      _Configuration.set(key, updateProperty);
    }
  }
};
Configuration._properties = {};

// node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/src/textcache.js
var TextCache = class {
  /**
   * @classdesc
   * This class represent a client-side text cache class. Contains pairs of
   * strings (key/value) which can be retrieved in any moment. Usually used
   * to store AJAX responses for text services like mathml2latex
   * (c.f {@link Latex} class) or mathml2accessible (c.f {@link Accessibility} class).
   * @constructs
   */
  constructor() {
    this.cache = [];
  }
  /**
   * This method populates a key/value pair into the {@link this.cache} property.
   * @param {String} key - Cache key, usually the service string parameter.
   * @param {String} value - Cache value, usually the service response.
   */
  populate(key, value) {
    this.cache[key] = value;
  }
  /**
   * Returns the cache value associated to certain cache key.
   * @param {String} key - Cache key, usually the service string parameter.
   * @return {String} value - Cache value, if exists. False otherwise.
   */
  get(key) {
    if (Object.prototype.hasOwnProperty.call(this.cache, key)) {
      return this.cache[key];
    }
    return false;
  }
};

// node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/src/listeners.js
var Listeners = class {
  /**
   * @classdesc
   * This class represents a custom listeners manager.
   * @constructs
   */
  constructor() {
    this.listeners = [];
  }
  /**
   * Add a listener to Listener class.
   * @param {Object} listener - A listener object.
   */
  add(listener) {
    this.listeners.push(listener);
  }
  /**
   * Fires MathType event listeners
   * @param {String} eventName - event name
   * @param {Event} event - event object.
   * @return {boolean} false if event has been prevented. true otherwise.
   */
  fire(eventName, event) {
    for (let i = 0; i < this.listeners.length && !event.cancelled; i += 1) {
      if (this.listeners[i].eventName === eventName) {
        this.listeners[i].callback(event);
      }
    }
    return event.defaultPrevented;
  }
  /**
   * Creates a new listener object.
   * @param {string} eventName - Event name.
   * @param {Object} callback - Callback function.
   * @returns {object} the listener object.
   */
  static newListener(eventName, callback) {
    const listener = {};
    listener.eventName = eventName;
    listener.callback = callback;
    return listener;
  }
};

// node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/src/serviceprovider.js
var ServiceProvider = class _ServiceProvider {
  /**
   * Returns Service Provider listeners.
   * @type {Listeners}
   */
  static get listeners() {
    return _ServiceProvider._listeners;
  }
  /**
   * Adds a {@link Listener} instance to {@link ServiceProvider} class.
   * @param {Listener} listener - Instance of {@link Listener}.
   */
  static addListener(listener) {
    _ServiceProvider.listeners.add(listener);
  }
  /**
   * Fires events in Service Provider.
   * @param {String} eventName - Event name.
   * @param {Event} event - Event object.
   */
  static fireEvent(eventName, event) {
    _ServiceProvider.listeners.fire(eventName, event);
  }
  /**
   * Service parameters.
   * @type {ServiceProviderProperties}
   *
   */
  static get parameters() {
    return _ServiceProvider._parameters;
  }
  /**
   * Service parameters.
   * @private
   * @type {ServiceProviderProperties}
   */
  static set parameters(parameters) {
    _ServiceProvider._parameters = parameters;
  }
  /**
   * Static property.
   * Return service provider paths.
   * @private
   * @type {String}
   */
  static get servicePaths() {
    return _ServiceProvider._servicePaths;
  }
  /**
   * Static property setter.
   * Set service paths.
   * @param {String} value - The property value.
   * @ignore
   */
  static set servicePaths(value) {
    _ServiceProvider._servicePaths = value;
  }
  /**
   * Adds a new service to the ServiceProvider.
   * @param {String} service - Service name.
   * @param {String} path - Service path.
   * @static
   */
  static setServicePath(service, path) {
    _ServiceProvider.servicePaths[service] = path;
  }
  /**
   * Returns the service path for a certain service.
   * @param {String} serviceName - Service name.
   * @returns {String} The service path.
   * @static
   */
  static getServicePath(serviceName) {
    return _ServiceProvider.servicePaths[serviceName];
  }
  /**
   * Static property.
   * Service provider integration path.
   * @type {String}
   */
  static get integrationPath() {
    return _ServiceProvider._integrationPath;
  }
  /**
   * Static property setter.
   * Set service provider integration path.
   * @param {String} value - The property value.
   * @ignore
   */
  static set integrationPath(value) {
    _ServiceProvider._integrationPath = value;
  }
  /**
   * Returns the server URL in the form protocol://serverName:serverPort.
   * @return {String} The client side server path.
   */
  static getServerURL() {
    const url = window.location.href;
    const arr = url.split("/");
    const result = `${arr[0]}//${arr[2]}`;
    return result;
  }
  /**
   * Inits {@link this} class. Uses {@link this.integrationPath} as
   * base path to generate all backend services paths.
   * @param {Object} parameters - Function parameters.
   * @param {String} parameters.integrationPath - Service path.
   */
  static init(parameters) {
    _ServiceProvider.parameters = parameters;
    let configurationURI = _ServiceProvider.createServiceURI("configurationjs");
    let createImageURI = _ServiceProvider.createServiceURI("createimage");
    let showImageURI = _ServiceProvider.createServiceURI("showimage");
    let getMathMLURI = _ServiceProvider.createServiceURI("getmathml");
    let serviceURI = _ServiceProvider.createServiceURI("service");
    if (_ServiceProvider.parameters.URI.indexOf("/") === 0) {
      const serverPath = _ServiceProvider.getServerURL();
      configurationURI = serverPath + configurationURI;
      showImageURI = serverPath + showImageURI;
      createImageURI = serverPath + createImageURI;
      getMathMLURI = serverPath + getMathMLURI;
      serviceURI = serverPath + serviceURI;
    }
    _ServiceProvider.setServicePath("configurationjs", configurationURI);
    _ServiceProvider.setServicePath("showimage", showImageURI);
    _ServiceProvider.setServicePath("createimage", createImageURI);
    _ServiceProvider.setServicePath("service", serviceURI);
    _ServiceProvider.setServicePath("getmathml", getMathMLURI);
    _ServiceProvider.setServicePath("configurationjs", configurationURI);
    _ServiceProvider.listeners.fire("onInit", {});
  }
  /**
   * Gets the content from an URL.
   * @param {String} url - Target URL.
   * @param {Object} [postVariables] - Object containing post variables.
   * null if a GET query should be done.
   * @returns {String} Content of the target URL.
   * @private
   * @static
   */
  static getUrl(url, postVariables) {
    const currentPath = window.location.toString().substr(0, window.location.toString().lastIndexOf("/") + 1);
    const httpRequest = Util.createHttpRequest();
    if (httpRequest) {
      if (typeof postVariables === "undefined" || typeof postVariables === "undefined") {
        httpRequest.open("GET", url, false);
      } else if (url.substr(0, 1) === "/" || url.substr(0, 7) === "http://" || url.substr(0, 8) === "https://") {
        httpRequest.open("POST", url, false);
      } else {
        httpRequest.open("POST", currentPath + url, false);
      }
      let header = Configuration.get("customHeaders");
      if (header) {
        header = header.toString();
        header.split(",").map((element) => element.trim().split("=")).forEach(([key, val]) => httpRequest.setRequestHeader(key, val));
      }
      if (typeof postVariables !== "undefined" && postVariables) {
        httpRequest.setRequestHeader("Content-type", "application/x-www-form-urlencoded; charset=UTF-8");
        httpRequest.send(Util.httpBuildQuery(postVariables));
      } else {
        httpRequest.send(null);
      }
      return httpRequest.responseText;
    }
    return "";
  }
  /**
   * Returns the response text of a certain service.
   * @param {String} service - Service name.
   * @param {String} postVariables - Post variables.
   * @param {Boolean} get - True if the request is GET instead of POST. false otherwise.
   * @returns {String} Service response text.
   */
  static getService(service, postVariables, get) {
    let response;
    if (get === true) {
      const getVariables = postVariables ? `?${postVariables}` : "";
      const serviceUrl = `${_ServiceProvider.getServicePath(service)}${getVariables}`;
      response = _ServiceProvider.getUrl(serviceUrl);
    } else {
      const serviceUrl = _ServiceProvider.getServicePath(service);
      response = _ServiceProvider.getUrl(serviceUrl, postVariables);
    }
    return response;
  }
  /**
   * Returns the server language of a certain service. The possible values
   * are: php, aspx, java and ruby.
   * This method has backward compatibility purposes.
   * @param {String} service - The configuration service.
   * @returns {String} - The server technology associated with the configuration service.
   */
  static getServerLanguageFromService(service) {
    if (service.indexOf(".php") !== -1) {
      return "php";
    }
    if (service.indexOf(".aspx") !== -1) {
      return "aspx";
    }
    if (service.indexOf("wirispluginengine") !== -1) {
      return "ruby";
    }
    return "java";
  }
  /**
   * Returns the URI associated with a certain service.
   * @param {String} service - The service name.
   * @return {String} The service path.
   */
  static createServiceURI(service) {
    const extension = _ServiceProvider.serverExtension();
    return Util.concatenateUrl(_ServiceProvider.parameters.URI, service) + extension;
  }
  static serverExtension() {
    if (_ServiceProvider.parameters.server.indexOf("php") !== -1) {
      return ".php";
    }
    if (_ServiceProvider.parameters.server.indexOf("aspx") !== -1) {
      return ".aspx";
    }
    return "";
  }
};
ServiceProvider._servicePaths = {};
ServiceProvider._integrationPath = "";
ServiceProvider._listeners = new Listeners();
ServiceProvider._parameters = {};

// node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/src/latex.js
var Latex = class _Latex {
  /**
   * Static property.
   * Return latex cache.
   * @private
   * @type {Cache}
   */
  static get cache() {
    return _Latex._cache;
  }
  /**
   * Static property setter.
   * Set latex cache.
   * @param {Cache} value - The property value.
   * @ignore
  */
  static set cache(value) {
    _Latex._cache = value;
  }
  /**
   * Converts MathML to LaTeX by calling mathml2latex service. For text services
   * we call a text service with the param mathml2latex.
   * @param {String} mathml - MathML String.
   * @return {String} LaTeX string generated by the MathML argument.
   */
  static getLatexFromMathML(mathml) {
    const mathmlWithoutSemantics = MathML.removeSemantics(mathml);
    const { cache } = _Latex;
    const data = {
      service: "mathml2latex",
      mml: mathmlWithoutSemantics
    };
    const jsonResponse = JSON.parse(ServiceProvider.getService("service", data));
    let latex = "";
    if (jsonResponse.status === "ok") {
      latex = jsonResponse.result.text;
      const latexHtmlEntitiesEncoded = Util.htmlEntities(latex);
      const mathmlWithSemantics = MathML.addAnnotation(mathml, latexHtmlEntitiesEncoded, "LaTeX");
      cache.populate(latex, mathmlWithSemantics);
    }
    return latex;
  }
  /**
   * Converts LaTeX to MathML by calling latex2mathml service. For text services
   * we call a text service with the param latex2mathml.
   * @param {String} latex - String containing a LaTeX formula.
   * @param {Boolean} includeLatexOnSemantics
   * - If true LaTeX would me included into MathML semantics.
   * @return {String} MathML string generated by the LaTeX argument.
   */
  static getMathMLFromLatex(latex, includeLatexOnSemantics) {
    const latexCache = _Latex.cache;
    if (_Latex.cache.get(latex)) {
      return _Latex.cache.get(latex);
    }
    const data = {
      service: "latex2mathml",
      latex
    };
    if (includeLatexOnSemantics) {
      data.saveLatex = "";
    }
    const jsonResponse = JSON.parse(ServiceProvider.getService("service", data));
    let output;
    if (jsonResponse.status === "ok") {
      let mathml = jsonResponse.result.text;
      mathml = mathml.split("\r").join("").split("\n").join(" ");
      if (mathml.indexOf("semantics") === -1 && mathml.indexOf("annotation") === -1) {
        const content = Util.htmlEntities(latex);
        mathml = MathML.addAnnotation(mathml, content, "LaTeX");
        output = mathml;
      } else {
        output = mathml;
      }
      if (!latexCache.get(latex)) {
        latexCache.populate(latex, mathml);
      }
    } else {
      output = `$$${latex}$$`;
    }
    return output;
  }
  /**
   * Converts all occurrences of MathML code to LaTeX.
   * The MathML code should containing <annotation encoding="LaTeX"/> to be converted.
   * @param {String} content - A string containing MathML valid code.
   * @param {Object} characters - An object containing special characters.
   * @return {String} A string containing all MathML annotated occurrences
   * replaced by the corresponding LaTeX code.
   */
  static parseMathmlToLatex(content, characters) {
    let output = "";
    const mathTagBegin = `${characters.tagOpener}math`;
    const mathTagEnd = `${characters.tagOpener}/math${characters.tagCloser}`;
    const openTarget = `${characters.tagOpener}annotation encoding=${characters.doubleQuote}LaTeX${characters.doubleQuote}${characters.tagCloser}`;
    const closeTarget = `${characters.tagOpener}/annotation${characters.tagCloser}`;
    let start = content.indexOf(mathTagBegin);
    let end = 0;
    let mathml;
    let startAnnotation;
    let closeAnnotation;
    while (start !== -1) {
      output += content.substring(end, start);
      end = content.indexOf(mathTagEnd, start);
      if (end === -1) {
        end = content.length - 1;
      } else {
        end += mathTagEnd.length;
      }
      mathml = content.substring(start, end);
      startAnnotation = mathml.indexOf(openTarget);
      if (startAnnotation !== -1) {
        startAnnotation += openTarget.length;
        closeAnnotation = mathml.indexOf(closeTarget);
        let latex = mathml.substring(startAnnotation, closeAnnotation);
        if (characters === Constants.safeXmlCharacters) {
          latex = MathML.safeXmlDecode(latex);
        }
        output += `$$${latex}$$`;
        _Latex.cache.populate(latex, mathml);
      } else {
        output += mathml;
      }
      start = content.indexOf(mathTagBegin, end);
    }
    output += content.substring(end, content.length);
    return output;
  }
  /**
   * Extracts the latex of a determined position in a text.
   * @param {Node} textNode - textNode to extract the LaTeX
   * @param {Number} caretPosition - Starting position to find LaTeX.
   * @param {Object} latexTags - Optional parameter representing tags between latex is inserted.
   * It has the 'open' attribute for the open tag and the 'close' attribute for the close tag.
   * "$$" by default.
   * @return {Object} An object with 3 keys: 'latex', 'start' and 'end'. Null if latex is not found.
   * @static
   */
  static getLatexFromTextNode(textNode, caretPosition, latexTags) {
    const defaultLatexTags = {
      open: "$$",
      close: "$$"
    };
    if (typeof latexTags === "undefined" || latexTags == null) {
      latexTags = defaultLatexTags;
    }
    let startNode = textNode;
    while (startNode.previousSibling && startNode.previousSibling.nodeType === 3) {
      startNode = startNode.previousSibling;
    }
    function getNextLatexPosition(currentNode, currentPosition, tag) {
      let position = currentNode.nodeValue.indexOf(tag, currentPosition);
      while (position === -1) {
        currentNode = currentNode.nextSibling;
        if (!currentNode) {
          return null;
        }
        position = currentNode.nodeValue ? currentNode.nodeValue.indexOf(latexTags.close) : -1;
      }
      return {
        node: currentNode,
        position
      };
    }
    function isPrevious(node, position, endNode, endPosition) {
      if (node === endNode) {
        return position <= endPosition;
      }
      while (node && node !== endNode) {
        node = node.nextSibling;
      }
      return node === endNode;
    }
    let start;
    let end = {
      node: startNode,
      position: 0
    };
    const tagLength = latexTags.open.length;
    do {
      start = getNextLatexPosition(end.node, end.position, latexTags.open);
      if (start == null || isPrevious(textNode, caretPosition, start.node, start.position)) {
        return null;
      }
      end = getNextLatexPosition(start.node, start.position + tagLength, latexTags.close);
      if (end == null) {
        return null;
      }
      end.position += tagLength;
    } while (isPrevious(end.node, end.position, textNode, caretPosition));
    let latex;
    if (start.node === end.node) {
      latex = start.node.nodeValue.substring(start.position + tagLength, end.position - tagLength);
    } else {
      const index = start.position + tagLength;
      latex = start.node.nodeValue.substring(index, start.node.nodeValue.length);
      let currentNode = start.node;
      do {
        currentNode = currentNode.nextSibling;
        if (currentNode === end.node) {
          latex += end.node.nodeValue.substring(0, end.position - tagLength);
        } else {
          latex += currentNode.nodeValue ? currentNode.nodeValue : "";
        }
      } while (currentNode !== end.node);
    }
    return {
      latex,
      startNode: start.node,
      startPosition: start.position,
      endNode: end.node,
      endPosition: end.position
    };
  }
};
Latex._cache = new TextCache();

// node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/lang/strings.json
var strings_default = {
  ar: {
    latex: "LaTeX",
    cancel: "إلغاء",
    accept: "إدراج",
    manual: "الدليل",
    insert_math: "إدراج صيغة رياضية - MathType",
    insert_chem: "إدراج صيغة كيميائية - ChemType",
    minimize: "تصغير",
    maximize: "تكبير",
    fullscreen: "ملء الشاشة",
    exit_fullscreen: "الخروج من ملء الشاشة",
    close: "إغلاق",
    mathtype: "MathType",
    title_modalwindow: "نافذة MathType مشروطة",
    close_modal_warning: "هل تريد المغادرة بالتأكيد؟ ستُفقد التغييرات التي أجريتها.",
    latex_name_label: "صيغة Latex",
    browser_no_compatible: "المستعرض غير متوافق مع تقنية AJAX. الرجاء استخدام أحدث إصدار من Mozilla Firefox.",
    error_convert_accessibility: "حدث خطأ أثناء التحويل من MathML إلى نص قابل للاستخدام.",
    exception_cross_site: "البرمجة النصية للمواقع المشتركة مسموح بها لـ HTTP فقط.",
    exception_high_surrogate: "المركّب المرتفع غير متبوع بمركّب منخفض في fixedCharCodeAt()‎",
    exception_string_length: "سلسلة غير صالحة. يجب أن يكون الطول من مضاعفات العدد 4",
    exception_key_nonobject: "Object.keys مستدعاة على غير كائن",
    exception_null_or_undefined: " هذا فارغ أو غير محدد",
    exception_not_function: " ليست دالة",
    exception_invalid_date_format: "تنسيق تاريخ غير صالح: ",
    exception_casting: "لا يمكن الصياغة ",
    exception_casting_to: " إلى "
  },
  ca: {
    latex: "LaTeX",
    cancel: "Cancel·lar",
    accept: "Inserir",
    manual: "Manual",
    insert_math: "Inserir fórmula matemàtica - MathType",
    insert_chem: "Inserir fórmula química - ChemType",
    minimize: "Minimitza",
    maximize: "Maximitza",
    fullscreen: "Pantalla completa",
    exit_fullscreen: "Sortir de la pantalla complera",
    close: "Tanca",
    mathtype: "MathType",
    title_modalwindow: " Finestra modal de MathType",
    close_modal_warning: "N'estàs segur que vols sortir? Es perdran els canvis que has fet.",
    latex_name_label: "Fórmula en Latex",
    browser_no_compatible: "El teu navegador no és compatible amb AJAX. Si us plau, usa la darrera versió de Mozilla Firefox.",
    error_convert_accessibility: "Error en convertir de MathML a text accessible.",
    exception_cross_site: "Els scripts de llocs creuats només estan permesos per HTTP.",
    exception_high_surrogate: "Subrogat alt no seguit de subrogat baix a fixedCharCodeAt()",
    exception_string_length: "Cadena invàlida. La longitud ha de ser un múltiple de 4",
    exception_key_nonobject: "Object.keys anomenat a non-object",
    exception_null_or_undefined: " això és null o no definit",
    exception_not_function: " no és una funció",
    exception_invalid_date_format: "Format de data invàlid : ",
    exception_casting: "No es pot emetre ",
    exception_casting_to: " a "
  },
  cs: {
    latex: "LaTeX",
    cancel: "Storno",
    accept: "Vložit",
    manual: "Příručka",
    insert_math: "Vložit matematický vzorec - MathType",
    insert_chem: "Vložení chemického vzorce – ChemType",
    minimize: "Minimalizovat",
    maximize: "Maximalizovat",
    fullscreen: "Celá obrazovka",
    exit_fullscreen: "Opustit režim celé obrazovky",
    close: "Zavřít",
    mathtype: "MathType",
    title_modalwindow: "Modální okno MathType",
    close_modal_warning: "Opravdu chcete okno zavřít? Provedené změny budou ztraceny.",
    latex_name_label: "Vzorec v LaTeXu",
    browser_no_compatible: "Váš prohlížeč nepodporuje technologii AJAX. Použijte nejnovější verzi prohlížeče Mozilla Firefox.",
    error_convert_accessibility: "Při převodu kódu MathML na čitelný text došlo k chybě.",
    exception_cross_site: "Skriptování mezi více servery je povoleno jen v HTTP.",
    exception_high_surrogate: "Ve funkci fixedCharCodeAt() nenásleduje po první části kódu znaku druhá část",
    exception_string_length: "Neplatný řetězec. Délka musí být násobkem 4.",
    exception_key_nonobject: "Funkce Object.keys byla použita pro prvek, který není objektem",
    exception_null_or_undefined: " hodnota je null nebo není definovaná",
    exception_not_function: " není funkce",
    exception_invalid_date_format: "Neplatný formát data: ",
    exception_casting: "Nelze přetypovat ",
    exception_casting_to: " na "
  },
  da: {
    latex: "LaTeX",
    cancel: "Annuller",
    accept: "Indsæt",
    manual: "Brugervejledning",
    insert_math: "Indsæt matematisk formel - MathType",
    insert_chem: "Indsæt en kemisk formel - ChemType",
    minimize: "Minimer",
    maximize: "Maksimer",
    fullscreen: "Fuld skærm",
    exit_fullscreen: "Afslut Fuld skærm",
    close: "Luk",
    mathtype: "MathType",
    title_modalwindow: "MathType-modalvindue",
    close_modal_warning: "Er du sikker på, du vil lukke? Dine ændringer går tabt.",
    latex_name_label: "LaTex-formel",
    browser_no_compatible: "Din browser er ikke kompatibel med AJAX-teknologi. Brug den nyeste version af Mozilla Firefox.",
    error_convert_accessibility: "Fejl under konvertering fra MathML til tilgængelig tekst.",
    exception_cross_site: "Scripts på tværs af websteder er kun tilladt for HTTP.",
    exception_high_surrogate: "Et højt erstatningstegn er ikke fulgt af et lavt erstatningstegn i fixedCharCodeAt()",
    exception_string_length: "Ugyldig streng. Længden skal være et multiplum af 4",
    exception_key_nonobject: "Object.keys kaldet ved ikke-objekt",
    exception_null_or_undefined: " dette er nul eller ikke defineret",
    exception_not_function: " er ikke en funktion",
    exception_invalid_date_format: "Ugyldigt datoformat: ",
    exception_casting: "Kan ikke beregne ",
    exception_casting_to: " til "
  },
  de: {
    latex: "LaTeX",
    cancel: "Abbrechen",
    accept: "Einfügen",
    manual: "Handbuch",
    insert_math: "Mathematische Formel einfügen - MathType",
    insert_chem: "Eine chemische Formel einfügen – ChemType",
    minimize: "Verkleinern",
    maximize: "Vergrößern",
    fullscreen: "Vollbild",
    exit_fullscreen: "Vollbild schließen",
    close: "Schließen",
    mathtype: "MathType",
    title_modalwindow: "Modales MathType-Fenster",
    close_modal_warning: "Bist du sicher, dass du das Programm verlassen willst? Alle vorgenommenen Änderungen gehen damit verloren.",
    latex_name_label: "Latex-Formel",
    browser_no_compatible: "Dein Browser ist nicht mit der AJAX-Technologie kompatibel. Verwende bitte die neueste Version von Mozilla Firefox.",
    error_convert_accessibility: "Fehler beim Konvertieren von MathML in barrierefreien Text.",
    exception_cross_site: "Cross-Site-Scripting ist nur bei HTTP zulässig.",
    exception_high_surrogate: "Hoher Ersatz bei bei festerZeichenkodierungbei() nicht von niedrigem Ersatz befolgt.",
    exception_string_length: "Ungültige Zeichenfolge. Länge muss ein Vielfaches von 4 sein.",
    exception_key_nonobject: "Object.keys wurde für ein Nicht-Objekt aufgerufen.",
    exception_null_or_undefined: " Das ist Null oder nicht definiert.",
    exception_not_function: " ist keine Funktion",
    exception_invalid_date_format: "Ungültiges Datumsformat: ",
    exception_casting: "Umwandlung nicht möglich ",
    exception_casting_to: " zu "
  },
  el: {
    latex: "LaTeX",
    cancel: "Άκυρο",
    accept: "Εισαγωγή",
    manual: "Χειροκίνητα",
    insert_math: "Εισαγωγή μαθηματικού τύπου - MathType",
    insert_chem: "Εισαγωγή χημικού τύπου - ChemType",
    minimize: "Ελαχιστοποίηση",
    maximize: "Μεγιστοποίηση",
    fullscreen: "Πλήρης οθόνη",
    exit_fullscreen: "Έξοδος από πλήρη οθόνη",
    close: "Κλείσιμο",
    mathtype: "MathType",
    title_modalwindow: "Τροπικό παράθυρο MathType",
    close_modal_warning: "Επιθυμείτε σίγουρα αποχώρηση; Θα χαθούν οι αλλαγές που έχετε κάνει.",
    latex_name_label: "Τύπος LaTeX",
    browser_no_compatible: "Το πρόγραμμα περιήγησής σας δεν είναι συμβατό με την τεχνολογία AJAX. Χρησιμοποιήστε την πιο πρόσφατη έκδοση του Mozilla Firefox.",
    error_convert_accessibility: "Σφάλμα κατά τη μετατροπή από MathML σε προσβάσιμο κείμενο.",
    exception_cross_site: "Το XSS (Cross site scripting) επιτρέπεται μόνο για HTTP.",
    exception_high_surrogate: "Το υψηλό υποκατάστατο δεν ακολουθείται από χαμηλό υποκατάστατο στο fixedCharCodeAt()",
    exception_string_length: "Μη έγκυρη συμβολοσειρά. Το μήκος πρέπει να είναι πολλαπλάσιο του 4",
    exception_key_nonobject: "Έγινε κλήση του Object.keys σε μη αντικείμενο",
    exception_null_or_undefined: " αυτό είναι μηδενικό ή δεν έχει οριστεί",
    exception_not_function: " δεν είναι συνάρτηση",
    exception_invalid_date_format: "Μη έγκυρη μορφή ημερομηνίας: ",
    exception_casting: "Δεν είναι δυνατή η μετατροπή ",
    exception_casting_to: " σε "
  },
  en: {
    latex: "LaTeX",
    cancel: "Cancel",
    accept: "Insert",
    manual: "Manual",
    insert_math: "Insert a math equation - MathType",
    insert_chem: "Insert a chemistry formula - ChemType",
    minimize: "Minimize",
    maximize: "Maximize",
    fullscreen: "Full-screen",
    exit_fullscreen: "Exit full-screen",
    close: "Close",
    mathtype: "MathType",
    title_modalwindow: "MathType modal window",
    close_modal_warning: "Are you sure you want to leave? The changes you made will be lost.",
    latex_name_label: "Latex Formula",
    browser_no_compatible: "Your browser is not compatible with AJAX technology. Please, use the latest version of Mozilla Firefox.",
    error_convert_accessibility: "Error converting from MathML to accessible text.",
    exception_cross_site: "Cross site scripting is only allowed for HTTP.",
    exception_high_surrogate: "High surrogate not followed by low surrogate in fixedCharCodeAt()",
    exception_string_length: "Invalid string. Length must be a multiple of 4",
    exception_key_nonobject: "Object.keys called on non-object",
    exception_null_or_undefined: " this is null or not defined",
    exception_not_function: " is not a function",
    exception_invalid_date_format: "Invalid date format : ",
    exception_casting: "Cannot cast ",
    exception_casting_to: " to "
  },
  es: {
    latex: "LaTeX",
    cancel: "Cancelar",
    accept: "Insertar",
    manual: "Manual",
    insert_math: "Insertar fórmula matemática - MathType",
    insert_chem: "Insertar fórmula química - ChemType",
    minimize: "Minimizar",
    maximize: "Maximizar",
    fullscreen: "Pantalla completa",
    exit_fullscreen: "Salir de pantalla completa",
    close: "Cerrar",
    mathtype: "MathType",
    title_modalwindow: "Ventana modal de MathType",
    close_modal_warning: "Seguro que quieres cerrar? Los cambios que has hecho se perderán",
    latex_name_label: "Formula en Latex",
    browser_no_compatible: "Tu navegador no es complatible con AJAX. Por favor, usa la última version de Mozilla Firefox.",
    error_convert_accessibility: "Error conviertiendo una fórmula MathML a texto accesible.",
    exception_cross_site: "Cross site scripting solo está permitido para HTTP.",
    exception_high_surrogate: "Subrogado alto no seguido por subrogado bajo en fixedCharCodeAt()",
    exception_string_length: "Cadena no válida. La longitud debe ser múltiplo de 4",
    exception_key_nonobject: "Object.keys called on non-object",
    exception_null_or_undefined: " esto es null o no definido",
    exception_not_function: " no es una función",
    exception_invalid_date_format: "Formato de fecha inválido: ",
    exception_casting: "No se puede emitir",
    exception_casting_to: " a "
  },
  et: {
    latex: "LaTeX",
    cancel: "Loobu",
    accept: "Lisa",
    manual: "Käsiraamat",
    insert_math: "Lisa matemaatiline valem – WIRIS",
    insert_chem: "Lisa keemiline valem – ChemType",
    minimize: "Minimeeri",
    maximize: "Maksimeeri",
    fullscreen: "Täiskuva",
    exit_fullscreen: "Välju täiskuvalt",
    close: "Sule",
    mathtype: "MathType",
    title_modalwindow: "MathType'i modaalaken",
    close_modal_warning: "Kas soovite kindlasti lahkuda? Tehtud muudatused lähevad kaduma.",
    latex_name_label: "Latexi valem",
    browser_no_compatible: "Teie brauser ei ühildu AJAXi tehnoloogiaga. Palun kasutage Mozilla Firefoxi uusimat versiooni.",
    error_convert_accessibility: "Tõrge teisendamisel MathML-ist muudetavaks tekstiks.",
    exception_cross_site: "Ristskriptimine on lubatud ainult HTTP kasutamisel.",
    exception_high_surrogate: "Funktsioonis fixedCharCodeAt() ei järgne kõrgemale asendusliikmele madalam asendusliige.",
    exception_string_length: "Vigane string. Pikkus peab olema 4 kordne.",
    exception_key_nonobject: "Protseduur Object.keys kutsuti mitteobjekti korral.",
    exception_null_or_undefined: " see on null või määramata",
    exception_not_function: " ei ole funktsioon",
    exception_invalid_date_format: "Sobimatu kuupäeva kuju: ",
    exception_casting: "Esitamine ei õnnestu ",
    exception_casting_to: " – "
  },
  eu: {
    latex: "LaTeX",
    cancel: "Ezeztatu",
    accept: "Txertatu",
    manual: "Gida",
    insert_math: "Txertatu matematikako formula - MathType",
    insert_chem: "Txertatu formula kimiko bat - ChemType",
    minimize: "Ikonotu",
    maximize: "Maximizatu",
    fullscreen: "Pantaila osoa",
    exit_fullscreen: "Irten pantaila osotik",
    close: "Itxi",
    mathtype: "MathType",
    title_modalwindow: "MathType leiho modala",
    close_modal_warning: "Ziur irten nahi duzula? Egiten dituzun aldaketak galdu egingo dira.",
    latex_name_label: "LaTex Formula",
    browser_no_compatible: "Zure arakatzailea ez da bateragarria AJAX teknologiarekin. Erabili Mozilla Firefoxen azken bertsioa.",
    error_convert_accessibility: "Errorea MathMLtik testu irisgarrira bihurtzean.",
    exception_cross_site: "Gune arteko scriptak HTTPrako soilik onartzen dira.",
    exception_high_surrogate: "Ordezko baxuak ez dio ordezko altuari jarraitzen, hemen: fixedCharCodeAt()",
    exception_string_length: "Kate baliogabea. Luzerak 4ren multiploa izan behar du",
    exception_key_nonobject: "Object.keys deitu zaio objektua ez den zerbaiti",
    exception_null_or_undefined: " nulua edo definitu gabea da",
    exception_not_function: " ez da funtzio bat",
    exception_invalid_date_format: "Data-formatu baliogabea : ",
    exception_casting: "Ezin da igorri ",
    exception_casting_to: " honi "
  },
  fi: {
    latex: "LaTeX",
    cancel: "Peruuta",
    accept: "Lisää",
    manual: "Manual",
    insert_math: "Liitä matemaattinen kaava - MathType",
    insert_chem: "Lisää kemian kaava - ChemType",
    minimize: "Pienennä",
    maximize: "Suurenna",
    fullscreen: "Koko ruutu",
    exit_fullscreen: "Poistu koko ruudun tilasta",
    close: "Sulje",
    mathtype: "MathType",
    title_modalwindow: "MathTypen modaalinen ikkuna",
    close_modal_warning: "Oletko varma, että haluat poistua? Menetät tekemäsi muutokset.",
    latex_name_label: "Latex-kaava",
    browser_no_compatible: "Selaimesi ei tue AJAX-tekniikkaa. Ole hyvä ja käytä uusinta Firefox-versiota.",
    error_convert_accessibility: "Virhe muunnettaessa MathML:stä tekstiksi.",
    exception_cross_site: "Cross site scripting sallitaan vain HTTP:llä.",
    exception_high_surrogate: "fixedCharCodeAt(): yläsijaismerkkiä ei seurannut alasijaismerkki",
    exception_string_length: "Epäkelpo merkkijono. Pituuden on oltava 4:n kerrannainen",
    exception_key_nonobject: "Object.keys kutsui muuta kuin oliota",
    exception_null_or_undefined: " tämä on null tai ei määritelty",
    exception_not_function: " ei ole funktio",
    exception_invalid_date_format: "Virheellinen päivämäärämuoto : ",
    exception_casting: "Ei voida muuntaa tyyppiä ",
    exception_casting_to: " tyyppiin "
  },
  fr: {
    latex: "LaTeX",
    cancel: "Annuler",
    accept: "Insérer",
    manual: "Manuel",
    insert_math: "Insérer une formule mathématique - MathType",
    insert_chem: "Insérer une formule chimique - ChemType",
    minimize: "Minimiser",
    maximize: "Maximiser",
    fullscreen: "Plein écran",
    exit_fullscreen: "Quitter le plein écran",
    close: "Fermer",
    mathtype: "MathType",
    title_modalwindow: "Fenêtre modale MathType",
    close_modal_warning: "Confirmez-vous vouloir fermer ? Les changements effectués seront perdus.",
    latex_name_label: "Formule LaTeX",
    browser_no_compatible: "Votre navigateur n’est pas compatible avec la technologie AJAX. Veuillez utiliser la dernière version de Mozilla Firefox.",
    error_convert_accessibility: "Une erreur de conversion du format MathML en texte accessible est survenue.",
    exception_cross_site: "Le cross-site scripting n’est autorisé que pour HTTP.",
    exception_high_surrogate: "Substitut élevé non suivi d’un substitut inférieur dans fixedCharCodeAt()",
    exception_string_length: "Chaîne non valide. Longueur limitée aux multiples de 4",
    exception_key_nonobject: "Object.keys appelé sur un non-objet",
    exception_null_or_undefined: " nul ou non défini",
    exception_not_function: " n’est pas une fonction",
    exception_invalid_date_format: "Format de date non valide : ",
    exception_casting: "Impossible de convertir ",
    exception_casting_to: " sur "
  },
  gl: {
    latex: "LaTeX",
    cancel: "Cancelar",
    accept: "Inserir",
    manual: "Manual",
    insert_math: "Inserir unha fórmula matemática - MathType",
    insert_chem: "Inserir unha fórmula química - ChemType",
    minimize: "Minimizar",
    maximize: "Maximizar",
    fullscreen: "Pantalla completa",
    exit_fullscreen: "Saír da pantalla completa",
    close: "Pechar",
    mathtype: "MathType",
    title_modalwindow: "Ventá modal de MathType",
    close_modal_warning: "Seguro que quere saír? Perderanse os cambios realizados.",
    latex_name_label: "Fórmula Latex",
    browser_no_compatible: "O seu explorador non é compatible coa tecnoloxía AJAX. Use a versión máis recente de Mozilla Firefox.",
    error_convert_accessibility: "Erro ao converter de MathML a texto accesible.",
    exception_cross_site: "Os scripts de sitios só se permiten para HTTP.",
    exception_high_surrogate: "Suplente superior non seguido por suplente inferior en fixedCharCodeAt()",
    exception_string_length: "Cadea non válida. A lonxitude debe ser un múltiplo de 4",
    exception_key_nonobject: "Claves de obxecto chamadas en non obxecto",
    exception_null_or_undefined: " nulo ou non definido",
    exception_not_function: " non é unha función",
    exception_invalid_date_format: "Formato de data non válido: ",
    exception_casting: "Non se pode converter ",
    exception_casting_to: " a "
  },
  he: {
    latex: "LaTeX",
    cancel: "ביטול",
    accept: "עדכון",
    manual: "ידני",
    insert_math: "הוספת נוסחה מתמטית - MathType",
    insert_chem: "הוספת כתיבה כימית - ChemType",
    minimize: "מזערי",
    maximize: "מרבי",
    fullscreen: "מסך מלא",
    exit_fullscreen: "יציאה ממצב מסך מלא",
    close: "סגירה",
    mathtype: "MathType",
    title_modalwindow: "חלון מודאלי של MathType",
    close_modal_warning: "האם לצאת? שינויים אשר בוצעו ימחקו.",
    latex_name_label: "נוסחת Latex",
    browser_no_compatible: "הדפדפן שלך אינו תואם לטכנולוגיית AJAX. יש להשתמש בגרסה העדכנית ביותר של Mozilla Firefox.",
    error_convert_accessibility: "שגיאה בהמרה מ-MathML לטקסט נגיש.",
    exception_cross_site: "סקריפטינג חוצה-אתרים מורשה עבור HTTP בלבד.",
    exception_high_surrogate: "ערך ממלא מקום גבוה אינו מופיע אחרי ערך ממלא מקום נמוך ב-fixedCharCodeAt()‎",
    exception_string_length: "מחרוזת לא חוקית. האורך חייב להיות כפולה של 4",
    exception_key_nonobject: "בוצעה קריאה אל Object.keys ברכיב שאינו אובייקט",
    exception_null_or_undefined: " הוא Null או לא מוגדר",
    exception_not_function: "איננה פונקציה",
    exception_invalid_date_format: "תסדיר תאריך אינו תקין : ",
    exception_casting: "לא ניתן להמיר ",
    exception_casting_to: " ל "
  },
  hr: {
    latex: "LaTeX",
    cancel: "Poništi",
    accept: "Umetni",
    manual: "Priručnik",
    insert_math: "Umetnite matematičku formulu - MathType",
    insert_chem: "Umetnite kemijsku formulu - ChemType",
    minimize: "Minimiziraj",
    maximize: "Maksimiziraj",
    fullscreen: "Cijeli zaslon",
    exit_fullscreen: "Izlaz iz prikaza na cijelom zaslonu",
    close: "Zatvori",
    mathtype: "MathType",
    title_modalwindow: "MathType modalni prozor",
    close_modal_warning: "Sigurno želite zatvoriti? Izgubit će se unesene promjene.",
    latex_name_label: "Latex formula",
    browser_no_compatible: "Vaš preglednik nije kompatibilan s AJAX tehnologijom. Upotrijebite najnoviju verziju Mozilla Firefoxa.",
    error_convert_accessibility: "Pogreška konverzije iz MathML-a u dostupni tekst.",
    exception_cross_site: "Skriptiranje na različitim web-mjestima dopušteno je samo za HTTP.",
    exception_high_surrogate: "Iza visoke zamjene ne slijedi niska zamjena u fixedCharCodeAt()",
    exception_string_length: "Nevažeći niz. Duljina mora biti višekratnik broja 4",
    exception_key_nonobject: "Object.keys pozvano na ne-objekt",
    exception_null_or_undefined: " ovo je nula ili nije definirano",
    exception_not_function: " nije funkcija",
    exception_invalid_date_format: "Nevažeći format datuma : ",
    exception_casting: "Ne može se poslati ",
    exception_casting_to: " na "
  },
  hu: {
    latex: "LaTeX",
    cancel: "Mégsem",
    accept: "Beszúrás",
    manual: "Kézikönyv",
    insert_math: "Matematikai képlet beszúrása - MathType",
    insert_chem: "Kémiai képet beillesztése - ChemType",
    minimize: "Kis méret",
    maximize: "Nagy méret",
    fullscreen: "Teljes képernyő",
    exit_fullscreen: "Teljes képernyő elhagyása",
    close: "Bezárás",
    mathtype: "MathType",
    title_modalwindow: "MathType modális ablak",
    close_modal_warning: "Biztosan kilép? A módosítások el fognak veszni.",
    latex_name_label: "Latex képlet",
    browser_no_compatible: "A böngészője nem kompatibilis az AJAX technológiával. Használja a Mozilla Firefox legújabb verzióját.",
    error_convert_accessibility: "Hiba lépett fel a MathML szöveggé történő konvertálása során.",
    exception_cross_site: "Az oldalak közti scriptelés csak HTTP esetén engedélyezett.",
    exception_high_surrogate: "A magas helyettesítő karaktert nem alacsony helyettesítő karakter követi a fixedCharCodeAt() esetében",
    exception_string_length: "Érvénytelen karakterlánc. A hossznak a 4 többszörösének kell lennie",
    exception_key_nonobject: "Az Object.keys egy nem objektumra került meghívásra",
    exception_null_or_undefined: " null vagy nem definiált",
    exception_not_function: " nem függvény",
    exception_invalid_date_format: "Érvénytelen dátumformátum: ",
    exception_casting: "Nem alkalmazható ",
    exception_casting_to: " erre "
  },
  id: {
    latex: "LaTeX",
    cancel: "Membatalkan",
    accept: "Masukkan",
    manual: "Manual",
    insert_math: "Masukkan rumus matematika - MathType",
    insert_chem: "Masukkan rumus kimia - ChemType",
    minimize: "Minikan",
    maximize: "Perbesar",
    fullscreen: "Layar penuh",
    exit_fullscreen: "Keluar layar penuh",
    close: "Tutup",
    mathtype: "MathType",
    title_modalwindow: "Jendela modal MathType",
    close_modal_warning: "Anda yakin ingin keluar? Anda akan kehilangan perubahan yang Anda buat.",
    latex_name_label: "Rumus Latex",
    browser_no_compatible: "Penjelajah Anda tidak kompatibel dengan teknologi AJAX. Harap gunakan Mozilla Firefox versi terbaru.",
    error_convert_accessibility: "Kesalahan konversi dari MathML menjadi teks yang dapat diakses.",
    exception_cross_site: "Skrip lintas situs hanya diizinkan untuk HTTP.",
    exception_high_surrogate: "Pengganti tinggi tidak diikuti oleh pengganti rendah di fixedCharCodeAt()",
    exception_string_length: "String tidak valid. Panjang harus kelipatan 4",
    exception_key_nonobject: "Object.keys meminta nonobjek",
    exception_null_or_undefined: " ini tidak berlaku atau tidak didefinisikan",
    exception_not_function: " bukan sebuah fungsi",
    exception_invalid_date_format: "Format tanggal tidak valid : ",
    exception_casting: "Tidak dapat mentransmisikan ",
    exception_casting_to: " untuk "
  },
  it: {
    latex: "LaTeX",
    cancel: "Annulla",
    accept: "Inserisci",
    manual: "Manuale",
    insert_math: "Inserisci una formula matematica - MathType",
    insert_chem: "Inserisci una formula chimica - ChemType",
    minimize: "Riduci a icona",
    maximize: "Ingrandisci",
    fullscreen: "Schermo intero",
    exit_fullscreen: "Esci da schermo intero",
    close: "Chiudi",
    mathtype: "MathType",
    title_modalwindow: "Finestra modale di MathType",
    close_modal_warning: "Confermi di voler uscire? Le modifiche effettuate andranno perse.",
    latex_name_label: "Formula LaTeX",
    browser_no_compatible: "Il tuo browser non è compatibile con la tecnologia AJAX. Utilizza la versione più recente di Mozilla Firefox.",
    error_convert_accessibility: "Errore durante la conversione da MathML in testo accessibile.",
    exception_cross_site: "Lo scripting tra siti è consentito solo per HTTP.",
    exception_high_surrogate: "Surrogato alto non seguito da surrogato basso in fixedCharCodeAt()",
    exception_string_length: "Stringa non valida. La lunghezza deve essere un multiplo di 4",
    exception_key_nonobject: "Metodo Object.keys richiamato in un elemento non oggetto",
    exception_null_or_undefined: " questo è un valore null o non definito",
    exception_not_function: " non è una funzione",
    exception_invalid_date_format: "Formato di data non valido: ",
    exception_casting: "Impossibile eseguire il cast ",
    exception_casting_to: " a "
  },
  ja: {
    latex: "LaTeX",
    cancel: "キャンセル",
    accept: "挿入",
    manual: "マニュアル",
    insert_math: "数式を挿入 - MathType",
    insert_chem: "化学式を挿入 - ChemType",
    minimize: "最小化",
    maximize: "最大化",
    fullscreen: "全画面表示",
    exit_fullscreen: "全画面表示を解除",
    close: "閉じる",
    mathtype: "MathType",
    title_modalwindow: "MathType モードウィンドウ",
    close_modal_warning: "このページから移動してもよろしいですか？変更内容は失われます。",
    latex_name_label: "LaTeX 数式",
    browser_no_compatible: "お使いのブラウザは、AJAX 技術と互換性がありません。Mozilla Firefox の最新バージョンをご使用ください。",
    error_convert_accessibility: "MathML からアクセシブルなテキストへの変換中にエラーが発生しました。",
    exception_cross_site: "クロスサイトスクリプティングは、HTTP のみに許可されています。",
    exception_high_surrogate: "fixedCharCodeAt（）で上位サロゲートの後に下位サロゲートがありません",
    exception_string_length: "無効な文字列です。長さは4の倍数である必要があります",
    exception_key_nonobject: "Object.keys が非オブジェクトで呼び出されました",
    exception_null_or_undefined: " null であるか、定義されていません",
    exception_not_function: " は関数ではありません",
    exception_invalid_date_format: "無効な日付形式: ",
    exception_casting: "次にキャスト ",
    exception_casting_to: " できません "
  },
  ko: {
    latex: "LaTeX",
    cancel: "취소",
    accept: "삽입",
    manual: "설명서",
    insert_math: "수학 공식 삽입 - MathType",
    insert_chem: "화학 공식 입력하기 - ChemType",
    minimize: "최소화",
    maximize: "최대화",
    fullscreen: "전체 화면",
    exit_fullscreen: "전체 화면 나가기",
    close: "닫기",
    mathtype: "MathType",
    title_modalwindow: "MathType 모달 창",
    close_modal_warning: "정말로 나가시겠습니까? 변경 사항이 손실됩니다.",
    latex_name_label: "Latex 공식",
    browser_no_compatible: "사용자의 브라우저는 AJAX 기술과 호환되지 않습니다. Mozilla Firefox 최신 버전을 사용하십시오.",
    error_convert_accessibility: "MathML로부터 접근 가능한 텍스트로 오류 변환.",
    exception_cross_site: "사이트 교차 스크립팅은 HTTP 환경에서만 사용할 수 있습니다.",
    exception_high_surrogate: "fixedCharCodeAt()에서는 상위 서러게이트 뒤에 하위 서러게이트가 붙지 않습니다",
    exception_string_length: "유효하지 않은 스트링입니다. 길이는 4의 배수여야 합니다",
    exception_key_nonobject: "Object.keys가 non-object를 요청하였습니다",
    exception_null_or_undefined: " Null값이거나 정의되지 않았습니다",
    exception_not_function: " 함수가 아닙니다",
    exception_invalid_date_format: "유효하지 않은 날짜 포맷 : ",
    exception_casting: "캐스팅할 수 없습니다 ",
    exception_casting_to: " (으)로 "
  },
  nl: {
    latex: "LaTeX",
    cancel: "Annuleren",
    insert_chem: "Een scheikundige formule invoegen - ChemType",
    minimize: "Minimaliseer",
    maximize: "Maximaliseer",
    fullscreen: "Schermvullend",
    exit_fullscreen: "Verlaat volledig scherm",
    close: "Sluit",
    mathtype: "MathType",
    title_modalwindow: "Modaal venster MathType",
    close_modal_warning: "Weet je zeker dat je de app wilt sluiten? De gemaakte wijzigingen gaan verloren.",
    latex_name_label: "LaTeX-formule",
    browser_no_compatible: "Je browser is niet compatibel met AJAX-technologie. Gebruik de meest recente versie van Mozilla Firefox.",
    error_convert_accessibility: "Fout bij conversie van MathML naar toegankelijke tekst.",
    exception_cross_site: "Cross-site scripting is alleen toegestaan voor HTTP.",
    exception_high_surrogate: "Hoog surrogaat niet gevolgd door laag surrogaat in fixedCharCodeAt()",
    exception_string_length: "Ongeldige tekenreeks. Lengte moet een veelvoud van 4 zijn",
    exception_key_nonobject: "Object.keys opgeroepen voor niet-object",
    exception_null_or_undefined: " dit is nul of niet gedefinieerd",
    exception_not_function: " is geen functie",
    exception_invalid_date_format: "Ongeldige datumnotatie: ",
    exception_casting: "Kan niet weergeven ",
    exception_casting_to: " op "
  },
  no: {
    latex: "LaTeX",
    cancel: "Avbryt",
    accept: "Set inn",
    manual: "Håndbok",
    insert_math: "Sett inn matematikkformel - MathType",
    insert_chem: "Set inn ein kjemisk formel – ChemType",
    minimize: "Minimer",
    maximize: "Maksimer",
    fullscreen: "Fullskjerm",
    exit_fullscreen: "Avslutt fullskjerm",
    close: "Lukk",
    mathtype: "MathType",
    title_modalwindow: "Modalt MathType-vindu",
    close_modal_warning: "Er du sikker på at du vil gå ut? Endringane du har gjort, vil gå tapt.",
    latex_name_label: "LaTeX-formel",
    browser_no_compatible: "Nettlesaren er ikkje kompatibel med AJAX-teknologien. Bruk den nyaste versjonen av Mozilla Firefox.",
    error_convert_accessibility: "Feil under konvertering frå MathML til tilgjengeleg tekst.",
    exception_cross_site: "Skripting på tvers av nettstadar er bere tillaten med HTTP.",
    exception_high_surrogate: "Høgt surrogat er ikkje etterfølgt av lågt surrogat i fixedCharCodeAt()",
    exception_string_length: "Ugyldig streng. Lengda må vera deleleg på 4",
    exception_key_nonobject: "Object.keys kalla på eit ikkje-objekt",
    exception_null_or_undefined: " dette er null eller ikkje definert",
    exception_not_function: " er ikkje ein funksjon",
    exception_invalid_date_format: "Ugyldig datoformat: ",
    exception_casting: "Kan ikkje bruka casting ",
    exception_casting_to: " til "
  },
  nb: {
    latex: "LaTeX",
    cancel: "Avbryt",
    accept: "Insert",
    manual: "Håndbok",
    insert_math: "Sett inn matematikkformel - MathType",
    insert_chem: "Sett inn en kjemisk formel – ChemType",
    minimize: "Minimer",
    maximize: "Maksimer",
    fullscreen: "Fullskjerm",
    exit_fullscreen: "Avslutt fullskjerm",
    close: "Lukk",
    mathtype: "MathType",
    title_modalwindow: "Modalt MathType-vindu",
    close_modal_warning: "Er du sikker på at du vil gå ut? Endringene du har gjort, vil gå tapt.",
    latex_name_label: "LaTeX-formel",
    browser_no_compatible: "Nettleseren er ikke kompatibel med AJAX-teknologien. Bruk den nyeste versjonen av Mozilla Firefox.",
    error_convert_accessibility: "Feil under konvertering fra MathML til tilgjengelig tekst.",
    exception_cross_site: "Skripting på tvers av nettsteder er bare tillatt med HTTP.",
    exception_high_surrogate: "Høyt surrogat etterfølges ikke av lavt surrogat i fixedCharCodeAt()",
    exception_string_length: "Ugyldig streng. Lengden må være delelig på 4",
    exception_key_nonobject: "Object.keys kalte på et ikke-objekt",
    exception_null_or_undefined: " dette er null eller ikke definert",
    exception_not_function: " er ikke en funksjon",
    exception_invalid_date_format: "Ugyldig datoformat: ",
    exception_casting: "Kan ikke bruke casting ",
    exception_casting_to: " til "
  },
  nn: {
    latex: "LaTeX",
    cancel: "Avbryt",
    accept: "Set inn",
    manual: "Håndbok",
    insert_math: "Sett inn matematikkformel - MathType",
    insert_chem: "Set inn ein kjemisk formel – ChemType",
    minimize: "Minimer",
    maximize: "Maksimer",
    fullscreen: "Fullskjerm",
    exit_fullscreen: "Avslutt fullskjerm",
    close: "Lukk",
    mathtype: "MathType",
    title_modalwindow: "Modalt MathType-vindu",
    close_modal_warning: "Er du sikker på at du vil gå ut? Endringane du har gjort, vil gå tapt.",
    latex_name_label: "LaTeX-formel",
    browser_no_compatible: "Nettlesaren er ikkje kompatibel med AJAX-teknologien. Bruk den nyaste versjonen av Mozilla Firefox.",
    error_convert_accessibility: "Feil under konvertering frå MathML til tilgjengeleg tekst.",
    exception_cross_site: "Skripting på tvers av nettstadar er bere tillaten med HTTP.",
    exception_high_surrogate: "Høgt surrogat er ikkje etterfølgt av lågt surrogat i fixedCharCodeAt()",
    exception_string_length: "Ugyldig streng. Lengda må vera deleleg på 4",
    exception_key_nonobject: "Object.keys kalla på eit ikkje-objekt",
    exception_null_or_undefined: " dette er null eller ikkje definert",
    exception_not_function: " er ikkje ein funksjon",
    exception_invalid_date_format: "Ugyldig datoformat: ",
    exception_casting: "Kan ikkje bruka casting ",
    exception_casting_to: " til "
  },
  pl: {
    latex: "LaTeX",
    cancel: "Anuluj",
    accept: "Wstaw",
    manual: "Instrukcja",
    insert_math: "Wstaw formułę matematyczną - MathType",
    insert_chem: "Wstaw wzór chemiczny — ChemType",
    minimize: "Minimalizuj",
    maximize: "Maksymalizuj",
    fullscreen: "Pełny ekran",
    exit_fullscreen: "Opuść tryb pełnoekranowy",
    close: "Zamknij",
    mathtype: "MathType",
    title_modalwindow: "Okno modalne MathType",
    close_modal_warning: "Czy na pewno chcesz zamknąć? Wprowadzone zmiany zostaną utracone.",
    latex_name_label: "Wzór Latex",
    browser_no_compatible: "Twoja przeglądarka jest niezgodna z technologią AJAX Użyj najnowszej wersji Mozilla Firefox.",
    error_convert_accessibility: "Błąd podczas konwertowania z formatu MathML na dostępny tekst.",
    exception_cross_site: "Krzyżowanie skryptów witryny jest dozwolone tylko dla HTTP.",
    exception_high_surrogate: "Brak niskiego surogatu po wysokim surogacie w fixedCharCodeAt()",
    exception_string_length: "Niewłaściwy ciąg znaków. Długość musi być wielokrotnością liczby 4.",
    exception_key_nonobject: "Argumentem wywołanej funkcji Object.key nie jest obiekt.",
    exception_null_or_undefined: " jest zerowy lub niezdefiniowany",
    exception_not_function: " nie jest funkcją",
    exception_invalid_date_format: "Nieprawidłowy format daty: ",
    exception_casting: "Nie można rzutować ",
    exception_casting_to: " na "
  },
  pt: {
    latex: "LaTeX",
    cancel: "Cancelar",
    accept: "Inserir",
    manual: "Manual",
    insert_math: "Inserir fórmula matemática - MathType",
    insert_chem: "Inserir uma fórmula química - ChemType",
    minimize: "Minimizar",
    maximize: "Maximizar",
    fullscreen: "Ecrã completo",
    exit_fullscreen: "Sair do ecrã completo",
    close: "Fechar",
    mathtype: "MathType",
    title_modalwindow: "Janela modal do MathType",
    close_modal_warning: "Pretende sair? As alterações efetuadas serão perdidas.",
    latex_name_label: "Fórmula Latex",
    browser_no_compatible: "O seu navegador não é compatível com a tecnologia AJAX. Utilize a versão mais recente do Mozilla Firefox.",
    error_convert_accessibility: "Erro ao converter de MathML para texto acessível.",
    exception_cross_site: "O processamento de scripts em vários sites só é permitido para HTTP.",
    exception_high_surrogate: "Substituto alto não seguido por um substituto baixo em fixedCharCodeAt()",
    exception_string_length: "Cadeia inválida. O comprimento tem de ser um múltiplo de 4",
    exception_key_nonobject: "Object.keys chamou um não-objeto",
    exception_null_or_undefined: " é nulo ou não está definido",
    exception_not_function: " não é uma função",
    exception_invalid_date_format: "Formato de data inválido: ",
    exception_casting: "Não é possível adicionar ",
    exception_casting_to: " até "
  },
  pt_br: {
    latex: "LaTeX",
    cancel: "Cancelar",
    accept: "Inserir",
    manual: "Manual",
    insert_math: "Inserir fórmula matemática - MathType",
    insert_chem: "Insira uma fórmula química - ChemType",
    minimize: "Minimizar",
    maximize: "Maximizar",
    fullscreen: "Tela cheia",
    exit_fullscreen: "Sair de tela cheia",
    close: "Fechar",
    mathtype: "MathType",
    title_modalwindow: "Janela modal do MathType",
    close_modal_warning: "Tem certeza de que deseja sair? Todas as alterações serão perdidas.",
    latex_name_label: "Fórmula LaTeX",
    browser_no_compatible: "O navegador não é compatível com a tecnologia AJAX. Use a versão mais recente do Mozilla Firefox.",
    error_convert_accessibility: "Erro ao converter de MathML para texto acessível.",
    exception_cross_site: "O uso de scripts entre sites só é permitido para HTTP.",
    exception_high_surrogate: "High surrogate não seguido de low surrogate em fixedCharCodeAt()",
    exception_string_length: "String inválida. O comprimento deve ser um múltiplo de 4",
    exception_key_nonobject: "Object.keys chamados em não objeto",
    exception_null_or_undefined: " isto é nulo ou não definido",
    exception_not_function: " não é uma função",
    exception_invalid_date_format: "Formato de data inválido: ",
    exception_casting: "Não é possível transmitir ",
    exception_casting_to: " para "
  },
  ro: {
    latex: "LaTeX",
    cancel: "Anulare",
    accept: "Inserați",
    manual: "Ghid",
    insert_math: "Inserați o formulă matematică - MathType",
    insert_chem: "Inserați o formulă chimică - ChemType",
    minimize: "Minimizați",
    maximize: "Maximizați",
    fullscreen: "Afișați pe tot ecranul",
    exit_fullscreen: "Opriți afișarea pe tot ecranul",
    close: "Închideți",
    mathtype: "MathType",
    title_modalwindow: "Fereastră modală MathType",
    close_modal_warning: "Sigur doriți să ieșiți? Modificările realizate se vor pierde.",
    latex_name_label: "Formulă Latex",
    browser_no_compatible: "Browserul dvs. nu este compatibil cu tehnologia AJAX. Utilizați cea mai recentă versiune de Mozilla Firefox.",
    error_convert_accessibility: "Eroare la convertirea din MathML în text accesibil.",
    exception_cross_site: "Scriptarea între site‑uri este permisă doar pentru HTTP.",
    exception_high_surrogate: "Surogatul superior nu este urmat de un surogat inferior în fixedCharCodeAt()",
    exception_string_length: "Șir nevalid. Lungimea trebuie să fie multiplu de 4",
    exception_key_nonobject: "Object.keys a apelat un non-obiect",
    exception_null_or_undefined: " este null sau nu este definit",
    exception_not_function: " nu este funcție",
    exception_invalid_date_format: "Format de dată nevalid: ",
    exception_casting: "nu se poate difuza ",
    exception_casting_to: " către "
  },
  ru: {
    latex: "LaTeX",
    cancel: "отмена",
    accept: "Вставка",
    manual: "вручную",
    insert_math: "Вставить математическую формулу: WIRIS",
    insert_chem: "Вставить химическую формулу — ChemType",
    minimize: "Свернуть",
    maximize: "Развернуть",
    fullscreen: "На весь экран",
    exit_fullscreen: "Выйти из полноэкранного режима",
    close: "Закрыть",
    mathtype: "MathType",
    title_modalwindow: "Режимное окно MathType",
    close_modal_warning: "Вы уверены, что хотите выйти? Все внесенные изменения будут утрачены.",
    latex_name_label: "Формула Latex",
    browser_no_compatible: "Ваш браузер несовместим с технологией AJAX. Используйте последнюю версию Mozilla Firefox.",
    error_convert_accessibility: "При преобразовании формулы в текст допустимого формата произошла ошибка.",
    exception_cross_site: "Межсайтовые сценарии доступны только для HTTP.",
    exception_high_surrogate: "Младший символ-заместитель не сопровождает старший символ-заместитель в исправленном методе CharCodeAt()",
    exception_string_length: "Недопустимая строка. Длинна должна быть кратной 4.",
    exception_key_nonobject: "Метод Object.keys вызван не для объекта",
    exception_null_or_undefined: " значение пустое или не определено",
    exception_not_function: " не функция",
    exception_invalid_date_format: "Недопустимый формат даты: ",
    exception_casting: "Не удается привести ",
    exception_casting_to: " к "
  },
  sv: {
    latex: "LaTeX",
    cancel: "Avbryt",
    accept: "Infoga",
    manual: "Bruksanvisning",
    insert_math: "Infoga matematisk formel - MathType",
    insert_chem: "Infoga en kemiformel – ChemType",
    minimize: "Minimera",
    maximize: "Maximera",
    fullscreen: "Helskärm",
    exit_fullscreen: "Stäng helskärm",
    close: "Stäng",
    mathtype: "MathType",
    title_modalwindow: "MathType modulfönster",
    close_modal_warning: "Vill du avsluta? Inga ändringar kommer att sparas.",
    latex_name_label: "Latex-formel",
    browser_no_compatible: "Din webbläsare är inte kompatibel med AJAX-teknik. Använd den senaste versionen av Mozilla Firefox.",
    error_convert_accessibility: "Det uppstod ett fel vid konvertering från MathML till åtkomlig text.",
    exception_cross_site: "Skriptkörning över flera sajter är endast tillåtet för HTTP.",
    exception_high_surrogate: "Hög surrogat följs inte av låg surrogat i fixedCharCodeAt()",
    exception_string_length: "Ogiltig sträng. Längden måste vara en multipel av 4",
    exception_key_nonobject: "Object.keys anropade icke-objekt",
    exception_null_or_undefined: " det är null eller inte definierat",
    exception_not_function: " är inte en funktion",
    exception_invalid_date_format: "Ogiltigt datumformat: ",
    exception_casting: "Går inte att konvertera ",
    exception_casting_to: " till "
  },
  tr: {
    latex: "LaTeX",
    cancel: "Vazgeç",
    accept: "Ekle",
    manual: "Kılavuz",
    insert_math: "Matematik formülü ekle - MathType",
    insert_chem: "Kimya formülü ekleyin - ChemType",
    minimize: "Simge Durumuna Küçült",
    maximize: "Ekranı Kapla",
    fullscreen: "Tam Ekran",
    exit_fullscreen: "Tam Ekrandan Çık",
    close: "Kapat",
    mathtype: "MathType",
    title_modalwindow: "MathType kalıcı penceresi",
    close_modal_warning: "Çıkmak istediğinizden emin misiniz? Yaptığınız değişiklikler kaybolacak.",
    latex_name_label: "Latex Formülü",
    browser_no_compatible: "Tarayıcınız AJAX teknolojisiyle uyumlu değil. Lütfen en güncel Mozilla Firefox sürümünü kullanın.",
    error_convert_accessibility: "MathML biçiminden erişilebilir metne dönüştürme hatası.",
    exception_cross_site: "Siteler arası komut dosyası yazma işlemine yalnızca HTTP için izin verilir.",
    exception_high_surrogate: "fixedCharCodeAt() fonksiyonunda üst vekilin ardından alt vekil gelmiyor",
    exception_string_length: "Geçersiz dizgi. Uzunluk, 4'ün katlarından biri olmalıdır",
    exception_key_nonobject: "Nesne olmayan öğe üzerinde Object.keys çağrıldı",
    exception_null_or_undefined: " bu değer boş veya tanımlanmamış",
    exception_not_function: " bir fonksiyon değil",
    exception_invalid_date_format: "Geçersiz tarih biçimi: ",
    exception_casting: "Tür dönüştürülemiyor ",
    exception_casting_to: " hedef: "
  },
  zh: {
    latex: "LaTeX",
    cancel: "取消",
    accept: "插入",
    manual: "手册",
    insert_math: "插入数学公式 - MathType",
    insert_chem: "插入化学分子式 - ChemType",
    minimize: "最小化",
    maximize: "最大化",
    fullscreen: "全屏幕",
    exit_fullscreen: "退出全屏幕",
    close: "关闭",
    mathtype: "MathType",
    title_modalwindow: "MathType 模式窗口",
    close_modal_warning: "您确定要离开吗？您所做的修改将丢失。",
    latex_name_label: "Latex 分子式",
    browser_no_compatible: "您的浏览器不兼容 AJAX 技术。请使用最新版 Mozilla Firefox。",
    error_convert_accessibility: "将 MathML 转换为可访问文本时出错。",
    exception_cross_site: "仅 HTTP 允许跨站脚本。",
    exception_high_surrogate: "fixedCharCodeAt() 中的高位代理之后未跟随低位代理",
    exception_string_length: "无效字符串。长度必须是 4 的倍数",
    exception_key_nonobject: "非对象调用了 Object.keys",
    exception_null_or_undefined: " 该值为空或未定义",
    exception_not_function: " 不是一个函数",
    exception_invalid_date_format: "无效日期格式： ",
    exception_casting: "无法转换 ",
    exception_casting_to: " 为 "
  },
  "": {}
};

// node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/src/stringmanager.js
var StringManager = class {
  constructor() {
    throw new Error("Static class StringManager can not be instantiated.");
  }
  /**
   * Returns the associated value of certain string key. If the associated value
   * doesn't exits returns the original key.
   * @param {string} key - string key
   * @param {string} lang - DEFAULT = null. Specify the language to translate the string
   * @returns {string} correspondent value. If doesn't exists original key.
   */
  static get(key, lang) {
    let { language } = this;
    if (lang) {
      language = lang;
    }
    if (language && language.length > 2) {
      language = language.slice(0, 2);
    }
    if (!this.strings.hasOwnProperty(language)) {
      console.warn(`Unknown language ${language} set in StringManager.`);
      language = "en";
    }
    if (!this.strings[language].hasOwnProperty(key)) {
      console.warn(`Unknown key ${key} for language ${language} in StringManager.`);
      return key;
    }
    return this.strings[language][key];
  }
};
StringManager.strings = strings_default;
StringManager.language = "en";

// node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/src/util.js
var Util = class _Util {
  /**
   * Fires an event in a target.
   * @param {EventTarget} eventTarget - target where event should be fired.
   * @param {string} eventName event to fire.
   * @static
   */
  static fireEvent(eventTarget, eventName) {
    if (document.createEvent) {
      const eventObject2 = document.createEvent("HTMLEvents");
      eventObject2.initEvent(eventName, true, true);
      return !eventTarget.dispatchEvent(eventObject2);
    }
    const eventObject = document.createEventObject();
    return eventTarget.fireEvent(`on${eventName}`, eventObject);
  }
  /**
   * Cross-browser addEventListener/attachEvent function.
   * @param {EventTarget} eventTarget - target to add the event.
   * @param {string} eventName - specifies the type of event.
   * @param {Function} callBackFunction - callback function.
   * @static
   */
  static addEvent(eventTarget, eventName, callBackFunction) {
    if (eventTarget.addEventListener) {
      eventTarget.addEventListener(eventName, callBackFunction, true);
    } else if (eventTarget.attachEvent) {
      eventTarget.attachEvent(`on${eventName}`, callBackFunction);
    }
  }
  /**
   * Cross-browser removeEventListener/detachEvent function.
   * @param {EventTarget} eventTarget - target to add the event.
   * @param {string} eventName - specifies the type of event.
   * @param {Function} callBackFunction - function to remove from the event target.
   * @static
   */
  static removeEvent(eventTarget, eventName, callBackFunction) {
    if (eventTarget.removeEventListener) {
      eventTarget.removeEventListener(eventName, callBackFunction, true);
    } else if (eventTarget.detachEvent) {
      eventTarget.detachEvent(`on${eventName}`, callBackFunction);
    }
  }
  /**
   * Adds the a callback function, for a certain event target, to the following event types:
   * - dblclick
   * - mousedown
   * - mouseup
   * @param {EventTarget} eventTarget - event target.
   * @param {Function} doubleClickHandler - function to run when on dblclick event.
   * @param {Function} mousedownHandler - function to run when on mousedown event.
   * @param {Function} mouseupHandler - function to run when on mouseup event.
   * @static
   */
  static addElementEvents(eventTarget, doubleClickHandler, mousedownHandler, mouseupHandler) {
    if (doubleClickHandler) {
      this.callbackDblclick = (event) => {
        const realEvent = event || window.event;
        const element = realEvent.srcElement ? realEvent.srcElement : realEvent.target;
        doubleClickHandler(element, realEvent);
      };
      _Util.addEvent(eventTarget, "dblclick", this.callbackDblclick);
    }
    if (mousedownHandler) {
      this.callbackMousedown = (event) => {
        const realEvent = event || window.event;
        const element = realEvent.srcElement ? realEvent.srcElement : realEvent.target;
        mousedownHandler(element, realEvent);
      };
      _Util.addEvent(eventTarget, "mousedown", this.callbackMousedown);
    }
    if (mouseupHandler) {
      this.callbackMouseup = (event) => {
        const realEvent = event || window.event;
        const element = realEvent.srcElement ? realEvent.srcElement : realEvent.target;
        mouseupHandler(element, realEvent);
      };
      _Util.addEvent(document, "mouseup", this.callbackMouseup);
      _Util.addEvent(eventTarget, "mouseup", this.callbackMouseup);
    }
  }
  /**
   * Remove all callback function, for a certain event target, to the following event types:
   * - dblclick
   * - mousedown
   * - mouseup
   * @param {EventTarget} eventTarget - event target.
   * @static
   */
  static removeElementEvents(eventTarget) {
    _Util.removeEvent(eventTarget, "dblclick", this.callbackDblclick);
    _Util.removeEvent(eventTarget, "mousedown", this.callbackMousedown);
    _Util.removeEvent(document, "mouseup", this.callbackMouseup);
    _Util.removeEvent(eventTarget, "mouseup", this.callbackMouseup);
  }
  /**
   * Adds a class name to a HTMLElement.
   * @param {HTMLElement} element - the HTML element.
   * @param {string} className - the class name.
   * @static
   */
  static addClass(element, className) {
    if (!_Util.containsClass(element, className)) {
      element.className += ` ${className}`;
    }
  }
  /**
   * Checks if a HTMLElement contains a certain class.
   * @param {HTMLElement} element - the HTML element.
   * @param {string} className - the className.
   * @returns {boolean} true if the HTMLElement contains the class name. false otherwise.
   * @static
   */
  static containsClass(element, className) {
    if (element == null || !("className" in element)) {
      return false;
    }
    const currentClasses = element.className.split(" ");
    for (let i = currentClasses.length - 1; i >= 0; i -= 1) {
      if (currentClasses[i] === className) {
        return true;
      }
    }
    return false;
  }
  /**
   * Remove a certain class for a HTMLElement.
   * @param {HTMLElement} element - the HTML element.
   * @param {string} className - the class name.
   * @static
   */
  static removeClass(element, className) {
    let newClassName = "";
    const classes = element.className.split(" ");
    for (let i = 0; i < classes.length; i += 1) {
      if (classes[i] !== className) {
        newClassName += `${classes[i]} `;
      }
    }
    element.className = newClassName.trim();
  }
  /**
   * Converts old xml initial text attribute (with «») to the correct one(with §lt;§gt;). It's
   * used to parse old applets.
   * @param {string} text - string containing safeXml characters
   * @returns {string} a string with safeXml characters parsed.
   * @static
   */
  static convertOldXmlinitialtextAttribute(text2) {
    const val = "value=";
    const xitpos = text2.indexOf("xmlinitialtext");
    const valpos = text2.indexOf(val, xitpos);
    const quote = text2.charAt(valpos + val.length);
    const startquote = valpos + val.length + 1;
    const endquote = text2.indexOf(quote, startquote);
    const value = text2.substring(startquote, endquote);
    let newvalue = value.split("«").join("§lt;");
    newvalue = newvalue.split("»").join("§gt;");
    newvalue = newvalue.split("&").join("§");
    newvalue = newvalue.split("¨").join("§quot;");
    text2 = text2.split(value).join(newvalue);
    return text2;
  }
  /**
   * Cross-browser solution for creating new elements.
   * @param {string} tagName - tag name of the wished element.
   * @param {Object} attributes - an object where each key is a wished
   * attribute name and each value is its value.
   * @param {Object} [creator] - if supplied, this function will use
   * the "createElement" method from this param. Otherwise
   * document will be used as creator.
   * @returns {Element} The DOM element with the specified attributes assigned.
   * @static
   */
  static createElement(tagName, attributes, creator) {
    if (attributes === void 0) {
      attributes = {};
    }
    if (creator === void 0) {
      creator = document;
    }
    let element;
    try {
      let html2 = `<${tagName}`;
      Object.keys(attributes).forEach((attributeName) => {
        html2 += ` ${attributeName}="${_Util.htmlEntities(attributes[attributeName])}"`;
      });
      html2 += ">";
      element = creator.createElement(html2);
    } catch (e) {
      element = creator.createElement(tagName);
      Object.keys(attributes).forEach((attributeName) => {
        element.setAttribute(attributeName, attributes[attributeName]);
      });
    }
    return element;
  }
  /**
   * Creates new HTML from it's HTML code as string.
   * @param {string} objectCode - html code
   * @returns {Element} the HTML element.
   * @static
   */
  static createObject(objectCode, creator) {
    if (creator === void 0) {
      creator = document;
    }
    objectCode = objectCode.split("<applet ").join('<span wirisObject="WirisApplet" ').split("<APPLET ").join('<span wirisObject="WirisApplet" ');
    objectCode = objectCode.split("</applet>").join("</span>").split("</APPLET>").join("</span>");
    objectCode = objectCode.split("<param ").join('<br wirisObject="WirisParam" ').split("<PARAM ").join('<br wirisObject="WirisParam" ');
    objectCode = objectCode.split("</param>").join("</br>").split("</PARAM>").join("</br>");
    const container = _Util.createElement("div", {}, creator);
    container.innerHTML = objectCode;
    function recursiveParamsFix(object) {
      if (object.getAttribute && object.getAttribute("wirisObject") === "WirisParam") {
        const attributesParsed = {};
        for (let i = 0; i < object.attributes.length; i += 1) {
          if (object.attributes[i].nodeValue !== null) {
            attributesParsed[object.attributes[i].nodeName] = object.attributes[i].nodeValue;
          }
        }
        const param = _Util.createElement("param", attributesParsed, creator);
        if (param.NAME) {
          param.name = param.NAME;
          param.value = param.VALUE;
        }
        param.removeAttribute("wirisObject");
        object.parentNode.replaceChild(param, object);
      } else if (object.getAttribute && object.getAttribute("wirisObject") === "WirisApplet") {
        const attributesParsed = {};
        for (let i = 0; i < object.attributes.length; i += 1) {
          if (object.attributes[i].nodeValue !== null) {
            attributesParsed[object.attributes[i].nodeName] = object.attributes[i].nodeValue;
          }
        }
        const applet = _Util.createElement("applet", attributesParsed, creator);
        applet.removeAttribute("wirisObject");
        for (let i = 0; i < object.childNodes.length; i += 1) {
          recursiveParamsFix(object.childNodes[i]);
          if (object.childNodes[i].nodeName.toLowerCase() === "param") {
            applet.appendChild(object.childNodes[i]);
            i -= 1;
          }
        }
        object.parentNode.replaceChild(applet, object);
      } else {
        for (let i = 0; i < object.childNodes.length; i += 1) {
          recursiveParamsFix(object.childNodes[i]);
        }
      }
    }
    recursiveParamsFix(container);
    return container.firstChild;
  }
  /**
   * Converts an Element to its HTML code.
   * @param {Element} element - entry element.
   * @return {string} the HTML code of the input element.
   * @static
   */
  static createObjectCode(element) {
    if (typeof element === "undefined" || element === null) {
      return null;
    }
    if (element.nodeType === 1) {
      let output = `<${element.tagName}`;
      for (let i = 0; i < element.attributes.length; i += 1) {
        if (element.attributes[i].specified) {
          output += ` ${element.attributes[i].name}="${_Util.htmlEntities(element.attributes[i].value)}"`;
        }
      }
      if (element.childNodes.length > 0) {
        output += ">";
        for (let i = 0; i < element.childNodes.length; i += 1) {
          output += _Util.createObject(element.childNodes[i]);
        }
        output += `</${element.tagName}>`;
      } else if (element.nodeName === "DIV" || element.nodeName === "SCRIPT") {
        output += `></${element.tagName}>`;
      } else {
        output += "/>";
      }
      return output;
    }
    if (element.nodeType === 3) {
      return _Util.htmlEntities(element.nodeValue);
    }
    return "";
  }
  /**
   * Concatenates two URL paths.
   * @param {string} path1 - first URL path
   * @param {string} path2 - second URL path
   * @returns {string} new URL.
   */
  static concatenateUrl(path1, path2) {
    let separator = "";
    if (path1.indexOf("/") !== path1.length && path2.indexOf("/") !== 0) {
      separator = "/";
    }
    return (path1 + separator + path2).replace(/([^:]\/)\/+/g, "$1");
  }
  /**
   * Parses a text and replaces all HTML special characters by their correspondent entities.
   * @param {string} input - text to be parsed.
   * @returns {string} the input text with all their special characters replaced by their entities.
   * @static
   */
  static htmlEntities(input) {
    return input.split("&").join("&amp;").split("<").join("&lt;").split(">").join("&gt;").split('"').join("&quot;");
  }
  /**
   * Sanitize HTML to prevent XSS injections.
   * @param {string} html - html to be sanitize.
   * @returns {string} html sanitized.
   * @static
   */
  static htmlSanitize(html2) {
    let annotationRegex = /\<annotation.+\<\/annotation\>/;
    let annotation = html2.match(annotationRegex);
    html2 = purify.sanitize(html2, { ADD_TAGS: ["semantics", "annotation"], ALLOWED_ATTR: ["mathvariant", "class", "linebreak", "open", "close"] });
    return html2.replace(annotationRegex, annotation);
  }
  /**
   * Parses a text and replaces all the HTML entities by their characters.
   * @param {string} input - text to be parsed
   * @returns {string} the input text with all their entities replaced by characters.
   * @static
   */
  static htmlEntitiesDecode(input) {
    const textarea = document.createElement("textarea");
    textarea.innerHTML = input;
    return textarea.value;
  }
  /**
   * Returns a cross-browser http request.
   * @return {object} httpRequest request object.
   * @returns {XMLHttpRequest|ActiveXObject} the proper request object.
   */
  static createHttpRequest() {
    const currentPath = window.location.toString().substr(0, window.location.toString().lastIndexOf("/") + 1);
    if (currentPath.substr(0, 7) === "file://") {
      throw StringManager.get("exception_cross_site");
    }
    if (typeof XMLHttpRequest !== "undefined") {
      return new XMLHttpRequest();
    }
    try {
      return new ActiveXObject("Msxml2.XMLHTTP");
    } catch (e) {
      try {
        return new ActiveXObject("Microsoft.XMLHTTP");
      } catch (oc) {
        return null;
      }
    }
  }
  /**
   * Converts a hash to a HTTP query.
   * @param {Object[]} properties - a key/value object.
   * @returns {string} a HTTP query containing all the key value pairs with
   * all the special characters replaced by their entities.
   * @static
   */
  static httpBuildQuery(properties) {
    let result = "";
    Object.keys(properties).forEach((i) => {
      if (properties[i] != null) {
        result += `${_Util.urlEncode(i)}=${_Util.urlEncode(properties[i])}&`;
      }
    });
    if (result.substring(result.length - 1) === "&") {
      result = result.substring(0, result.length - 1);
    }
    return result;
  }
  /**
   * Convert a hash to string sorting keys to get a deterministic output
   * @param {Object[]} hash - a key/value object.
   * @returns {string} a string with the form key1=value1...keyn=valuen
   * @static
   */
  static propertiesToString(hash) {
    const keys = [];
    Object.keys(hash).forEach((key) => {
      if (Object.prototype.hasOwnProperty.call(hash, key)) {
        keys.push(key);
      }
    });
    const n = keys.length;
    for (let i = 0; i < n; i += 1) {
      for (let j = i + 1; j < n; j += 1) {
        const s1 = keys[i];
        const s2 = keys[j];
        if (_Util.compareStrings(s1, s2) > 0) {
          keys[i] = s2;
          keys[j] = s1;
        }
      }
    }
    let output = "";
    for (let i = 0; i < n; i += 1) {
      const key = keys[i];
      output += key;
      output += "=";
      let value = hash[key];
      value = value.replace("\\", "\\\\");
      value = value.replace("\n", "\\n");
      value = value.replace("\r", "\\r");
      value = value.replace("	", "\\t");
      output += value;
      output += "\n";
    }
    return output;
  }
  /**
   * Compare two strings using charCodeAt method
   * @param {string} a - first string to compare.
   * @param {string} b - second string to compare.
   * @returns {number} the difference between a and b
   * @static
   */
  static compareStrings(a, b) {
    let i;
    const an = a.length;
    const bn = b.length;
    const n = an > bn ? bn : an;
    for (i = 0; i < n; i += 1) {
      const c = _Util.fixedCharCodeAt(a, i) - _Util.fixedCharCodeAt(b, i);
      if (c !== 0) {
        return c;
      }
    }
    return a.length - b.length;
  }
  /**
   * Fix charCodeAt() JavaScript function to handle non-Basic-Multilingual-Plane characters.
   * @param {string} string - input string
   * @param {number} idx - an integer greater than or equal to 0
   * and less than the length of the string
   * @returns {number} an integer representing the UTF-16 code of the string at the given index.
   * @static
   */
  static fixedCharCodeAt(string, idx) {
    idx = idx || 0;
    const code2 = string.charCodeAt(idx);
    let hi;
    let low;
    if (code2 >= 55296 && code2 <= 56319) {
      hi = code2;
      low = string.charCodeAt(idx + 1);
      if (Number.isNaN(low)) {
        throw StringManager.get("exception_high_surrogate");
      }
      return (hi - 55296) * 1024 + (low - 56320) + 65536;
    }
    if (code2 >= 56320 && code2 <= 57343) {
      return false;
    }
    return code2;
  }
  /**
   * Returns an URL with it's query params converted into array.
   * @param {string} url - input URL.
   * @returns {Object[]} an array containing all URL query params.
   * @static
   */
  static urlToAssArray(url) {
    let i;
    i = url.indexOf("?");
    if (i > 0) {
      const query = url.substring(i + 1);
      const ss = query.split("&");
      const h = {};
      for (i = 0; i < ss.length; i += 1) {
        const s = ss[i];
        const kv = s.split("=");
        if (kv.length > 1) {
          h[kv[0]] = decodeURIComponent(kv[1].replace(/\+/g, " "));
        }
      }
      return h;
    }
    return {};
  }
  /**
   * Returns an encoded URL by replacing each instance of certain characters by
   * one, two, three or four escape sequences using encodeURIComponent method.
   * !'()* . will not be encoded.
   *
   * @param {string} clearString - URL string to be encoded
   * @returns {string} URL with it's special characters replaced.
   * @static
   */
  static urlEncode(clearString) {
    let output = "";
    output = encodeURIComponent(clearString);
    return output;
  }
  // TODO: To parser?
  /**
   * Converts the HTML of a image into the output code that WIRIS must return.
   * By default returns the MathML stored on data-mahml attribute (if imgCode is a formula)
   * or the Wiriscas attribute of a WIRIS applet.
   * @param {string} imgCode - the html code from a formula or a CAS image.
   * @param {boolean} convertToXml - true if the image should be converted to XML.
   * @param {boolean} convertToSafeXml - true if the image should be converted to safeXML.
   * @returns {string} the XML or safeXML of a WIRIS image.
   * @static
   */
  static getWIRISImageOutput(imgCode, convertToXml, convertToSafeXml) {
    const imgObject = _Util.createObject(imgCode);
    if (imgObject) {
      if (imgObject.className === Configuration.get("imageClassName") || imgObject.getAttribute(Configuration.get("imageMathmlAttribute"))) {
        if (!convertToXml) {
          return imgCode;
        }
        const dataMathML = imgObject.getAttribute(Configuration.get("imageMathmlAttribute"));
        let mathML = MathML.safeXmlDecode(dataMathML);
        if (!Configuration.get("saveHandTraces")) {
          mathML = MathML.removeAnnotation(mathML, "application/json");
        }
        if (mathML == null) {
          mathML = imgObject.getAttribute("alt");
        }
        if (convertToSafeXml) {
          const safeMathML = MathML.safeXmlEncode(mathML);
          return safeMathML;
        }
        return mathML;
      }
    }
    return imgCode;
  }
  /**
   * Gets the node length in characters.
   * @param {Node} node - HTML node.
   * @returns {number} node length.
   * @static
   */
  static getNodeLength(node) {
    const staticNodeLengths = {
      IMG: 1,
      BR: 1
    };
    if (node.nodeType === 3) {
      return node.nodeValue.length;
    }
    if (node.nodeType === 1) {
      let length = staticNodeLengths[node.nodeName.toUpperCase()];
      if (length === void 0) {
        length = 0;
      }
      for (let i = 0; i < node.childNodes.length; i += 1) {
        length += _Util.getNodeLength(node.childNodes[i]);
      }
      return length;
    }
    return 0;
  }
  /**
   * Gets a selected node or text from an editable HTMLElement.
   * If the caret is on a text node, concatenates it with all the previous and next text nodes.
   * @param {HTMLElement} target - the editable HTMLElement.
   * @param {boolean} isIframe  - specifies if the target is an iframe or not
   * @param {boolean} forceGetSelection - if true, ignores IE system to get
   * the current selection and uses window.getSelection()
   * @returns {object} an object with the 'node' key set if the item is an
   * element or the keys 'node' and 'caretPosition' if the element is text.
   * @static
   */
  static getSelectedItem(target, isIframe, forceGetSelection) {
    var _a;
    let windowTarget;
    if (isIframe) {
      windowTarget = target.contentWindow;
      windowTarget.focus();
    } else {
      windowTarget = window;
      target.focus();
    }
    if (document.selection && !forceGetSelection) {
      const range = windowTarget.document.selection.createRange();
      if (range.parentElement) {
        if (range.htmlText.length > 0) {
          if (range.text.length === 0) {
            return _Util.getSelectedItem(target, isIframe, true);
          }
          return null;
        }
        windowTarget.document.execCommand("InsertImage", false, "#");
        let temporalObject = range.parentElement();
        if (temporalObject.nodeName.toUpperCase() !== "IMG") {
          range.pasteHTML('<span id="wrs_openEditorWindow_temporalObject"></span>');
          temporalObject = windowTarget.document.getElementById("wrs_openEditorWindow_temporalObject");
        }
        let node;
        let caretPosition;
        if (temporalObject.nextSibling && temporalObject.nextSibling.nodeType === 3) {
          node = temporalObject.nextSibling;
          caretPosition = 0;
        } else if (temporalObject.previousSibling && temporalObject.previousSibling.nodeType === 3) {
          node = temporalObject.previousSibling;
          caretPosition = node.nodeValue.length;
        } else {
          node = windowTarget.document.createTextNode("");
          temporalObject.parentNode.insertBefore(node, temporalObject);
          caretPosition = 0;
        }
        temporalObject.parentNode.removeChild(temporalObject);
        return {
          node,
          caretPosition
        };
      }
      if (range.length > 1) {
        return null;
      }
      return {
        node: range.item(0)
      };
    }
    if (windowTarget.getSelection) {
      let range;
      const selection = windowTarget.getSelection();
      try {
        range = selection.getRangeAt(0);
      } catch (e) {
        range = windowTarget.document.createRange();
      }
      const node = range.startContainer;
      if (node.nodeType === 3) {
        return {
          node,
          caretPosition: range.startOffset
        };
      }
      if (node !== range.endContainer) {
        return null;
      }
      if (node.nodeType === 1) {
        const position = range.startOffset;
        if (node.childNodes[position]) {
          if (range.startOffset === range.endOffset) {
            if (position !== 0 && node.childNodes[position - 1].localName === "span" && node.childNodes[position].classList.contains("Wirisformula")) {
              node.childNodes[position - 1].remove();
              return _Util.getSelectedItem(target, isIframe, forceGetSelection);
            } else if ((_a = node.childNodes[position].classList) == null ? void 0 : _a.contains("Wirisformula")) {
              if (position > 0 && node.childNodes[position - 1].classList.contains("Wirisformula") || position === 0) {
                var emptySpan = document.createElement("span");
                node.insertBefore(emptySpan, node.childNodes[position]);
                return {
                  node: node.childNodes[position]
                };
              }
            }
          }
          return {
            node: node.childNodes[position]
          };
        }
      }
    }
    return null;
  }
  /**
   * Returns null if there isn't any item or if it is malformed.
   * Otherwise returns an object containing the node with the MathML image
   * and the cursor position inside the textarea.
   * @param {HTMLTextAreaElement} textarea - textarea element.
   * @returns {Object} An object containing the node, the index of the
   * beginning  of the selected text, caret position and the start and end position of the
   * text node.
   * @static
   */
  static getSelectedItemOnTextarea(textarea) {
    const textNode = document.createTextNode(textarea.value);
    const textNodeValues = Latex.getLatexFromTextNode(textNode, textarea.selectionStart);
    if (textNodeValues === null) {
      return null;
    }
    return {
      node: textNode,
      caretPosition: textarea.selectionStart,
      startPosition: textNodeValues.startPosition,
      endPosition: textNodeValues.endPosition
    };
  }
  /**
   * Looks for elements that match the given name in a HTML code string.
   * Important: this function is very concrete for WIRIS code.
   * It takes as preconditions lots of behaviors that are not the general case.
   * @param {string} code -  HTML code.
   * @param {string} name - element name.
   * @param {boolean} autoClosed - true if the elements are autoClosed.
   * @return {Object[]} an object containing all HTML elements of code matching the name argument.
   * @static
   */
  static getElementsByNameFromString(code2, name, autoClosed) {
    const elements = [];
    code2 = code2.toLowerCase();
    name = name.toLowerCase();
    let start = code2.indexOf(`<${name} `);
    while (start !== -1) {
      let endString;
      if (autoClosed) {
        endString = ">";
      } else {
        endString = `</${name}>`;
      }
      let end = code2.indexOf(endString, start);
      if (end !== -1) {
        end += endString.length;
        elements.push({
          start,
          end
        });
      } else {
        end = start + 1;
      }
      start = code2.indexOf(`<${name} `, end);
    }
    return elements;
  }
  /**
   * Returns the numeric value of a base64 character.
   * @param  {string} character - base64 character.
   * @returns {number} base64 character numeric value.
   * @static
   */
  static decode64(character) {
    const PLUS = "+".charCodeAt(0);
    const SLASH = "/".charCodeAt(0);
    const NUMBER = "0".charCodeAt(0);
    const LOWER = "a".charCodeAt(0);
    const UPPER = "A".charCodeAt(0);
    const PLUS_URL_SAFE = "-".charCodeAt(0);
    const SLASH_URL_SAFE = "_".charCodeAt(0);
    const code2 = character.charCodeAt(0);
    if (code2 === PLUS || code2 === PLUS_URL_SAFE) {
      return 62;
    }
    if (code2 === SLASH || code2 === SLASH_URL_SAFE) {
      return 63;
    }
    if (code2 < NUMBER) {
      return -1;
    }
    if (code2 < NUMBER + 10) {
      return code2 - NUMBER + 26 + 26;
    }
    if (code2 < UPPER + 26) {
      return code2 - UPPER;
    }
    if (code2 < LOWER + 26) {
      return code2 - LOWER + 26;
    }
    return null;
  }
  /**
   * Converts a base64 string to a array of bytes.
   * @param {string} b64String - base64 string.
   * @param {number} length - dimension of byte array (by default whole string).
   * @return {Object[]} the resultant byte array.
   * @static
   */
  static b64ToByteArray(b64String, length) {
    let tmp;
    if (b64String.length % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    const arr = [];
    let l;
    let placeHolders;
    if (!length) {
      if (b64String.charAt(b64String.length - 2) === "=") {
        placeHolders = 2;
      } else if (b64String.charAt(b64String.length - 1) === "=") {
        placeHolders = 1;
      } else {
        placeHolders = 0;
      }
      l = placeHolders > 0 ? b64String.length - 4 : b64String.length;
    } else {
      l = length;
    }
    let i;
    for (i = 0; i < l; i += 4) {
      tmp = _Util.decode64(b64String.charAt(i)) << 18 | _Util.decode64(b64String.charAt(i + 1)) << 12 | _Util.decode64(b64String.charAt(i + 2)) << 6 | _Util.decode64(b64String.charAt(i + 3));
      arr.push(tmp >> 16 & 255);
      arr.push(tmp >> 8 & 255);
      arr.push(tmp & 255);
    }
    if (placeHolders) {
      if (placeHolders === 2) {
        tmp = _Util.decode64(b64String.charAt(i)) << 2 | _Util.decode64(b64String.charAt(i + 1)) >> 4;
        arr.push(tmp & 255);
      } else if (placeHolders === 1) {
        tmp = _Util.decode64(b64String.charAt(i)) << 10 | _Util.decode64(b64String.charAt(i + 1)) << 4 | _Util.decode64(b64String.charAt(i + 2)) >> 2;
        arr.push(tmp >> 8 & 255);
        arr.push(tmp & 255);
      }
    }
    return arr;
  }
  /**
   * Returns the first 32-bit signed integer from a byte array.
   * @param {Object[]} bytes - array of bytes.
   * @returns {number} the 32-bit signed integer.
   * @static
   */
  static readInt32(bytes) {
    if (bytes.length < 4) {
      return false;
    }
    const int32 = bytes.splice(0, 4);
    return int32[0] << 24 | int32[1] << 16 | int32[2] << 8 | int32[3] << 0;
  }
  /**
   * Read the first byte from a byte array.
   * @param {Object} bytes - input byte array.
   * @returns {number} first byte of the byte array.
   * @static
   */
  static readByte(bytes) {
    return bytes.shift() << 0;
  }
  /**
   * Read an arbitrary number of bytes, from a fixed position on a byte array.
   * @param  {Object[]} bytes - byte array.
   * @param  {number} pos - start position.
   * @param  {number} len - number of bytes to read.
   * @returns {Object[]} the byte array.
   * @static
   */
  static readBytes(bytes, pos, len) {
    return bytes.splice(pos, len);
  }
  /**
   * Inserts or modifies formulas or CAS on a textarea.
   * @param {HTMLTextAreaElement} textarea - textarea target.
   * @param {string} text - text to add in the textarea. For example, to add the link to the image,
   * call this function as (textarea, Parser.createImageSrc(mathml));
   * @static
   */
  static updateTextArea(textarea, text2) {
    if (textarea && text2) {
      textarea.focus();
      if (textarea.selectionStart != null) {
        const { selectionEnd } = textarea;
        const selectionStart = textarea.value.substring(0, textarea.selectionStart);
        const selectionEndSub = textarea.value.substring(selectionEnd, textarea.value.length);
        textarea.value = selectionStart + text2 + selectionEndSub;
        textarea.selectionEnd = selectionEnd + text2.length;
      } else {
        const selection = document.selection.createRange();
        selection.text = text2;
      }
    }
  }
  /**
   * Modifies existing formula on a textarea.
   * @param {HTMLTextAreaElement} textarea - text area target.
   * @param {string} text - text to add in the textarea. For example, if you want to add the link
   * to the image,you can call this function as
   * Util.updateTextarea(textarea, Parser.createImageSrc(mathml));
   * @param {number} start - beginning index from textarea where it needs to be replaced by text.
   * @param {number} end - ending index from textarea where it needs to be replaced by text
   * @static
   */
  static updateExistingTextOnTextarea(textarea, text2, start, end) {
    textarea.focus();
    const textareaStart = textarea.value.substring(0, start);
    textarea.value = textareaStart + text2 + textarea.value.substring(end, textarea.value.length);
    textarea.selectionEnd = start + text2.length;
  }
  /**
   * Add a parameter with it's correspondent value to an URL (GET).
   * @param {string} path - URL path
   * @param {string} parameter - parameter
   * @param {string} value - value
   * @static
   */
  static addArgument(path, parameter, value) {
    let sep;
    if (path.indexOf("?") > 0) {
      sep = "&";
    } else {
      sep = "?";
    }
    return `${path + sep + parameter}=${value}`;
  }
};

// node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/src/image.js
var Image = class _Image {
  /**
   * Removes data attributes from an image.
   * @param {HTMLImageElement} img - Image where remove data attributes.
   */
  static removeImgDataAttributes(img) {
    const attributesToRemove = [];
    const { attributes } = img;
    Object.keys(attributes).forEach((key) => {
      const attribute = attributes[key];
      if (attribute !== void 0 && attribute.name !== void 0 && attribute.name.indexOf("data-") === 0) {
        attributesToRemove.push(attribute.name);
      }
    });
    attributesToRemove.forEach((attribute) => {
      img.removeAttribute(attribute);
    });
  }
  /**
   * @static
   * Clones all MathType image attributes from a HTMLImageElement to another.
   * @param {HTMLImageElement} originImg - The original image.
   * @param {HTMLImageElement} destImg - The destination image.
   */
  static clone(originImg, destImg) {
    const customEditorAttributeName = Configuration.get("imageCustomEditorName");
    if (!originImg.hasAttribute(customEditorAttributeName)) {
      destImg.removeAttribute(customEditorAttributeName);
    }
    const mathmlAttributeName = Configuration.get("imageMathmlAttribute");
    const imgAttributes = [
      mathmlAttributeName,
      customEditorAttributeName,
      "alt",
      "height",
      "width",
      "style",
      "src",
      "role"
    ];
    imgAttributes.forEach((iterator) => {
      const originAttribute = originImg.getAttribute(iterator);
      if (originAttribute) {
        destImg.setAttribute(iterator, originAttribute);
      }
    });
  }
  /**
  * Calculates the metrics of a MathType image given the the service response and the image format.
  * @param {HTMLImageElement} img - The HTMLImageElement.
  * @param {String} uri - The URI generated by the image service: can be a data URI scheme or a URL.
  * @param {Boolean} jsonResponse - True the response of the image service is a
  * JSON object. False otherwise.
  */
  static setImgSize(img, uri, jsonResponse) {
    let ar;
    let base64String;
    let bytes;
    let svgString;
    if (jsonResponse) {
      if (Configuration.get("imageFormat") === "svg") {
        if (Configuration.get("saveMode") !== "base64") {
          ar = _Image.getMetricsFromSvgString(uri);
        } else {
          base64String = img.src.substr(img.src.indexOf("base64,") + 7, img.src.length);
          svgString = "";
          bytes = Util.b64ToByteArray(base64String, base64String.length);
          for (let i = 0; i < bytes.length; i += 1) {
            svgString += String.fromCharCode(bytes[i]);
          }
          ar = _Image.getMetricsFromSvgString(svgString);
        }
      } else {
        base64String = img.src.substr(img.src.indexOf("base64,") + 7, img.src.length);
        bytes = Util.b64ToByteArray(base64String, 88);
        ar = _Image.getMetricsFromBytes(bytes);
      }
    } else {
      ar = Util.urlToAssArray(uri);
    }
    let width = ar.cw;
    if (!width) {
      return;
    }
    let height = ar.ch;
    let baseline = ar.cb;
    const { dpi } = ar;
    if (dpi) {
      width = width * 96 / dpi;
      height = height * 96 / dpi;
      baseline = baseline * 96 / dpi;
    }
    img.width = width;
    img.height = height;
    img.style.verticalAlign = `-${height - baseline}px`;
  }
  /**
   * Calculates the metrics of an image which has been resized. Is used to restore the original
   * metrics of a resized image.
   * @param {HTMLImageElement } img - The resized HTMLImageElement.
   */
  static fixAfterResize(img) {
    img.removeAttribute("style");
    img.removeAttribute("width");
    img.removeAttribute("height");
    img.style.maxWidth = "none";
    const processImg = (img2) => {
      if (img2.src.indexOf("data:image") !== -1) {
        if (img2.src.indexOf("data:image/svg+xml") !== -1) {
          if (img2.src.indexOf("data:image/svg+xml;base64,") !== -1) {
            const base64String = img2.getAttribute("src").substring(26);
            const svgString = window.atob(base64String);
            const encodedSvgString = encodeURIComponent(svgString);
            img2.setAttribute("src", `data:image/svg+xml;charset=utf8,${encodedSvgString}`);
          }
          const svg2 = decodeURIComponent(img2.src.substring(32, img2.src.length));
          _Image.setImgSize(img2, svg2, true);
        } else {
          const base64 = img2.src.substring(22, img2.src.length);
          _Image.setImgSize(img2, base64, true);
        }
      } else {
        _Image.setImgSize(img2, img2.src);
      }
    };
    if (img.src.indexOf("blob:") === -1) {
      processImg(img);
    } else {
      let reader = new FileReader();
      reader.onload = function() {
        img.setAttribute("src", reader.result);
        processImg(img);
      };
      fetch(img.src).then((r) => r.blob()).then((blob) => {
        reader.readAsDataURL(blob);
      });
    }
  }
  /**
   * Returns the metrics (height, width and baseline) contained in a SVG image generated
   * by the MathType image service. This image contains as an extra custom attribute:
   * the baseline (wrs:baseline).
   * @param {String} svgString - The SVG image.
   * @return {Array} - The image metrics.
   */
  static getMetricsFromSvgString(svgString) {
    let first2 = svgString.indexOf('height="');
    let last = svgString.indexOf('"', first2 + 8, svgString.length);
    const height = svgString.substring(first2 + 8, last);
    first2 = svgString.indexOf('width="');
    last = svgString.indexOf('"', first2 + 7, svgString.length);
    const width = svgString.substring(first2 + 7, last);
    first2 = svgString.indexOf('wrs:baseline="');
    last = svgString.indexOf('"', first2 + 14, svgString.length);
    const baseline = svgString.substring(first2 + 14, last);
    if (typeof width !== "undefined") {
      const arr = [];
      arr.cw = width;
      arr.ch = height;
      if (typeof baseline !== "undefined") {
        arr.cb = baseline;
      }
      return arr;
    }
    return [];
  }
  /**
   * Returns the metrics (width, height, baseline and dpi) contained in a PNG byte array.
   * @param  {Array.<Bytes>} bytes - png byte array.
   * @return {Array} The png metrics.
   */
  static getMetricsFromBytes(bytes) {
    Util.readBytes(bytes, 0, 8);
    let width;
    let height;
    let typ;
    let baseline;
    let dpi;
    while (bytes.length >= 4) {
      typ = Util.readInt32(bytes);
      if (typ === 1229472850) {
        width = Util.readInt32(bytes);
        height = Util.readInt32(bytes);
        Util.readInt32(bytes);
        Util.readByte(bytes);
      } else if (typ === 1650545477) {
        baseline = Util.readInt32(bytes);
      } else if (typ === 1883789683) {
        dpi = Util.readInt32(bytes);
        dpi = Math.round(dpi / 39.37);
        Util.readInt32(bytes);
        Util.readByte(bytes);
      }
      Util.readInt32(bytes);
    }
    if (typeof width !== "undefined") {
      const arr = [];
      arr.cw = width;
      arr.ch = height;
      arr.dpi = dpi;
      if (baseline) {
        arr.cb = baseline;
      }
      return arr;
    }
    return [];
  }
};

// node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/src/accessibility.js
var Accessibility = class _Accessibility {
  /**
  * Static property.
  * Accessibility cache, each entry contains a MathML and its correspondent accessibility text.
  * @type {TextCache}
  */
  static get cache() {
    return _Accessibility._cache;
  }
  /**
   * Static property setter.
   * Set accessibility cache.
   * @param {TextCahe} value - The property value.
   * @ignore
   */
  static set cache(value) {
    _Accessibility._cache = value;
  }
  /**
   * Converts MathML strings to its accessible text representation.
   * @param {String} mathML - MathML to be converted to accessible text.
   * @param {String} [language] - Language of the accessible text. 'en' by default.
   * @param {Array.<String>} [data] - Parameters to send to mathml2accessible service.
   * @return {String} Accessibility text.
   */
  static mathMLToAccessible(mathML, language, data) {
    if (typeof language === "undefined") {
      language = "en";
    }
    if (MathML.containClass(mathML, "wrs_chemistry")) {
      data.mode = "chemistry";
    }
    data.ignoreStyles = true;
    let accessibleText = "";
    if (_Accessibility.cache.get(mathML)) {
      accessibleText = _Accessibility.cache.get(mathML);
    } else {
      data.service = "mathml2accessible";
      data.lang = language;
      const accessibleJsonResponse = JSON.parse(ServiceProvider.getService("service", data));
      if (accessibleJsonResponse.status !== "error") {
        accessibleText = accessibleJsonResponse.result.text;
        _Accessibility.cache.populate(mathML, accessibleText);
      } else {
        accessibleText = StringManager.get("error_convert_accessibility");
      }
    }
    return accessibleText;
  }
};
Accessibility._cache = new TextCache();

// node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/src/md5.js
var md5;
var md5_default = md5;
(function() {
  var HxOverrides = function() {
  };
  HxOverrides.__name__ = true;
  HxOverrides.dateStr = function(date) {
    var m = date.getMonth() + 1;
    var d = date.getDate();
    var h = date.getHours();
    var mi = date.getMinutes();
    var s = date.getSeconds();
    return date.getFullYear() + "-" + (m < 10 ? "0" + m : "" + m) + "-" + (d < 10 ? "0" + d : "" + d) + " " + (h < 10 ? "0" + h : "" + h) + ":" + (mi < 10 ? "0" + mi : "" + mi) + ":" + (s < 10 ? "0" + s : "" + s);
  };
  HxOverrides.strDate = function(s) {
    switch (s.length) {
      case 8:
        var k = s.split(":");
        var d = /* @__PURE__ */ new Date();
        d.setTime(0);
        d.setUTCHours(k[0]);
        d.setUTCMinutes(k[1]);
        d.setUTCSeconds(k[2]);
        return d;
      case 10:
        var k = s.split("-");
        return new Date(k[0], k[1] - 1, k[2], 0, 0, 0);
      case 19:
        var k = s.split(" ");
        var y = k[0].split("-");
        var t = k[1].split(":");
        return new Date(y[0], y[1] - 1, y[2], t[0], t[1], t[2]);
      default:
        throw "Invalid date format : " + s;
    }
  };
  HxOverrides.cca = function(s, index) {
    var x = s.charCodeAt(index);
    if (x != x)
      return void 0;
    return x;
  };
  HxOverrides.substr = function(s, pos, len) {
    if (pos != null && pos != 0 && len != null && len < 0)
      return "";
    if (len == null)
      len = s.length;
    if (pos < 0) {
      pos = s.length + pos;
      if (pos < 0)
        pos = 0;
    } else if (len < 0)
      len = s.length + len - pos;
    return s.substr(pos, len);
  };
  HxOverrides.remove = function(a, obj) {
    var i = 0;
    var l = a.length;
    while (i < l) {
      if (a[i] == obj) {
        a.splice(i, 1);
        return true;
      }
      i++;
    }
    return false;
  };
  HxOverrides.iter = function(a) {
    return {
      cur: 0,
      arr: a,
      hasNext: function() {
        return this.cur < this.arr.length;
      },
      next: function() {
        return this.arr[this.cur++];
      }
    };
  };
  var IntIter = function(min, max) {
    this.min = min;
    this.max = max;
  };
  IntIter.__name__ = true;
  IntIter.prototype = {
    next: function() {
      return this.min++;
    },
    hasNext: function() {
      return this.min < this.max;
    },
    __class__: IntIter
  };
  var Std = function() {
  };
  Std.__name__ = true;
  Std["is"] = function(v, t) {
    return js.Boot.__instanceof(v, t);
  };
  Std.string = function(s) {
    return js.Boot.__string_rec(s, "");
  };
  Std["int"] = function(x) {
    return x | 0;
  };
  Std.parseInt = function(x) {
    var v = parseInt(x, 10);
    if (v == 0 && (HxOverrides.cca(x, 1) == 120 || HxOverrides.cca(x, 1) == 88))
      v = parseInt(x);
    if (isNaN(v))
      return null;
    return v;
  };
  Std.parseFloat = function(x) {
    return parseFloat(x);
  };
  Std.random = function(x) {
    return Math.floor(Math.random() * x);
  };
  var com = com || {};
  if (!com.wiris)
    com.wiris = {};
  if (!com.wiris.js)
    com.wiris.js = {};
  com.wiris.js.JsPluginTools = function() {
    this.tryReady();
  };
  com.wiris.js.JsPluginTools.__name__ = true;
  com.wiris.js.JsPluginTools.main = function() {
    var ev;
    ev = com.wiris.js.JsPluginTools.getInstance();
    haxe.Timer.delay($bind(ev, ev.tryReady), 100);
  };
  com.wiris.js.JsPluginTools.getInstance = function() {
    if (com.wiris.js.JsPluginTools.instance == null)
      com.wiris.js.JsPluginTools.instance = new com.wiris.js.JsPluginTools();
    return com.wiris.js.JsPluginTools.instance;
  };
  com.wiris.js.JsPluginTools.bypassEncapsulation = function() {
    if (window.com == null)
      window.com = {};
    if (window.com.wiris == null)
      window.com.wiris = {};
    if (window.com.wiris.js == null)
      window.com.wiris.js = {};
    if (window.com.wiris.js.JsPluginTools == null)
      window.com.wiris.js.JsPluginTools = com.wiris.js.JsPluginTools.getInstance();
  };
  com.wiris.js.JsPluginTools.prototype = {
    md5encode: function(content) {
      return haxe.Md5.encode(content);
    },
    doLoad: function() {
      this.ready = true;
      com.wiris.js.JsPluginTools.instance = this;
      com.wiris.js.JsPluginTools.bypassEncapsulation();
    },
    tryReady: function() {
      this.ready = false;
      if (js.Lib.document.readyState) {
        this.doLoad();
        this.ready = true;
      }
      if (!this.ready)
        haxe.Timer.delay($bind(this, this.tryReady), 100);
    },
    __class__: com.wiris.js.JsPluginTools
  };
  var haxe = haxe || {};
  haxe.Log = function() {
  };
  haxe.Log.__name__ = true;
  haxe.Log.trace = function(v, infos) {
    js.Boot.__trace(v, infos);
  };
  haxe.Log.clear = function() {
    js.Boot.__clear_trace();
  };
  haxe.Md5 = function() {
  };
  haxe.Md5.__name__ = true;
  haxe.Md5.encode = function(s) {
    return new haxe.Md5().doEncode(s);
  };
  haxe.Md5.prototype = {
    doEncode: function(str) {
      var x = this.str2blks(str);
      var a = 1732584193;
      var b = -271733879;
      var c = -1732584194;
      var d = 271733878;
      var step;
      var i = 0;
      while (i < x.length) {
        var olda = a;
        var oldb = b;
        var oldc = c;
        var oldd = d;
        step = 0;
        a = this.ff(a, b, c, d, x[i], 7, -680876936);
        d = this.ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = this.ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = this.ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = this.ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = this.ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = this.ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = this.ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = this.ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = this.ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = this.ff(c, d, a, b, x[i + 10], 17, -42063);
        b = this.ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = this.ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = this.ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = this.ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = this.ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = this.gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = this.gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = this.gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = this.gg(b, c, d, a, x[i], 20, -373897302);
        a = this.gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = this.gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = this.gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = this.gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = this.gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = this.gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = this.gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = this.gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = this.gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = this.gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = this.gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = this.gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = this.hh(a, b, c, d, x[i + 5], 4, -378558);
        d = this.hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = this.hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = this.hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = this.hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = this.hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = this.hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = this.hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = this.hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = this.hh(d, a, b, c, x[i], 11, -358537222);
        c = this.hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = this.hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = this.hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = this.hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = this.hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = this.hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = this.ii(a, b, c, d, x[i], 6, -198630844);
        d = this.ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = this.ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = this.ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = this.ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = this.ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = this.ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = this.ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = this.ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = this.ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = this.ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = this.ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = this.ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = this.ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = this.ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = this.ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = this.addme(a, olda);
        b = this.addme(b, oldb);
        c = this.addme(c, oldc);
        d = this.addme(d, oldd);
        i += 16;
      }
      return this.rhex(a) + this.rhex(b) + this.rhex(c) + this.rhex(d);
    },
    ii: function(a, b, c, d, x, s, t) {
      return this.cmn(this.bitXOR(c, this.bitOR(b, ~d)), a, b, x, s, t);
    },
    hh: function(a, b, c, d, x, s, t) {
      return this.cmn(this.bitXOR(this.bitXOR(b, c), d), a, b, x, s, t);
    },
    gg: function(a, b, c, d, x, s, t) {
      return this.cmn(this.bitOR(this.bitAND(b, d), this.bitAND(c, ~d)), a, b, x, s, t);
    },
    ff: function(a, b, c, d, x, s, t) {
      return this.cmn(this.bitOR(this.bitAND(b, c), this.bitAND(~b, d)), a, b, x, s, t);
    },
    cmn: function(q, a, b, x, s, t) {
      return this.addme(this.rol(this.addme(this.addme(a, q), this.addme(x, t)), s), b);
    },
    rol: function(num, cnt) {
      return num << cnt | num >>> 32 - cnt;
    },
    str2blks: function(str) {
      var nblk = (str.length + 8 >> 6) + 1;
      var blks = new Array();
      var _g1 = 0, _g = nblk * 16;
      while (_g1 < _g) {
        var i = _g1++;
        blks[i] = 0;
      }
      var i = 0;
      while (i < str.length) {
        blks[i >> 2] |= HxOverrides.cca(str, i) << (str.length * 8 + i) % 4 * 8;
        i++;
      }
      blks[i >> 2] |= 128 << (str.length * 8 + i) % 4 * 8;
      var l = str.length * 8;
      var k = nblk * 16 - 2;
      blks[k] = l & 255;
      blks[k] |= (l >>> 8 & 255) << 8;
      blks[k] |= (l >>> 16 & 255) << 16;
      blks[k] |= (l >>> 24 & 255) << 24;
      return blks;
    },
    rhex: function(num) {
      var str = "";
      var hex_chr = "0123456789abcdef";
      var _g = 0;
      while (_g < 4) {
        var j = _g++;
        str += hex_chr.charAt(num >> j * 8 + 4 & 15) + hex_chr.charAt(num >> j * 8 & 15);
      }
      return str;
    },
    addme: function(x, y) {
      var lsw = (x & 65535) + (y & 65535);
      var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
      return msw << 16 | lsw & 65535;
    },
    bitAND: function(a, b) {
      var lsb = a & 1 & (b & 1);
      var msb31 = a >>> 1 & b >>> 1;
      return msb31 << 1 | lsb;
    },
    bitXOR: function(a, b) {
      var lsb = a & 1 ^ b & 1;
      var msb31 = a >>> 1 ^ b >>> 1;
      return msb31 << 1 | lsb;
    },
    bitOR: function(a, b) {
      var lsb = a & 1 | b & 1;
      var msb31 = a >>> 1 | b >>> 1;
      return msb31 << 1 | lsb;
    },
    __class__: haxe.Md5
  };
  haxe.Timer = function(time_ms) {
    var me = this;
    this.id = window.setInterval(function() {
      me.run();
    }, time_ms);
  };
  haxe.Timer.__name__ = true;
  haxe.Timer.delay = function(f, time_ms) {
    var t = new haxe.Timer(time_ms);
    t.run = function() {
      t.stop();
      f();
    };
    return t;
  };
  haxe.Timer.measure = function(f, pos) {
    var t0 = haxe.Timer.stamp();
    var r = f();
    haxe.Log.trace(haxe.Timer.stamp() - t0 + "s", pos);
    return r;
  };
  haxe.Timer.stamp = function() {
    return (/* @__PURE__ */ new Date()).getTime() / 1e3;
  };
  haxe.Timer.prototype = {
    run: function() {
    },
    stop: function() {
      if (this.id == null)
        return;
      window.clearInterval(this.id);
      this.id = null;
    },
    __class__: haxe.Timer
  };
  var js = js || {};
  js.Boot = function() {
  };
  js.Boot.__name__ = true;
  js.Boot.__unhtml = function(s) {
    return s.split("&").join("&amp;").split("<").join("&lt;").split(">").join("&gt;");
  };
  js.Boot.__trace = function(v, i) {
    var msg = i != null ? i.fileName + ":" + i.lineNumber + ": " : "";
    msg += js.Boot.__string_rec(v, "");
    var d;
    if (typeof document != "undefined" && (d = document.getElementById("haxe:trace")) != null)
      d.innerHTML += js.Boot.__unhtml(msg) + "<br/>";
    else if (typeof console != "undefined" && console.log != null)
      console.log(msg);
  };
  js.Boot.__clear_trace = function() {
    var d = document.getElementById("haxe:trace");
    if (d != null)
      d.innerHTML = "";
  };
  js.Boot.isClass = function(o) {
    return o.__name__;
  };
  js.Boot.isEnum = function(e) {
    return e.__ename__;
  };
  js.Boot.getClass = function(o) {
    return o.__class__;
  };
  js.Boot.__string_rec = function(o, s) {
    if (o == null)
      return "null";
    if (s.length >= 5)
      return "<...>";
    var t = typeof o;
    if (t == "function" && (o.__name__ || o.__ename__))
      t = "object";
    switch (t) {
      case "object":
        if (o instanceof Array) {
          if (o.__enum__) {
            if (o.length == 2)
              return o[0];
            var str = o[0] + "(";
            s += "	";
            var _g1 = 2, _g = o.length;
            while (_g1 < _g) {
              var i = _g1++;
              if (i != 2)
                str += "," + js.Boot.__string_rec(o[i], s);
              else
                str += js.Boot.__string_rec(o[i], s);
            }
            return str + ")";
          }
          var l = o.length;
          var i;
          var str = "[";
          s += "	";
          var _g = 0;
          while (_g < l) {
            var i1 = _g++;
            str += (i1 > 0 ? "," : "") + js.Boot.__string_rec(o[i1], s);
          }
          str += "]";
          return str;
        }
        var tostr;
        try {
          tostr = o.toString;
        } catch (e) {
          return "???";
        }
        if (tostr != null && tostr != Object.toString) {
          var s2 = o.toString();
          if (s2 != "[object Object]")
            return s2;
        }
        var k = null;
        var str = "{\n";
        s += "	";
        var hasp = o.hasOwnProperty != null;
        for (var k in o) {
          ;
          if (hasp && !o.hasOwnProperty(k)) {
            continue;
          }
          if (k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
            continue;
          }
          if (str.length != 2)
            str += ", \n";
          str += s + k + " : " + js.Boot.__string_rec(o[k], s);
        }
        s = s.substring(1);
        str += "\n" + s + "}";
        return str;
      case "function":
        return "<function>";
      case "string":
        return o;
      default:
        return String(o);
    }
  };
  js.Boot.__interfLoop = function(cc, cl) {
    if (cc == null)
      return false;
    if (cc == cl)
      return true;
    var intf = cc.__interfaces__;
    if (intf != null) {
      var _g1 = 0, _g = intf.length;
      while (_g1 < _g) {
        var i = _g1++;
        var i1 = intf[i];
        if (i1 == cl || js.Boot.__interfLoop(i1, cl))
          return true;
      }
    }
    return js.Boot.__interfLoop(cc.__super__, cl);
  };
  js.Boot.__instanceof = function(o, cl) {
    try {
      if (o instanceof cl) {
        if (cl == Array)
          return o.__enum__ == null;
        return true;
      }
      if (js.Boot.__interfLoop(o.__class__, cl))
        return true;
    } catch (e) {
      if (cl == null)
        return false;
    }
    switch (cl) {
      case Int:
        return Math.ceil(o % 2147483648) === o;
      case Float:
        return typeof o == "number";
      case Bool:
        return o === true || o === false;
      case String:
        return typeof o == "string";
      case Dynamic:
        return true;
      default:
        if (o == null)
          return false;
        if (cl == Class && o.__name__ != null)
          return true;
        else
          null;
        if (cl == Enum && o.__ename__ != null)
          return true;
        else
          null;
        return o.__enum__ == cl;
    }
  };
  js.Boot.__cast = function(o, t) {
    if (js.Boot.__instanceof(o, t))
      return o;
    else
      throw "Cannot cast " + Std.string(o) + " to " + Std.string(t);
  };
  js.Lib = function() {
  };
  js.Lib.__name__ = true;
  js.Lib.debug = function() {
    debugger;
  };
  js.Lib.alert = function(v) {
    alert(js.Boot.__string_rec(v, ""));
  };
  js.Lib.eval = function(code) {
    return eval(code);
  };
  js.Lib.setErrorHandler = function(f) {
    js.Lib.onerror = f;
  };
  var $_;
  function $bind(o, m) {
    var f = function() {
      return f.method.apply(f.scope, arguments);
    };
    f.scope = o;
    f.method = m;
    return f;
  }
  ;
  if (Array.prototype.indexOf)
    HxOverrides.remove = function(a, o) {
      var i = a.indexOf(o);
      if (i == -1)
        return false;
      a.splice(i, 1);
      return true;
    };
  else
    null;
  Math.__name__ = ["Math"];
  Math.NaN = Number.NaN;
  Math.NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY;
  Math.POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
  Math.isFinite = function(i) {
    return isFinite(i);
  };
  Math.isNaN = function(i) {
    return isNaN(i);
  };
  String.prototype.__class__ = String;
  String.__name__ = true;
  Array.prototype.__class__ = Array;
  Array.__name__ = true;
  Date.prototype.__class__ = Date;
  Date.__name__ = ["Date"];
  var Int = { __name__: ["Int"] };
  var Dynamic = { __name__: ["Dynamic"] };
  var Float = Number;
  Float.__name__ = ["Float"];
  var Bool = Boolean;
  Bool.__ename__ = ["Bool"];
  var Class = { __name__: ["Class"] };
  var Enum = {};
  var Void = { __ename__: ["Void"] };
  if (typeof document != "undefined")
    js.Lib.document = document;
  if (typeof window != "undefined") {
    js.Lib.window = window;
    js.Lib.window.onerror = function(msg, url, line) {
      var f = js.Lib.onerror;
      if (f == null)
        return false;
      return f(msg, [url + ":" + line]);
    };
  }
  com.wiris.js.JsPluginTools.main();
  delete Array.prototype.__class__;
})();
(function() {
  var HxOverrides = function() {
  };
  HxOverrides.__name__ = true;
  HxOverrides.dateStr = function(date) {
    var m = date.getMonth() + 1;
    var d = date.getDate();
    var h = date.getHours();
    var mi = date.getMinutes();
    var s = date.getSeconds();
    return date.getFullYear() + "-" + (m < 10 ? "0" + m : "" + m) + "-" + (d < 10 ? "0" + d : "" + d) + " " + (h < 10 ? "0" + h : "" + h) + ":" + (mi < 10 ? "0" + mi : "" + mi) + ":" + (s < 10 ? "0" + s : "" + s);
  };
  HxOverrides.strDate = function(s) {
    switch (s.length) {
      case 8:
        var k = s.split(":");
        var d = /* @__PURE__ */ new Date();
        d.setTime(0);
        d.setUTCHours(k[0]);
        d.setUTCMinutes(k[1]);
        d.setUTCSeconds(k[2]);
        return d;
      case 10:
        var k = s.split("-");
        return new Date(k[0], k[1] - 1, k[2], 0, 0, 0);
      case 19:
        var k = s.split(" ");
        var y = k[0].split("-");
        var t = k[1].split(":");
        return new Date(y[0], y[1] - 1, y[2], t[0], t[1], t[2]);
      default:
        throw "Invalid date format : " + s;
    }
  };
  HxOverrides.cca = function(s, index) {
    var x = s.charCodeAt(index);
    if (x != x)
      return void 0;
    return x;
  };
  HxOverrides.substr = function(s, pos, len) {
    if (pos != null && pos != 0 && len != null && len < 0)
      return "";
    if (len == null)
      len = s.length;
    if (pos < 0) {
      pos = s.length + pos;
      if (pos < 0)
        pos = 0;
    } else if (len < 0)
      len = s.length + len - pos;
    return s.substr(pos, len);
  };
  HxOverrides.remove = function(a, obj) {
    var i = 0;
    var l = a.length;
    while (i < l) {
      if (a[i] == obj) {
        a.splice(i, 1);
        return true;
      }
      i++;
    }
    return false;
  };
  HxOverrides.iter = function(a) {
    return {
      cur: 0,
      arr: a,
      hasNext: function() {
        return this.cur < this.arr.length;
      },
      next: function() {
        return this.arr[this.cur++];
      }
    };
  };
  var IntIter = function(min, max) {
    this.min = min;
    this.max = max;
  };
  IntIter.__name__ = true;
  IntIter.prototype = {
    next: function() {
      return this.min++;
    },
    hasNext: function() {
      return this.min < this.max;
    },
    __class__: IntIter
  };
  var Std = function() {
  };
  Std.__name__ = true;
  Std["is"] = function(v, t) {
    return js.Boot.__instanceof(v, t);
  };
  Std.string = function(s) {
    return js.Boot.__string_rec(s, "");
  };
  Std["int"] = function(x) {
    return x | 0;
  };
  Std.parseInt = function(x) {
    var v = parseInt(x, 10);
    if (v == 0 && (HxOverrides.cca(x, 1) == 120 || HxOverrides.cca(x, 1) == 88))
      v = parseInt(x);
    if (isNaN(v))
      return null;
    return v;
  };
  Std.parseFloat = function(x) {
    return parseFloat(x);
  };
  Std.random = function(x) {
    return Math.floor(Math.random() * x);
  };
  var com = com || {};
  if (!com.wiris)
    com.wiris = {};
  if (!com.wiris.js)
    com.wiris.js = {};
  com.wiris.js.JsPluginTools = function() {
    this.tryReady();
  };
  com.wiris.js.JsPluginTools.__name__ = true;
  com.wiris.js.JsPluginTools.main = function() {
    var ev;
    ev = com.wiris.js.JsPluginTools.getInstance();
    haxe.Timer.delay($bind(ev, ev.tryReady), 100);
  };
  com.wiris.js.JsPluginTools.getInstance = function() {
    if (com.wiris.js.JsPluginTools.instance == null)
      com.wiris.js.JsPluginTools.instance = new com.wiris.js.JsPluginTools();
    return com.wiris.js.JsPluginTools.instance;
  };
  com.wiris.js.JsPluginTools.bypassEncapsulation = function() {
    if (window.com == null)
      window.com = {};
    if (window.com.wiris == null)
      window.com.wiris = {};
    if (window.com.wiris.js == null)
      window.com.wiris.js = {};
    if (window.com.wiris.js.JsPluginTools == null)
      window.com.wiris.js.JsPluginTools = com.wiris.js.JsPluginTools.getInstance();
  };
  com.wiris.js.JsPluginTools.prototype = {
    md5encode: function(content) {
      return haxe.Md5.encode(content);
    },
    doLoad: function() {
      this.ready = true;
      com.wiris.js.JsPluginTools.instance = this;
      com.wiris.js.JsPluginTools.bypassEncapsulation();
    },
    tryReady: function() {
      this.ready = false;
      if (js.Lib.document.readyState) {
        this.doLoad();
        this.ready = true;
      }
      if (!this.ready)
        haxe.Timer.delay($bind(this, this.tryReady), 100);
    },
    __class__: com.wiris.js.JsPluginTools
  };
  var haxe = haxe || {};
  haxe.Log = function() {
  };
  haxe.Log.__name__ = true;
  haxe.Log.trace = function(v, infos) {
    js.Boot.__trace(v, infos);
  };
  haxe.Log.clear = function() {
    js.Boot.__clear_trace();
  };
  haxe.Md5 = function() {
  };
  haxe.Md5.__name__ = true;
  haxe.Md5.encode = function(s) {
    return new haxe.Md5().doEncode(s);
  };
  haxe.Md5.prototype = {
    doEncode: function(str) {
      var x = this.str2blks(str);
      var a = 1732584193;
      var b = -271733879;
      var c = -1732584194;
      var d = 271733878;
      var step;
      var i = 0;
      while (i < x.length) {
        var olda = a;
        var oldb = b;
        var oldc = c;
        var oldd = d;
        step = 0;
        a = this.ff(a, b, c, d, x[i], 7, -680876936);
        d = this.ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = this.ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = this.ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = this.ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = this.ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = this.ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = this.ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = this.ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = this.ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = this.ff(c, d, a, b, x[i + 10], 17, -42063);
        b = this.ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = this.ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = this.ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = this.ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = this.ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = this.gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = this.gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = this.gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = this.gg(b, c, d, a, x[i], 20, -373897302);
        a = this.gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = this.gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = this.gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = this.gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = this.gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = this.gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = this.gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = this.gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = this.gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = this.gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = this.gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = this.gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = this.hh(a, b, c, d, x[i + 5], 4, -378558);
        d = this.hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = this.hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = this.hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = this.hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = this.hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = this.hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = this.hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = this.hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = this.hh(d, a, b, c, x[i], 11, -358537222);
        c = this.hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = this.hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = this.hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = this.hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = this.hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = this.hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = this.ii(a, b, c, d, x[i], 6, -198630844);
        d = this.ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = this.ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = this.ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = this.ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = this.ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = this.ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = this.ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = this.ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = this.ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = this.ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = this.ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = this.ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = this.ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = this.ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = this.ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = this.addme(a, olda);
        b = this.addme(b, oldb);
        c = this.addme(c, oldc);
        d = this.addme(d, oldd);
        i += 16;
      }
      return this.rhex(a) + this.rhex(b) + this.rhex(c) + this.rhex(d);
    },
    ii: function(a, b, c, d, x, s, t) {
      return this.cmn(this.bitXOR(c, this.bitOR(b, ~d)), a, b, x, s, t);
    },
    hh: function(a, b, c, d, x, s, t) {
      return this.cmn(this.bitXOR(this.bitXOR(b, c), d), a, b, x, s, t);
    },
    gg: function(a, b, c, d, x, s, t) {
      return this.cmn(this.bitOR(this.bitAND(b, d), this.bitAND(c, ~d)), a, b, x, s, t);
    },
    ff: function(a, b, c, d, x, s, t) {
      return this.cmn(this.bitOR(this.bitAND(b, c), this.bitAND(~b, d)), a, b, x, s, t);
    },
    cmn: function(q, a, b, x, s, t) {
      return this.addme(this.rol(this.addme(this.addme(a, q), this.addme(x, t)), s), b);
    },
    rol: function(num, cnt) {
      return num << cnt | num >>> 32 - cnt;
    },
    str2blks: function(str) {
      var nblk = (str.length + 8 >> 6) + 1;
      var blks = new Array();
      var _g1 = 0, _g = nblk * 16;
      while (_g1 < _g) {
        var i = _g1++;
        blks[i] = 0;
      }
      var i = 0;
      while (i < str.length) {
        blks[i >> 2] |= HxOverrides.cca(str, i) << (str.length * 8 + i) % 4 * 8;
        i++;
      }
      blks[i >> 2] |= 128 << (str.length * 8 + i) % 4 * 8;
      var l = str.length * 8;
      var k = nblk * 16 - 2;
      blks[k] = l & 255;
      blks[k] |= (l >>> 8 & 255) << 8;
      blks[k] |= (l >>> 16 & 255) << 16;
      blks[k] |= (l >>> 24 & 255) << 24;
      return blks;
    },
    rhex: function(num) {
      var str = "";
      var hex_chr = "0123456789abcdef";
      var _g = 0;
      while (_g < 4) {
        var j = _g++;
        str += hex_chr.charAt(num >> j * 8 + 4 & 15) + hex_chr.charAt(num >> j * 8 & 15);
      }
      return str;
    },
    addme: function(x, y) {
      var lsw = (x & 65535) + (y & 65535);
      var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
      return msw << 16 | lsw & 65535;
    },
    bitAND: function(a, b) {
      var lsb = a & 1 & (b & 1);
      var msb31 = a >>> 1 & b >>> 1;
      return msb31 << 1 | lsb;
    },
    bitXOR: function(a, b) {
      var lsb = a & 1 ^ b & 1;
      var msb31 = a >>> 1 ^ b >>> 1;
      return msb31 << 1 | lsb;
    },
    bitOR: function(a, b) {
      var lsb = a & 1 | b & 1;
      var msb31 = a >>> 1 | b >>> 1;
      return msb31 << 1 | lsb;
    },
    __class__: haxe.Md5
  };
  haxe.Timer = function(time_ms) {
    var me = this;
    this.id = window.setInterval(function() {
      me.run();
    }, time_ms);
  };
  haxe.Timer.__name__ = true;
  haxe.Timer.delay = function(f, time_ms) {
    var t = new haxe.Timer(time_ms);
    t.run = function() {
      t.stop();
      f();
    };
    return t;
  };
  haxe.Timer.measure = function(f, pos) {
    var t0 = haxe.Timer.stamp();
    var r = f();
    haxe.Log.trace(haxe.Timer.stamp() - t0 + "s", pos);
    return r;
  };
  haxe.Timer.stamp = function() {
    return (/* @__PURE__ */ new Date()).getTime() / 1e3;
  };
  haxe.Timer.prototype = {
    run: function() {
    },
    stop: function() {
      if (this.id == null)
        return;
      window.clearInterval(this.id);
      this.id = null;
    },
    __class__: haxe.Timer
  };
  var js = js || {};
  js.Boot = function() {
  };
  js.Boot.__name__ = true;
  js.Boot.__unhtml = function(s) {
    return s.split("&").join("&amp;").split("<").join("&lt;").split(">").join("&gt;");
  };
  js.Boot.__trace = function(v, i) {
    var msg = i != null ? i.fileName + ":" + i.lineNumber + ": " : "";
    msg += js.Boot.__string_rec(v, "");
    var d;
    if (typeof document != "undefined" && (d = document.getElementById("haxe:trace")) != null)
      d.innerHTML += js.Boot.__unhtml(msg) + "<br/>";
    else if (typeof console != "undefined" && console.log != null)
      console.log(msg);
  };
  js.Boot.__clear_trace = function() {
    var d = document.getElementById("haxe:trace");
    if (d != null)
      d.innerHTML = "";
  };
  js.Boot.isClass = function(o) {
    return o.__name__;
  };
  js.Boot.isEnum = function(e) {
    return e.__ename__;
  };
  js.Boot.getClass = function(o) {
    return o.__class__;
  };
  js.Boot.__string_rec = function(o, s) {
    if (o == null)
      return "null";
    if (s.length >= 5)
      return "<...>";
    var t = typeof o;
    if (t == "function" && (o.__name__ || o.__ename__))
      t = "object";
    switch (t) {
      case "object":
        if (o instanceof Array) {
          if (o.__enum__) {
            if (o.length == 2)
              return o[0];
            var str = o[0] + "(";
            s += "	";
            var _g1 = 2, _g = o.length;
            while (_g1 < _g) {
              var i = _g1++;
              if (i != 2)
                str += "," + js.Boot.__string_rec(o[i], s);
              else
                str += js.Boot.__string_rec(o[i], s);
            }
            return str + ")";
          }
          var l = o.length;
          var i;
          var str = "[";
          s += "	";
          var _g = 0;
          while (_g < l) {
            var i1 = _g++;
            str += (i1 > 0 ? "," : "") + js.Boot.__string_rec(o[i1], s);
          }
          str += "]";
          return str;
        }
        var tostr;
        try {
          tostr = o.toString;
        } catch (e) {
          return "???";
        }
        if (tostr != null && tostr != Object.toString) {
          var s2 = o.toString();
          if (s2 != "[object Object]")
            return s2;
        }
        var k = null;
        var str = "{\n";
        s += "	";
        var hasp = o.hasOwnProperty != null;
        for (var k in o) {
          ;
          if (hasp && !o.hasOwnProperty(k)) {
            continue;
          }
          if (k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
            continue;
          }
          if (str.length != 2)
            str += ", \n";
          str += s + k + " : " + js.Boot.__string_rec(o[k], s);
        }
        s = s.substring(1);
        str += "\n" + s + "}";
        return str;
      case "function":
        return "<function>";
      case "string":
        return o;
      default:
        return String(o);
    }
  };
  js.Boot.__interfLoop = function(cc, cl) {
    if (cc == null)
      return false;
    if (cc == cl)
      return true;
    var intf = cc.__interfaces__;
    if (intf != null) {
      var _g1 = 0, _g = intf.length;
      while (_g1 < _g) {
        var i = _g1++;
        var i1 = intf[i];
        if (i1 == cl || js.Boot.__interfLoop(i1, cl))
          return true;
      }
    }
    return js.Boot.__interfLoop(cc.__super__, cl);
  };
  js.Boot.__instanceof = function(o, cl) {
    try {
      if (o instanceof cl) {
        if (cl == Array)
          return o.__enum__ == null;
        return true;
      }
      if (js.Boot.__interfLoop(o.__class__, cl))
        return true;
    } catch (e) {
      if (cl == null)
        return false;
    }
    switch (cl) {
      case Int:
        return Math.ceil(o % 2147483648) === o;
      case Float:
        return typeof o == "number";
      case Bool:
        return o === true || o === false;
      case String:
        return typeof o == "string";
      case Dynamic:
        return true;
      default:
        if (o == null)
          return false;
        if (cl == Class && o.__name__ != null)
          return true;
        else
          null;
        if (cl == Enum && o.__ename__ != null)
          return true;
        else
          null;
        return o.__enum__ == cl;
    }
  };
  js.Boot.__cast = function(o, t) {
    if (js.Boot.__instanceof(o, t))
      return o;
    else
      throw "Cannot cast " + Std.string(o) + " to " + Std.string(t);
  };
  js.Lib = function() {
  };
  js.Lib.__name__ = true;
  js.Lib.debug = function() {
    debugger;
  };
  js.Lib.alert = function(v) {
    alert(js.Boot.__string_rec(v, ""));
  };
  js.Lib.eval = function(code) {
    return eval(code);
  };
  js.Lib.setErrorHandler = function(f) {
    js.Lib.onerror = f;
  };
  var $_;
  function $bind(o, m) {
    var f = function() {
      return f.method.apply(f.scope, arguments);
    };
    f.scope = o;
    f.method = m;
    return f;
  }
  ;
  if (Array.prototype.indexOf)
    HxOverrides.remove = function(a, o) {
      var i = a.indexOf(o);
      if (i == -1)
        return false;
      a.splice(i, 1);
      return true;
    };
  else
    null;
  Math.__name__ = ["Math"];
  Math.NaN = Number.NaN;
  Math.NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY;
  Math.POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
  Math.isFinite = function(i) {
    return isFinite(i);
  };
  Math.isNaN = function(i) {
    return isNaN(i);
  };
  String.prototype.__class__ = String;
  String.__name__ = true;
  Array.prototype.__class__ = Array;
  Array.__name__ = true;
  Date.prototype.__class__ = Date;
  Date.__name__ = ["Date"];
  var Int = { __name__: ["Int"] };
  var Dynamic = { __name__: ["Dynamic"] };
  var Float = Number;
  Float.__name__ = ["Float"];
  var Bool = Boolean;
  Bool.__ename__ = ["Bool"];
  var Class = { __name__: ["Class"] };
  var Enum = {};
  var Void = { __ename__: ["Void"] };
  if (typeof document != "undefined")
    js.Lib.document = document;
  if (typeof window != "undefined") {
    js.Lib.window = window;
    js.Lib.window.onerror = function(msg, url, line) {
      var f = js.Lib.onerror;
      if (f == null)
        return false;
      return f(msg, [url + ":" + line]);
    };
  }
  com.wiris.js.JsPluginTools.main();
})();
delete Array.prototype.__class__;

// node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/src/parser.js
var Parser = class _Parser {
  /**
   * Converts a MathML string to an img element.
   * @param {Document} creator - Document object to call createElement method.
   * @param {string} mathml - MathML code
   * @param {Object[]} wirisProperties - object containing WIRIS custom properties
   * @param {language} language - custom language for accessibility.
   * @returns {HTMLImageElement} the formula image corresponding to initial MathML string.
   * @static
   */
  static mathmlToImgObject(creator, mathml, wirisProperties, language) {
    const imgObject = creator.createElement("img");
    imgObject.align = "middle";
    imgObject.style.maxWidth = "none";
    let data = wirisProperties || {};
    const wirisEditorProperties = Configuration.get("editorParameters");
    data = { ...wirisEditorProperties, ...data };
    data.mml = mathml;
    data.lang = language;
    data.metrics = "true";
    data.centerbaseline = "false";
    if (Configuration.get("saveMode") === "base64" && Configuration.get("base64savemode") === "default") {
      data.base64 = true;
    }
    imgObject.className = Configuration.get("imageClassName");
    if (mathml.indexOf('class="') !== -1) {
      let mathmlSubstring = mathml.substring(mathml.indexOf('class="') + 'class="'.length, mathml.length);
      mathmlSubstring = mathmlSubstring.substring(0, mathmlSubstring.indexOf('"'));
      mathmlSubstring = mathmlSubstring.substring(4, mathmlSubstring.length);
      imgObject.setAttribute(Configuration.get("imageCustomEditorName"), mathmlSubstring);
    }
    if (Configuration.get("wirisPluginPerformance") && (Configuration.get("saveMode") === "xml" || Configuration.get("saveMode") === "safeXml")) {
      let result = JSON.parse(_Parser.createShowImageSrc(data, language));
      if (result.status === "warning") {
        try {
          result = JSON.parse(ServiceProvider.getService("showimage", data));
        } catch (e) {
          return null;
        }
      }
      ({ result } = result);
      if (result.format === "png") {
        imgObject.src = `data:image/png;base64,${result.content}`;
      } else {
        imgObject.src = `data:image/svg+xml;charset=utf8,${Util.urlEncode(result.content)}`;
      }
      imgObject.setAttribute(Configuration.get("imageMathmlAttribute"), MathML.safeXmlEncode(mathml));
      Image.setImgSize(imgObject, result.content, true);
      if (Configuration.get("enableAccessibility")) {
        if (typeof result.alt === "undefined") {
          imgObject.alt = Accessibility.mathMLToAccessible(mathml, language, data);
        } else {
          imgObject.alt = result.alt;
        }
      }
    } else {
      const result = _Parser.createImageSrc(mathml, data);
      imgObject.setAttribute(Configuration.get("imageMathmlAttribute"), MathML.safeXmlEncode(mathml));
      imgObject.src = result;
      Image.setImgSize(imgObject, result, Configuration.get("saveMode") === "base64" && Configuration.get("base64savemode") === "default");
      if (Configuration.get("enableAccessibility")) {
        imgObject.alt = Accessibility.mathMLToAccessible(mathml, language, data);
      }
    }
    if (typeof _Parser.observer !== "undefined") {
      _Parser.observer.observe(imgObject);
    }
    imgObject.setAttribute("role", "math");
    return imgObject;
  }
  /**
   * Returns the source to showimage service by calling createimage service. The
   * output of the createimage service is a URL path pointing to showimage service.
   * This method is called when performance is disabled.
   * @param {string} mathml - MathML code.
   * @param {Object[]} data - data object containing service parameters.
   * @returns {string} the showimage path.
   */
  static createImageSrc(mathml, data) {
    if (Configuration.get("saveMode") === "base64" && Configuration.get("base64savemode") === "default") {
      data.base64 = true;
    }
    let result = ServiceProvider.getService("createimage", data);
    if (result.indexOf("@BASE@") !== -1) {
      const baseParts = ServiceProvider.getServicePath("createimage").split("/");
      baseParts.pop();
      result = result.split("@BASE@").join(baseParts.join("/"));
    }
    return result;
  }
  /**
   * Parses initial HTML code. If the HTML contains data generated by WIRIS,
   * this data would be converted as following:
   * <pre>
   * MathML code: Image containing the corresponding MathML formulas.
   * MathML code with LaTeX annotation : LaTeX string.
   * </pre>
   * @param {string} code - HTML code containing MathML data.
   * @param {string} language - language to create image alt text.
   * @returns {string} HTML code with the original MathML converted into LaTeX and images.
   */
  static initParse(code2, language) {
    code2 = _Parser.initParseSaveMode(code2, language);
    return _Parser.initParseEditMode(code2);
  }
  /**
   * Parses initial HTML code depending on the save mode. Transforms all MathML
   * occurrences for it's correspondent image or LaTeX.
   * @param {string} code - HTML code to be parsed
   * @param {string} language - language to create image alt text.
   * @returns {string} HTML code parsed.
   */
  static initParseSaveMode(code2, language) {
    if (Configuration.get("saveMode")) {
      code2 = Latex.parseMathmlToLatex(code2, Constants.safeXmlCharacters);
      code2 = Latex.parseMathmlToLatex(code2, Constants.xmlCharacters);
      code2 = _Parser.parseMathmlToImg(code2, Constants.safeXmlCharacters, language);
      code2 = _Parser.parseMathmlToImg(code2, Constants.xmlCharacters, language);
      if (Configuration.get("saveMode") === "base64" && Configuration.get("base64savemode") === "image") {
        code2 = _Parser.codeImgTransform(code2, "base642showimage");
      }
    }
    return code2;
  }
  /**
   * Parses initial HTML code depending on the edit mode.
   * If 'latex' parseMode is enabled all MathML containing an annotation with encoding='LaTeX' will
   * be converted into a LaTeX string instead of an image.
   * @param {string} code - HTML code containing MathML.
   * @returns {string} parsed HTML code.
   */
  static initParseEditMode(code2) {
    if (Configuration.get("parseModes").indexOf("latex") !== -1) {
      const imgList = Util.getElementsByNameFromString(code2, "img", true);
      const token = 'encoding="LaTeX">';
      let carry = 0;
      for (let i = 0; i < imgList.length; i += 1) {
        const imgCode = code2.substring(imgList[i].start + carry, imgList[i].end + carry);
        if (imgCode.indexOf(` class="${Configuration.get("imageClassName")}"`) !== -1) {
          let mathmlStartToken = ` ${Configuration.get("imageMathmlAttribute")}="`;
          let mathmlStart = imgCode.indexOf(mathmlStartToken);
          if (mathmlStart === -1) {
            mathmlStartToken = ' alt="';
            mathmlStart = imgCode.indexOf(mathmlStartToken);
          }
          if (mathmlStart !== -1) {
            mathmlStart += mathmlStartToken.length;
            const mathmlEnd = imgCode.indexOf('"', mathmlStart);
            const mathml = Util.htmlSanitize(MathML.safeXmlDecode(imgCode.substring(mathmlStart, mathmlEnd)));
            let latexStartPosition = mathml.indexOf(token);
            if (latexStartPosition !== -1) {
              latexStartPosition += token.length;
              const latexEndPosition = mathml.indexOf("</annotation>", latexStartPosition);
              const latex = mathml.substring(latexStartPosition, latexEndPosition);
              const replaceText = `$$${Util.htmlEntitiesDecode(latex)}$$`;
              const start = code2.substring(0, imgList[i].start + carry);
              const end = code2.substring(imgList[i].end + carry);
              code2 = start + replaceText + end;
              carry += replaceText.length - (imgList[i].end - imgList[i].start);
            }
          }
        }
      }
    }
    return code2;
  }
  /**
   * Parses end HTML code. The end HTML code is HTML code with embedded images
   * or LaTeX formulas created with MathType. <br>
   * By default this method converts the formula images and LaTeX strings in MathML. <br>
   * If image mode is enabled the images will not be converted into MathML. For further information see {@link https://docs.wiris.com/mathtype/en/mathtype-integrations/mathtype-web-interface-features/full-mathml-mode---wirisplugins-js.html}.
   * @param {string} code - HTML to be parsed
   * @returns {string} the HTML code parsed.
   */
  static endParse(code2) {
    const codeEndParsedEditMode = _Parser.endParseEditMode(code2);
    const codeEndParseSaveMode = _Parser.endParseSaveMode(codeEndParsedEditMode);
    return codeEndParseSaveMode;
  }
  /**
   * Parses end HTML code depending on the edit mode.
   * - LaTeX is an enabled parse mode, all LaTeX occurrences will be converted into MathML.
   * @param {string} code - HTML code to be parsed.
   * @returns {string} HTML code parsed.
   */
  static endParseEditMode(code2) {
    if (Configuration.get("parseModes").indexOf("latex") !== -1) {
      let output = "";
      let endPosition = 0;
      let startPosition = code2.indexOf("$$");
      while (startPosition !== -1) {
        output += code2.substring(endPosition, startPosition);
        endPosition = code2.indexOf("$$", startPosition + 2);
        if (endPosition !== -1) {
          const latex = code2.substring(startPosition + 2, endPosition);
          const decodedLatex = Util.htmlEntitiesDecode(latex);
          let mathml = Util.htmlSanitize(Latex.getMathMLFromLatex(decodedLatex, true));
          if (!Configuration.get("saveHandTraces")) {
            mathml = MathML.removeAnnotation(mathml, "application/json");
          }
          output += mathml;
          endPosition += 2;
        } else {
          output += "$$";
          endPosition = startPosition + 2;
        }
        startPosition = code2.indexOf("$$", endPosition);
      }
      output += code2.substring(endPosition, code2.length);
      code2 = output;
    }
    return code2;
  }
  /**
   * Parses end HTML code depending on the save mode. Converts all
   * images into the element determined by the save mode:
   * - xml: Parses images formulas into MathML.
   * - safeXml: Parses images formulas into safeMAthML
   * - base64: Parses images into base64 images.
   * - image: Parse images into images (no parsing)
   * @param {string} code - HTML code to be parsed
   * @returns {string} HTML code parsed.
   */
  static endParseSaveMode(code2) {
    if (Configuration.get("saveMode")) {
      if (Configuration.get("saveMode") === "safeXml") {
        code2 = _Parser.codeImgTransform(code2, "img2mathml");
      } else if (Configuration.get("saveMode") === "xml") {
        code2 = _Parser.codeImgTransform(code2, "img2mathml");
      } else if (Configuration.get("saveMode") === "base64" && Configuration.get("base64savemode") === "image") {
        code2 = _Parser.codeImgTransform(code2, "img264");
      }
    }
    return code2;
  }
  /**
   * Auxiliar function that builds the data object to send to the showimage endpoint
   * @param {Object[]} data - object containing showimage service parameters.
   * @param {string} language - string containing the language of the formula.
   * @returns {Object} JSON object with the data to send to showimage.
   */
  static createShowImageSrcData(data, language) {
    const dataMd5 = {};
    const renderParams = ["mml", "color", "centerbaseline", "zoom", "dpi", "fontSize", "fontFamily", "defaultStretchy", "backgroundColor", "format"];
    renderParams.forEach((param) => {
      if (typeof data[param] !== "undefined") {
        dataMd5[param] = data[param];
      }
    });
    const dataObject = {};
    Object.keys(data).forEach((key) => {
      if (key !== "mml") {
        dataObject[key] = data[key];
      }
    });
    dataObject.formula = com.wiris.js.JsPluginTools.md5encode(Util.propertiesToString(dataMd5));
    dataObject.lang = typeof language === "undefined" ? "en" : language;
    dataObject.version = Configuration.get("version");
    return dataObject;
  }
  /**
   * Returns the result to call showimage service with the formula md5 as parameter.
   *  The result could be:
   * - {'status' : warning'} : The image associated to the MathML md5 is not in cache.
   * - {'status' : 'ok' ...} : The image associated to the MathML md5 is in cache.
   * @param {Object[]} data - object containing showimage service parameters.
   * @param {string} language - string containing the language of the formula.
   * @returns {Object} JSON object containing showimage response.
   */
  static createShowImageSrc(data, language) {
    const dataObject = this.createShowImageSrcData(data, language);
    const result = ServiceProvider.getService("showimage", Util.httpBuildQuery(dataObject), true);
    return result;
  }
  /**
   * Transform html img tags inside a html code to mathml, base64 img tags (i.e with base64 on src)
   * or showimage img tags (i.e with showimage.php on src)
   * @param  {string} code - HTML code
   * @param  {string} mode - base642showimage or img2mathml or img264 transform.
   * @returns {string} html - code transformed.
   */
  static codeImgTransform(code2, mode) {
    let output = "";
    let endPosition = 0;
    const pattern = /<img/gi;
    const patternLength = pattern.source.length;
    while (pattern.test(code2)) {
      const startPosition = pattern.lastIndex - patternLength;
      output += code2.substring(endPosition, startPosition);
      let i = startPosition + 1;
      while (i < code2.length && endPosition <= startPosition) {
        const character = code2.charAt(i);
        if (character === '"' || character === "'") {
          const characterNextPosition = code2.indexOf(character, i + 1);
          if (characterNextPosition === -1) {
            i = code2.length;
          } else {
            i = characterNextPosition;
          }
        } else if (character === ">") {
          endPosition = i + 1;
        }
        i += 1;
      }
      if (endPosition < startPosition) {
        output += code2.substring(startPosition, code2.length);
        return output;
      }
      let imgCode = code2.substring(startPosition, endPosition);
      const imgObject = Util.createObject(imgCode);
      let xmlCode = imgObject.getAttribute(Configuration.get("imageMathmlAttribute"));
      let convertToXml;
      let convertToSafeXml;
      if (mode === "base642showimage") {
        if (xmlCode == null) {
          xmlCode = imgObject.getAttribute("alt");
        }
        xmlCode = MathML.safeXmlDecode(xmlCode);
        imgCode = _Parser.mathmlToImgObject(document, xmlCode, null, null);
        output += Util.createObjectCode(imgCode);
      } else if (mode === "img2mathml") {
        if (Configuration.get("saveMode")) {
          if (Configuration.get("saveMode") === "safeXml") {
            convertToXml = true;
            convertToSafeXml = true;
          } else if (Configuration.get("saveMode") === "xml") {
            convertToXml = true;
            convertToSafeXml = false;
          }
        }
        output += Util.getWIRISImageOutput(imgCode, convertToXml, convertToSafeXml);
      } else if (mode === "img264") {
        if (xmlCode === null) {
          xmlCode = imgObject.getAttribute("alt");
        }
        xmlCode = MathML.safeXmlDecode(xmlCode);
        const properties = {};
        properties.base64 = "true";
        imgCode = _Parser.mathmlToImgObject(document, xmlCode, properties, null);
        Image.setImgSize(imgCode, imgCode.src, true);
        output += Util.createObjectCode(imgCode);
      }
    }
    output += code2.substring(endPosition, code2.length);
    return output;
  }
  /**
   * Converts all occurrences of MathML to the corresponding image.
   * @param {string} content - string with valid MathML code.
   * The MathML code doesn't contain semantics.
   * @param {Constants} characters - Constant object containing xmlCharacters
   * or safeXmlCharacters relation.
   * @param {string} language - a valid language code
   * in order to generate formula accessibility.
   * @returns {string} The input string with all the MathML
   * occurrences replaced by the corresponding image.
   */
  static parseMathmlToImg(content, characters, language) {
    let output = "";
    const mathTagBegin = `${characters.tagOpener}math`;
    const mathTagEnd = `${characters.tagOpener}/math${characters.tagCloser}`;
    let start = content.indexOf(mathTagBegin);
    let end = 0;
    while (start !== -1) {
      output += content.substring(end, start);
      const imageMathmlAtrribute = content.indexOf(Configuration.get("imageMathmlAttribute"));
      end = content.indexOf(mathTagEnd, start);
      if (end === -1) {
        end = content.length - 1;
      } else if (imageMathmlAtrribute !== -1) {
        end += content.indexOf("/>", start);
      } else {
        end += mathTagEnd.length;
      }
      if (!MathML.isMathmlInAttribute(content, start) && imageMathmlAtrribute === -1) {
        let mathml = content.substring(start, end);
        mathml = characters.id === Constants.safeXmlCharacters.id ? MathML.safeXmlDecode(mathml) : MathML.mathMLEntities(mathml);
        output += Util.createObjectCode(_Parser.mathmlToImgObject(document, mathml, null, language));
      } else {
        output += content.substring(start, end);
      }
      start = content.indexOf(mathTagBegin, end);
    }
    output += content.substring(end, content.length);
    return output;
  }
};
if (typeof MutationObserver !== "undefined") {
  const mutationObserver = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.oldValue === Configuration.get("imageClassName") && mutation.attributeName === "class" && mutation.target.className.indexOf(Configuration.get("imageClassName")) === -1) {
        mutation.target.className = Configuration.get("imageClassName");
      }
    });
  });
  Parser.observer = Object.create(mutationObserver);
  Parser.observer.Config = { attributes: true, attributeOldValue: true };
  Parser.observer.observe = function(target) {
    Object.getPrototypeOf(this).observe(target, this.Config);
  };
}

// node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/src/editorlistener.js
var EditorListener = class {
  /**
   * @classdesc
   * Determines if the content of the
   * MathType Editor has changes.
   * @implements {EditorListeners}
   * @constructs
   */
  constructor() {
    this.isContentChanged = false;
    this.waitingForChanges = false;
  }
  /**
   * Sets {@link EditorListener.isContentChanged} property.
   * @param {Boolean} value - The new vlue.
   */
  setIsContentChanged(value) {
    this.isContentChanged = value;
  }
  /**
   * Returns true if the content of the editor has been changed, false otherwise.
   * @return {Boolean}
   */
  getIsContentChanged() {
    return this.isContentChanged;
  }
  /**
   * Determines if the EditorListener should wait for any changes.
   * @param {Boolean} value - True if the editor should wait for changes, false otherwise.
   */
  setWaitingForChanges(value) {
    this.waitingForChanges = value;
  }
  /**
   * EditorListener method to overwrite.
   * @type {JsEditor}
   * @ignore
   */
  caretPositionChanged(_editor) {
  }
  /**
   * EditorListener method to overwrite
   * @type {JsEditor}
   * @ignore
   */
  clipboardChanged(_editor) {
  }
  /**
   * Determines if the content of an editor has been changed.
   * @param {JsEditor} editor - editor object.
   */
  contentChanged(_editor) {
    if (this.waitingForChanges === true && this.isContentChanged === false) {
      this.isContentChanged = true;
    }
  }
  /**
   * EditorListener method to overwrite
   * @param {JsEditor} editor - The editor instance.
   */
  styleChanged(_editor) {
  }
  /**
   * EditorListener method to overwrite
   * @param {JsEditor} - The editor instance.
   */
  transformationReceived(_editor) {
  }
};

// node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/telemeter-wasm/telemeter_wasm.js
var wasm;
var cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
if (typeof TextDecoder !== "undefined") {
  cachedTextDecoder.decode();
}
var cachedUint8Memory0 = null;
function getUint8Memory0() {
  if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8Memory0;
}
function getStringFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
var heap = new Array(128).fill(void 0);
heap.push(void 0, null, true, false);
var heap_next = heap.length;
function addHeapObject(obj) {
  if (heap_next === heap.length)
    heap.push(heap.length + 1);
  const idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj;
  return idx;
}
function getObject(idx) {
  return heap[idx];
}
function dropObject(idx) {
  if (idx < 132)
    return;
  heap[idx] = heap_next;
  heap_next = idx;
}
function takeObject(idx) {
  const ret = getObject(idx);
  dropObject(idx);
  return ret;
}
var WASM_VECTOR_LEN = 0;
var cachedTextEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : { encode: () => {
  throw Error("TextEncoder not available");
} };
var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
} : function(arg, view) {
  const buf = cachedTextEncoder.encode(arg);
  view.set(buf);
  return {
    read: arg.length,
    written: buf.length
  };
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8Memory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code2 = arg.charCodeAt(offset);
    if (code2 > 127)
      break;
    mem[ptr + offset] = code2;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
function isLikeNone(x) {
  return x === void 0 || x === null;
}
var cachedInt32Memory0 = null;
function getInt32Memory0() {
  if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
    cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
  }
  return cachedInt32Memory0;
}
var cachedFloat64Memory0 = null;
function getFloat64Memory0() {
  if (cachedFloat64Memory0 === null || cachedFloat64Memory0.byteLength === 0) {
    cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);
  }
  return cachedFloat64Memory0;
}
function debugString(val) {
  const type = typeof val;
  if (type == "number" || type == "boolean" || val == null) {
    return `${val}`;
  }
  if (type == "string") {
    return `"${val}"`;
  }
  if (type == "symbol") {
    const description = val.description;
    if (description == null) {
      return "Symbol";
    } else {
      return `Symbol(${description})`;
    }
  }
  if (type == "function") {
    const name = val.name;
    if (typeof name == "string" && name.length > 0) {
      return `Function(${name})`;
    } else {
      return "Function";
    }
  }
  if (Array.isArray(val)) {
    const length = val.length;
    let debug = "[";
    if (length > 0) {
      debug += debugString(val[0]);
    }
    for (let i = 1; i < length; i++) {
      debug += ", " + debugString(val[i]);
    }
    debug += "]";
    return debug;
  }
  const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
  let className;
  if (builtInMatches.length > 1) {
    className = builtInMatches[1];
  } else {
    return toString.call(val);
  }
  if (className == "Object") {
    try {
      return "Object(" + JSON.stringify(val) + ")";
    } catch (_) {
      return "Object";
    }
  }
  if (val instanceof Error) {
    return `${val.name}: ${val.message}
${val.stack}`;
  }
  return className;
}
function makeClosure(arg0, arg1, dtor, f) {
  const state = { a: arg0, b: arg1, cnt: 1, dtor };
  const real = (...args) => {
    state.cnt++;
    try {
      return f(state.a, state.b, ...args);
    } finally {
      if (--state.cnt === 0) {
        wasm.__wbindgen_export_2.get(state.dtor)(state.a, state.b);
        state.a = 0;
      }
    }
  };
  real.original = state;
  return real;
}
function __wbg_adapter_34(arg0, arg1, arg2) {
  wasm.__wbindgen_export_3(arg0, arg1, addHeapObject(arg2));
}
function makeMutClosure(arg0, arg1, dtor, f) {
  const state = { a: arg0, b: arg1, cnt: 1, dtor };
  const real = (...args) => {
    state.cnt++;
    const a = state.a;
    state.a = 0;
    try {
      return f(a, state.b, ...args);
    } finally {
      if (--state.cnt === 0) {
        wasm.__wbindgen_export_2.get(state.dtor)(a, state.b);
      } else {
        state.a = a;
      }
    }
  };
  real.original = state;
  return real;
}
function __wbg_adapter_37(arg0, arg1) {
  wasm.__wbindgen_export_4(arg0, arg1);
}
function __wbg_adapter_40(arg0, arg1, arg2) {
  wasm.__wbindgen_export_5(arg0, arg1, addHeapObject(arg2));
}
function handleError(f, args) {
  try {
    return f.apply(this, args);
  } catch (e) {
    wasm.__wbindgen_export_6(addHeapObject(e));
  }
}
function __wbg_adapter_99(arg0, arg1, arg2, arg3) {
  wasm.__wbindgen_export_7(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));
}
function getArrayU8FromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
var Level = Object.freeze({ Error: 0, "0": "Error", Warn: 1, "1": "Warn", Info: 2, "2": "Info", Debug: 3, "3": "Debug" });
var Telemeter = class _Telemeter {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_Telemeter.prototype);
    obj.__wbg_ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_telemeter_free(ptr);
  }
  /**
  * @param {any} solution
  * @param {any} hosts
  * @param {any} config
  */
  constructor(solution, hosts, config) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.telemeter_new(retptr, addHeapObject(solution), addHeapObject(hosts), addHeapObject(config));
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return _Telemeter.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * @param {string} sender_id
  * @returns {Promise<any>}
  */
  identify(sender_id) {
    const ptr0 = passStringToWasm0(sender_id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.telemeter_identify(this.__wbg_ptr, ptr0, len0);
    return takeObject(ret);
  }
  /**
  * @param {string} event_type
  * @param {any} event_payload
  * @returns {Promise<any>}
  */
  track(event_type, event_payload) {
    const ptr0 = passStringToWasm0(event_type, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.telemeter_track(this.__wbg_ptr, ptr0, len0, addHeapObject(event_payload));
    return takeObject(ret);
  }
  /**
  * @param {any} level
  * @param {string} message
  * @param {any} payload
  * @returns {Promise<any>}
  */
  log(level, message, payload) {
    const ptr0 = passStringToWasm0(message, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.telemeter_log(this.__wbg_ptr, addHeapObject(level), ptr0, len0, addHeapObject(payload));
    return takeObject(ret);
  }
  /**
  * @returns {Promise<any>}
  */
  finish() {
    const ptr = this.__destroy_into_raw();
    const ret = wasm.telemeter_finish(ptr);
    return takeObject(ret);
  }
  /**
  * @param {boolean | undefined} new_debug_status
  */
  debug(new_debug_status) {
    wasm.telemeter_debug(this.__wbg_ptr, isLikeNone(new_debug_status) ? 16777215 : new_debug_status ? 1 : 0);
  }
};
async function __wbg_load(module2, imports) {
  if (typeof Response === "function" && module2 instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module2, imports);
      } catch (e) {
        if (module2.headers.get("Content-Type") != "application/wasm") {
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
        } else {
          throw e;
        }
      }
    }
    const bytes = await module2.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance = await WebAssembly.instantiate(module2, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module: module2 };
    } else {
      return instance;
    }
  }
}
function __wbg_get_imports() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_b51585de1b234aff = function() {
    const ret = new Object();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_status_ac85a3142a84caa2 = function(arg0) {
    const ret = getObject(arg0).status;
    return ret;
  };
  imports.wbg.__wbg_headers_b70de86b8e989bc0 = function(arg0) {
    const ret = getObject(arg0).headers;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new0_c0be7df4b6bd481f = function() {
    const ret = /* @__PURE__ */ new Date();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_getTime_5e2054f832d82ec9 = function(arg0) {
    const ret = getObject(arg0).getTime();
    return ret;
  };
  imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
    takeObject(arg0);
  };
  imports.wbg.__wbindgen_is_object = function(arg0) {
    const val = getObject(arg0);
    const ret = typeof val === "object" && val !== null;
    return ret;
  };
  imports.wbg.__wbg_crypto_c48a774b022d20ac = function(arg0) {
    const ret = getObject(arg0).crypto;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_process_298734cf255a885d = function(arg0) {
    const ret = getObject(arg0).process;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_versions_e2e78e134e3e5d01 = function(arg0) {
    const ret = getObject(arg0).versions;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_node_1cd7a5d853dbea79 = function(arg0) {
    const ret = getObject(arg0).node;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_is_string = function(arg0) {
    const ret = typeof getObject(arg0) === "string";
    return ret;
  };
  imports.wbg.__wbg_require_8f08ceecec0f4fee = function() {
    return handleError(function() {
      const ret = module.require;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_msCrypto_bcb970640f50a1e8 = function(arg0) {
    const ret = getObject(arg0).msCrypto;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_newwithlength_e5d69174d6984cd7 = function(arg0) {
    const ret = new Uint8Array(arg0 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_get_44be0491f933a435 = function(arg0, arg1) {
    const ret = getObject(arg0)[arg1 >>> 0];
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_next_ddb3312ca1c4e32a = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).next();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_done_5c1f01fb660d73b5 = function(arg0) {
    const ret = getObject(arg0).done;
    return ret;
  };
  imports.wbg.__wbg_value_1695675138684bd5 = function(arg0) {
    const ret = getObject(arg0).value;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_iterator_97f0c81209c6c35a = function() {
    const ret = Symbol.iterator;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_next_526fc47e980da008 = function(arg0) {
    const ret = getObject(arg0).next;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_is_function = function(arg0) {
    const ret = typeof getObject(arg0) === "function";
    return ret;
  };
  imports.wbg.__wbg_call_cb65541d95d71282 = function() {
    return handleError(function(arg0, arg1) {
      const ret = getObject(arg0).call(getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbindgen_object_clone_ref = function(arg0) {
    const ret = getObject(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_self_1ff1d729e9aae938 = function() {
    return handleError(function() {
      const ret = self.self;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_window_5f4faef6c12b79ec = function() {
    return handleError(function() {
      const ret = window.window;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_globalThis_1d39714405582d3c = function() {
    return handleError(function() {
      const ret = globalThis.globalThis;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_global_651f05c6a0944d1c = function() {
    return handleError(function() {
      const ret = global.global;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbindgen_is_undefined = function(arg0) {
    const ret = getObject(arg0) === void 0;
    return ret;
  };
  imports.wbg.__wbg_newnoargs_581967eacc0e2604 = function(arg0, arg1) {
    const ret = new Function(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_isArray_4c24b343cb13cfb1 = function(arg0) {
    const ret = Array.isArray(getObject(arg0));
    return ret;
  };
  imports.wbg.__wbg_values_e80af618f92c8649 = function(arg0) {
    const ret = getObject(arg0).values();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_call_01734de55d61e11d = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_isSafeInteger_bb8e18dd21c97288 = function(arg0) {
    const ret = Number.isSafeInteger(getObject(arg0));
    return ret;
  };
  imports.wbg.__wbg_new_43f1b47c28813cbd = function(arg0, arg1) {
    try {
      var state0 = { a: arg0, b: arg1 };
      var cb0 = (arg02, arg12) => {
        const a = state0.a;
        state0.a = 0;
        try {
          return __wbg_adapter_99(a, state0.b, arg02, arg12);
        } finally {
          state0.a = a;
        }
      };
      const ret = new Promise(cb0);
      return addHeapObject(ret);
    } finally {
      state0.a = state0.b = 0;
    }
  };
  imports.wbg.__wbindgen_memory = function() {
    const ret = wasm.memory;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_buffer_085ec1f694018c4f = function(arg0) {
    const ret = getObject(arg0).buffer;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_8125e318e6245eed = function(arg0) {
    const ret = new Uint8Array(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_set_5cf90238115182c3 = function(arg0, arg1, arg2) {
    getObject(arg0).set(getObject(arg1), arg2 >>> 0);
  };
  imports.wbg.__wbg_length_72e2208bbc0efc61 = function(arg0) {
    const ret = getObject(arg0).length;
    return ret;
  };
  imports.wbg.__wbindgen_string_get = function(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = typeof obj === "string" ? obj : void 0;
    var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    var len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbg_get_97b561fb56f034b5 = function() {
    return handleError(function(arg0, arg1) {
      const ret = Reflect.get(getObject(arg0), getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_has_c5fcd020291e56b8 = function() {
    return handleError(function(arg0, arg1) {
      const ret = Reflect.has(getObject(arg0), getObject(arg1));
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_set_092e06b0f9d71865 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_stringify_e25465938f3f611f = function() {
    return handleError(function(arg0) {
      const ret = JSON.stringify(getObject(arg0));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_new_55c9955722952374 = function() {
    return handleError(function() {
      const ret = new AbortController();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_signal_4bd18fb489af2d4c = function(arg0) {
    const ret = getObject(arg0).signal;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_abort_654b796176d117aa = function(arg0) {
    getObject(arg0).abort();
  };
  imports.wbg.__wbg_newwithbyteoffsetandlength_6da8e527659b86aa = function(arg0, arg1, arg2) {
    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_fetch_8eaf01857a5bb21f = function(arg0, arg1) {
    const ret = getObject(arg0).fetch(getObject(arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_fetch_381efb5e862610fa = function(arg0) {
    const ret = fetch(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_d258248ed531ff54 = function(arg0, arg1) {
    const ret = new Error(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_is_null = function(arg0) {
    const ret = getObject(arg0) === null;
    return ret;
  };
  imports.wbg.__wbindgen_boolean_get = function(arg0) {
    const v = getObject(arg0);
    const ret = typeof v === "boolean" ? v ? 1 : 0 : 2;
    return ret;
  };
  imports.wbg.__wbg_instanceof_Uint8Array_d8d9cb2b8e8ac1d4 = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof Uint8Array;
    } catch {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_instanceof_ArrayBuffer_39ac22089b74fddb = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof ArrayBuffer;
    } catch {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbindgen_number_get = function(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = typeof obj === "number" ? obj : void 0;
    getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;
    getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);
  };
  imports.wbg.__wbg_entries_e51f29c7bba0c054 = function(arg0) {
    const ret = Object.entries(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_String_9aa17d6248d519a5 = function(arg0, arg1) {
    const ret = String(getObject(arg1));
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbg_get_723f83ba0c34871a = function(arg0, arg1) {
    const ret = getObject(arg0)[takeObject(arg1)];
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_b66404b6322c59bf = function() {
    return handleError(function(arg0, arg1) {
      const ret = new WebSocket(getStringFromWasm0(arg0, arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_setbinaryType_096c70c4a9d97499 = function(arg0, arg1) {
    getObject(arg0).binaryType = takeObject(arg1);
  };
  imports.wbg.__wbg_log_1d3ae0273d8f4f8a = function(arg0) {
    console.log(getObject(arg0));
  };
  imports.wbg.__wbg_error_788ae33f81d3b84b = function(arg0) {
    console.error(getObject(arg0));
  };
  imports.wbg.__wbg_warn_d60e832f9882c1b2 = function(arg0) {
    console.warn(getObject(arg0));
  };
  imports.wbg.__wbg_info_2e30e8204b29d91d = function(arg0) {
    console.info(getObject(arg0));
  };
  imports.wbg.__wbg_navigator_7c9103698acde322 = function(arg0) {
    const ret = getObject(arg0).navigator;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_warn_fb2e68e6e02a4cb1 = function(arg0, arg1) {
    console.warn(getObject(arg0), getObject(arg1));
  };
  imports.wbg.__wbg_readyState_b25418fd198bf715 = function(arg0) {
    const ret = getObject(arg0).readyState;
    return ret;
  };
  imports.wbg.__wbg_close_dfa389d8fddb52fc = function() {
    return handleError(function(arg0) {
      getObject(arg0).close();
    }, arguments);
  };
  imports.wbg.__wbg_document_f7ace2b956f30a4f = function(arg0) {
    const ret = getObject(arg0).document;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
  };
  imports.wbg.__wbg_visibilityState_d18aa202782db311 = function(arg0) {
    const ret = getObject(arg0).visibilityState;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_error_new = function(arg0, arg1) {
    const ret = new Error(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_addEventListener_5651108fc3ffeb6e = function() {
    return handleError(function(arg0, arg1, arg2, arg3) {
      getObject(arg0).addEventListener(getStringFromWasm0(arg1, arg2), getObject(arg3));
    }, arguments);
  };
  imports.wbg.__wbg_removeEventListener_5de660c02ed784e4 = function() {
    return handleError(function(arg0, arg1, arg2, arg3) {
      getObject(arg0).removeEventListener(getStringFromWasm0(arg1, arg2), getObject(arg3));
    }, arguments);
  };
  imports.wbg.__wbg_localStorage_dbac11bd189e9fa0 = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).localStorage;
      return isLikeNone(ret) ? 0 : addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_getItem_ed8e218e51f1efeb = function() {
    return handleError(function(arg0, arg1, arg2, arg3) {
      const ret = getObject(arg1).getItem(getStringFromWasm0(arg2, arg3));
      var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
      var len1 = WASM_VECTOR_LEN;
      getInt32Memory0()[arg0 / 4 + 1] = len1;
      getInt32Memory0()[arg0 / 4 + 0] = ptr1;
    }, arguments);
  };
  imports.wbg.__wbg_setItem_d002ee486462bfff = function() {
    return handleError(function(arg0, arg1, arg2, arg3, arg4) {
      getObject(arg0).setItem(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));
    }, arguments);
  };
  imports.wbg.__wbg_platform_6a9b59df01050eac = function() {
    return handleError(function(arg0, arg1) {
      const ret = getObject(arg1).platform;
      const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
      const len1 = WASM_VECTOR_LEN;
      getInt32Memory0()[arg0 / 4 + 1] = len1;
      getInt32Memory0()[arg0 / 4 + 0] = ptr1;
    }, arguments);
  };
  imports.wbg.__wbg_hardwareConcurrency_3b217d60cc0aa1a6 = function(arg0) {
    const ret = getObject(arg0).hardwareConcurrency;
    return ret;
  };
  imports.wbg.__wbg_languages_4ab80469955a57f7 = function(arg0) {
    const ret = getObject(arg0).languages;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_length_fff51ee6522a1a18 = function(arg0) {
    const ret = getObject(arg0).length;
    return ret;
  };
  imports.wbg.__wbg_screen_452da8d1ab76046e = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).screen;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_width_07fc222a210e15f1 = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).width;
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_height_6fa226ea329cffc1 = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).height;
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_pixelDepth_59e67c400cb7862f = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).pixelDepth;
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_maxTouchPoints_831c1f1c938603aa = function(arg0) {
    const ret = getObject(arg0).maxTouchPoints;
    return ret;
  };
  imports.wbg.__wbg_keys_386d224d0262f361 = function(arg0) {
    const ret = Object.keys(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_sort_3dd97e5325a14f4c = function(arg0) {
    const ret = getObject(arg0).sort();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_mediaDevices_3e7cfbc0834c7ebc = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).mediaDevices;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_enumerateDevices_bdfeafd96a31de36 = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).enumerateDevices();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_deviceId_2f4358ebee927f5c = function(arg0, arg1) {
    const ret = getObject(arg1).deviceId;
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbindgen_cb_drop = function(arg0) {
    const obj = takeObject(arg0).original;
    if (obj.cnt-- == 1) {
      obj.a = 0;
      return true;
    }
    const ret = false;
    return ret;
  };
  imports.wbg.__wbg_instanceof_Response_fc4327dbfcdf5ced = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof Response;
    } catch {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_randomFillSync_dc1e9a60c158336d = function() {
    return handleError(function(arg0, arg1) {
      getObject(arg0).randomFillSync(takeObject(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_subarray_13db269f57aa838d = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_getRandomValues_37fa2ca9e4e07fab = function() {
    return handleError(function(arg0, arg1) {
      getObject(arg0).getRandomValues(getObject(arg1));
    }, arguments);
  };
  imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {
    const ret = debugString(getObject(arg1));
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  };
  imports.wbg.__wbg_then_b2267541e2a73865 = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).then(getObject(arg1), getObject(arg2));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_then_f7e06ee3c11698eb = function(arg0, arg1) {
    const ret = getObject(arg0).then(getObject(arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_resolve_53698b95aaf7fcf8 = function(arg0) {
    const ret = Promise.resolve(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_newwithstrandinit_cad5cd6038c7ff5d = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_instanceof_Window_9029196b662bc42a = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof Window;
    } catch {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_new_1eead62f64ca15ce = function() {
    return handleError(function() {
      const ret = new Headers();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_append_fda9e3432e3e88da = function() {
    return handleError(function(arg0, arg1, arg2, arg3, arg4) {
      getObject(arg0).append(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));
    }, arguments);
  };
  imports.wbg.__wbg_url_8503de97f69da463 = function(arg0, arg1) {
    const ret = getObject(arg1).url;
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbg_send_1a008ea2eb3a1951 = function() {
    return handleError(function(arg0, arg1, arg2) {
      getObject(arg0).send(getArrayU8FromWasm0(arg1, arg2));
    }, arguments);
  };
  imports.wbg.__wbindgen_closure_wrapper1507 = function(arg0, arg1, arg2) {
    const ret = makeClosure(arg0, arg1, 84, __wbg_adapter_34);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper1671 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 84, __wbg_adapter_37);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper1878 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 94, __wbg_adapter_40);
    return addHeapObject(ret);
  };
  return imports;
}
function __wbg_init_memory(imports, maybe_memory) {
}
function __wbg_finalize_init(instance, module2) {
  wasm = instance.exports;
  __wbg_init.__wbindgen_wasm_module = module2;
  cachedFloat64Memory0 = null;
  cachedInt32Memory0 = null;
  cachedUint8Memory0 = null;
  wasm.__wbindgen_start();
  return wasm;
}
async function __wbg_init(input) {
  if (wasm !== void 0)
    return wasm;
  if (typeof input === "undefined") {
    input = new URL("telemeter_wasm_bg.wasm", import.meta.url);
  }
  const imports = __wbg_get_imports();
  if (typeof input === "string" || typeof Request === "function" && input instanceof Request || typeof URL === "function" && input instanceof URL) {
    input = fetch(input);
  }
  __wbg_init_memory(imports);
  const { instance, module: module2 } = await __wbg_load(await input, imports);
  return __wbg_finalize_init(instance, module2);
}
var telemeter_wasm_default = __wbg_init;

// node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/src/telemeter.js
var Telemeter2 = class {
  /**
   * Inits Telemeter class.
   * The parameters structures are defiended on {@link [Telemeter API](https://github.com/wiris/telemeter/blob/main/docs/USAGE.md#telemeter-api)}
   * @param {Object} telemeterAttributes.solution - The product that send data to Telemetry.
   * @param {Object} telemeterAttributes.hosts - Data about the environment where solution is integrated.
   * @param {Object} telemeterAttributes.config - Configuration parameters.
   */
  static init(telemeterAttributes) {
    if (!this.telemeter && !this.waitingForInit) {
      this.waitingForInit = true;
      telemeter_wasm_default(telemeterAttributes.url).then(() => {
        this.telemeter = new Telemeter(
          telemeterAttributes.solution,
          telemeterAttributes.hosts,
          telemeterAttributes.config
        );
      }).catch((error) => {
        console.log(error);
      }).finally(() => this.waitingForInit = false);
    }
  }
  /**
   * Closes the Telemetry Session. After calling this method no data will be added to the Telemetry Session.
   */
  static async finish() {
    if (!this.telemeter)
      return;
    try {
      let local_telemeter = this.telemeter;
      this.telemeter = void 0;
      await local_telemeter.finish();
    } catch (e) {
      console.error(e);
    }
  }
};

// node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/src/contentmanager.js
var ContentManager = class _ContentManager {
  /**
   * @classdesc
   * This class represents a modal dialog, managing the following:
   * - The insertion of content into the current instance of the {@link ModalDialog} class.
   * - The actions to be done once the modal object has been submitted
   *   (submitAction} method).
   * - The update of the content when the {@link ModalDialog} class is also updated,
   *   for example when ModalDialog is re-opened.
   * - The communication between the {@link ModalDialog} class and itself, if the content
   *   has been changed (hasChanges} method).
   * @constructs
   * @param {Object} contentManagerAttributes - Object containing all attributes needed to
   * create a new instance.
   */
  constructor(contentManagerAttributes) {
    this.editorAttributes = {};
    if ("editorAttributes" in contentManagerAttributes) {
      this.editorAttributes = contentManagerAttributes.editorAttributes;
    } else {
      throw new Error("ContentManager constructor error: editorAttributes property missed.");
    }
    this.customEditors = null;
    if ("customEditors" in contentManagerAttributes) {
      this.customEditors = contentManagerAttributes.customEditors;
    }
    this.environment = {};
    if ("environment" in contentManagerAttributes) {
      this.environment = contentManagerAttributes.environment;
    } else {
      throw new Error("ContentManager constructor error: environment property missed");
    }
    this.language = "";
    if ("language" in contentManagerAttributes) {
      this.language = contentManagerAttributes.language;
    } else {
      throw new Error("ContentManager constructor error: language property missed");
    }
    this.editorListener = new EditorListener();
    this.editor = null;
    this.ua = navigator.userAgent.toLowerCase();
    this.deviceProperties = {};
    this.deviceProperties.isAndroid = this.ua.indexOf("android") > -1;
    this.deviceProperties.isIOS = _ContentManager.isIOS();
    this.toolbar = null;
    this.dbclick = null;
    this.modalDialogInstance = null;
    this.listeners = new Listeners();
    this.mathML = null;
    this.isNewElement = true;
    this.integrationModel = null;
  }
  /**
   * Adds a new listener to the current {@link ContentManager} instance.
   * @param {Object} listener - The listener to be added.
   */
  addListener(listener) {
    this.listeners.add(listener);
  }
  /**
   * Sets an instance of {@link IntegrationModel} class to the current {@link ContentManager}
   * instance.
   * @param {IntegrationModel} integrationModel - The {@link IntegrationModel} instance.
   */
  setIntegrationModel(integrationModel) {
    this.integrationModel = integrationModel;
  }
  /**
   * Sets the {@link ModalDialog} instance into the current {@link ContentManager} instance.
   * @param {ModalDialog} modalDialogInstance - The {@link ModalDialog} instance
   */
  setModalDialogInstance(modalDialogInstance) {
    this.modalDialogInstance = modalDialogInstance;
  }
  /**
   * Inserts the content into the current {@link ModalDialog} instance updating
   * the title and inserting the JavaScript editor.
   */
  insert() {
    this.updateTitle(this.modalDialogInstance);
    this.insertEditor(this.modalDialogInstance);
  }
  /**
   * Inserts MathType editor into the {@link ModalDialog.contentContainer}. It waits until
   * editor's JavaScript is loaded.
   */
  insertEditor() {
    if (_ContentManager.isEditorLoaded()) {
      this.editor = window.com.wiris.jsEditor.JsEditor.newInstance(this.editorAttributes);
      this.editor.insertInto(this.modalDialogInstance.contentContainer);
      this.editor.focus();
      if (this.modalDialogInstance.rtl) {
        this.editor.action("rtl");
      }
      if (this.editor.getEditorModel().isRTL()) {
        this.editor.element.style.direction = "rtl";
      }
      this.editor.getEditorModel().addEditorListener(this.editorListener);
      if (this.modalDialogInstance.deviceProperties.isIOS) {
        setTimeout(function() {
          if (this.hasOwnProperty("modalDialogInstance"))
            this.modalDialogInstance.hideKeyboard();
        }, 400);
        const formulaDisplayDiv = document.getElementsByClassName("wrs_formulaDisplay")[0];
        Util.addEvent(formulaDisplayDiv, "focus", this.modalDialogInstance.handleOpenedIosSoftkeyboard);
        Util.addEvent(formulaDisplayDiv, "blur", this.modalDialogInstance.handleClosedIosSoftkeyboard);
      }
      this.listeners.fire("onLoad", {});
    } else {
      setTimeout(_ContentManager.prototype.insertEditor.bind(this), 100);
    }
  }
  /**
   * Initializes the current class by loading MathType script.
   */
  init() {
    if (!_ContentManager.isEditorLoaded()) {
      this.addEditorAsExternalDependency();
    }
  }
  /**
   * Adds script element to the DOM to include editor externally.
   */
  addEditorAsExternalDependency() {
    const script = document.createElement("script");
    script.type = "text/javascript";
    let editorUrl = Configuration.get("editorUrl");
    const anchorElement = document.createElement("a");
    _ContentManager.setHrefToAnchorElement(anchorElement, editorUrl);
    _ContentManager.setProtocolToAnchorElement(anchorElement);
    editorUrl = _ContentManager.getURLFromAnchorElement(anchorElement);
    const stats = this.getEditorStats();
    script.src = `${editorUrl}?lang=${this.language}&stats-editor=${stats.editor}&stats-mode=${stats.mode}&stats-version=${stats.version}`;
    document.getElementsByTagName("head")[0].appendChild(script);
  }
  /**
   * Sets the specified url to the anchor element.
   * @param {HTMLAnchorElement} anchorElement - Element where set 'url'.
   * @param {String} url - URL to set.
   */
  static setHrefToAnchorElement(anchorElement, url) {
    anchorElement.href = url;
  }
  /**
   * Sets the current protocol to the anchor element.
   * @param {HTMLAnchorElement} anchorElement - Element where set its protocol.
   */
  static setProtocolToAnchorElement(anchorElement) {
    if (window.location.href.indexOf("https://") === 0) {
      if (anchorElement.protocol === "http:") {
        anchorElement.protocol = "https:";
      }
    }
  }
  /**
   * Returns the url of the anchor element adding the current port
   * if it is needed.
   * @param {HTMLAnchorElement} anchorElement - Element where extract the url.
   * @returns {String}
   */
  static getURLFromAnchorElement(anchorElement) {
    const removePort = anchorElement.port === "80" || anchorElement.port === "443" || anchorElement.port === "";
    return `${anchorElement.protocol}//${anchorElement.hostname}${removePort ? "" : `:${anchorElement.port}`}${anchorElement.pathname.startsWith("/") ? anchorElement.pathname : `/${anchorElement.pathname}`}`;
  }
  /**
   * Returns object with editor stats.
   *
   * @typedef {Object} EditorStatsObject
   * @property {string} editor - Editor name.
   * @property {string} mode - Current configuration for formula save mode.
   * @property {string} version - Current plugins version.
   * @returns {EditorStatsObject}
   */
  getEditorStats() {
    const stats = {};
    if ("editor" in this.environment) {
      stats.editor = this.environment.editor;
    } else {
      stats.editor = "unknown";
    }
    if ("mode" in this.environment) {
      stats.mode = this.environment.mode;
    } else {
      stats.mode = Configuration.get("saveMode");
    }
    if ("version" in this.environment) {
      stats.version = this.environment.version;
    } else {
      stats.version = Configuration.get("version");
    }
    return stats;
  }
  /**
   * Returns true if device is iOS. Otherwise, false.
   * @returns {Boolean}
   */
  static isIOS() {
    return [
      "iPad Simulator",
      "iPhone Simulator",
      "iPod Simulator",
      "iPad",
      "iPhone",
      "iPod"
    ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
  }
  /**
   * Returns true if device is Mobile. Otherwise, false.
   * @returns {Boolean}
   */
  static isMobile() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  }
  /**
   * Returns true if editor is loaded. Otherwise, false.
   * @returns {Boolean}
   */
  static isEditorLoaded() {
    return window.com && window.com.wiris && window.com.wiris.jsEditor && window.com.wiris.jsEditor.JsEditor && window.com.wiris.jsEditor.JsEditor.newInstance;
  }
  /**
  * Sets the {@link ContentManager.editor} initial content.
  */
  setInitialContent() {
    if (!this.isNewElement) {
      this.setMathML(this.mathML);
    }
  }
  /**
   * Sets a MathML into {@link ContentManager.editor} instance.
   * @param {String} mathml - MathML string.
   * @param {Boolean} focusDisabled - If true editor don't get focus after the MathML is set.
   * False by default.
   */
  setMathML(mathml, focusDisabled) {
    if (typeof focusDisabled === "undefined") {
      focusDisabled = false;
    }
    this.editor.setMathMLWithCallback(mathml, () => {
      this.editorListener.setWaitingForChanges(true);
    });
    setTimeout(() => {
      this.editorListener.setIsContentChanged(false);
    }, 500);
    if (!focusDisabled) {
      this.onFocus();
    }
  }
  /**
   * Sets the focus to the current instance of {@link ContentManager.editor}. Triggered by
   * {@link ModalDialog.focus}.
   */
  onFocus() {
    if (typeof this.editor !== "undefined" && this.editor != null) {
      this.editor.focus();
      setTimeout(() => {
        this.editor.focus();
      }, 100);
    }
  }
  /**
   * Updates the edition area by calling {@link IntegrationModel.updateFormula}.
   * Triggered by {@link ModalDialog.submitAction}.
   */
  submitAction() {
    if (!this.editor.isFormulaEmpty()) {
      let mathML = this.editor.getMathMLWithSemantics();
      if (this.customEditors.getActiveEditor() !== null) {
        const { toolbar } = this.customEditors.getActiveEditor();
        mathML = MathML.addCustomEditorClassAttribute(mathML, toolbar);
      } else {
        Object.keys(this.customEditors.editors).forEach((key) => {
          mathML = MathML.removeCustomEditorClassAttribute(mathML, key);
        });
      }
      const mathmlEntitiesEncoded = MathML.mathMLEntities(mathML);
      this.integrationModel.updateFormula(mathmlEntitiesEncoded);
    } else {
      this.integrationModel.updateFormula(null);
    }
    this.customEditors.disable();
    this.integrationModel.notifyWindowClosed();
    this.setEmptyMathML();
    this.customEditors.disable();
  }
  /**
   * Sets an empty MathML as {@link ContentManager.editor} content.
   */
  setEmptyMathML() {
    if (this.deviceProperties.isAndroid || this.deviceProperties.isIOS) {
      if (this.editor.getEditorModel().isRTL()) {
        this.setMathML('<math dir="rtl"><semantics><annotation encoding="application/json">[]</annotation></semantics></math>', true);
      } else {
        this.setMathML('<math><semantics><annotation encoding="application/json">[]</annotation></semantics></math>', true);
      }
    } else if (this.editor.getEditorModel().isRTL()) {
      this.setMathML('<math dir="rtl"/>', true);
    } else {
      this.setMathML("<math/>", true);
    }
  }
  /**
   * Open event. Triggered by {@link ModalDialog.open}. Does the following:
   * - Updates the {@link ContentManager.editor} content
   *   (with an empty MathML or an existing formula),
   * - Updates the {@link ContentManager.editor} toolbar.
   * - Recovers the the focus.
   */
  onOpen() {
    if (this.isNewElement) {
      this.setEmptyMathML();
    } else {
      this.setMathML(this.mathML);
    }
    let toolbar = this.updateToolbar();
    this.onFocus();
    if (this.deviceProperties.isIOS) {
      const zoom = document.documentElement.clientWidth / window.innerWidth;
      if (zoom !== 1) {
        this.setKeyboardMode();
      }
    }
    let trigger = this.dbclick ? "formula" : "button";
    try {
      Telemeter2.telemeter.track("OPENED_MTCT_EDITOR", {
        toolbar,
        trigger
      });
    } catch (err) {
      console.error(err);
    }
    Core.globalListeners.fire("onModalOpen", {});
  }
  /**
   * Change Editor in keyboard mode when is loaded
   */
  setKeyboardMode() {
    const wrsEditor = document.getElementsByClassName("wrs_handOpen wrs_disablePalette")[0];
    if (wrsEditor) {
      wrsEditor.classList.remove("wrs_handOpen");
      wrsEditor.classList.remove("wrs_disablePalette");
    } else {
      setTimeout(_ContentManager.prototype.setKeyboardMode.bind(this), 100);
    }
  }
  /**
   * Sets the correct toolbar depending if exist other custom toolbars
   * at the same time (e.g: Chemistry).
   */
  updateToolbar() {
    this.updateTitle(this.modalDialogInstance);
    const customEditor = this.customEditors.getActiveEditor();
    let toolbar;
    if (customEditor) {
      toolbar = customEditor.toolbar ? customEditor.toolbar : _wrs_int_wirisProperties.toolbar;
      if (this.toolbar == null || this.toolbar !== toolbar) {
        this.setToolbar(toolbar);
      }
    } else {
      toolbar = this.getToolbar();
      if (this.toolbar == null || this.toolbar !== toolbar) {
        this.setToolbar(toolbar);
        this.customEditors.disable();
      }
    }
    return toolbar;
  }
  /**
   * Updates the current {@link ModalDialog.title}. If a {@link CustomEditors} is enabled
   * sets the custom editor title. Otherwise sets the default title.
   */
  updateTitle() {
    const customEditor = this.customEditors.getActiveEditor();
    if (customEditor) {
      this.modalDialogInstance.setTitle(customEditor.title);
    } else {
      this.modalDialogInstance.setTitle("MathType");
    }
  }
  /**
   * Returns the editor toolbar, depending on the configuration local or server side.
   * @returns {String} - Toolbar identifier.
   */
  getToolbar() {
    let toolbar = "general";
    if ("toolbar" in this.editorAttributes) {
      ({ toolbar } = this.editorAttributes);
    }
    if (toolbar === "general") {
      toolbar = typeof _wrs_int_wirisProperties === "undefined" || typeof _wrs_int_wirisProperties.toolbar === "undefined" ? "general" : _wrs_int_wirisProperties.toolbar;
    }
    return toolbar;
  }
  /**
   * Sets the current {@link ContentManager.editor} instance toolbar.
   * @param {String} toolbar - The toolbar name.
   */
  setToolbar(toolbar) {
    this.toolbar = toolbar;
    this.editor.setParams({ toolbar: this.toolbar });
  }
  /**
   * Returns true if the content of the editor has been changed. The logic of the changes
   * is delegated to {@link EditorListener} class.
   * @returns {Boolean} True if the editor content has been changed. False otherwise.
   */
  hasChanges() {
    return !this.editor.isFormulaEmpty() && this.editorListener.getIsContentChanged();
  }
  /**
   * Handle keyboard events detected in modal when elements of this class intervene.
   * @param {KeyboardEvent} keyboardEvent - The keyboard event.
   */
  onKeyDown(keyboardEvent) {
    if (keyboardEvent.key !== void 0 && keyboardEvent.repeat === false) {
      if (keyboardEvent.key === "Escape" || keyboardEvent.key === "Esc") {
        let list = document.getElementsByClassName("wrs_expandButton wrs_expandButtonFor3RowsLayout wrs_pressed");
        if (list.length === 0) {
          list = document.getElementsByClassName("wrs_expandButton wrs_expandButtonFor2RowsLayout wrs_pressed");
          if (list.length === 0) {
            list = document.getElementsByClassName("wrs_select wrs_pressed");
            if (list.length === 0) {
              this.modalDialogInstance.cancelAction();
              keyboardEvent.stopPropagation();
              keyboardEvent.preventDefault();
            }
          }
        }
      } else if (keyboardEvent.shiftKey && keyboardEvent.key === "Tab") {
        if (document.activeElement === this.modalDialogInstance.submitButton) {
          this.editor.focus();
          keyboardEvent.stopPropagation();
          keyboardEvent.preventDefault();
        } else if (document.querySelector('[title="Manual"]') === document.activeElement) {
          this.modalDialogInstance.closeDiv.focus();
          keyboardEvent.stopPropagation();
          keyboardEvent.preventDefault();
        } else {
          if (document.activeElement === this.modalDialogInstance.minimizeDiv) {
            if (!(this.modalDialogInstance.properties.state === "minimized")) {
              this.modalDialogInstance.cancelButton.focus();
              keyboardEvent.stopPropagation();
              keyboardEvent.preventDefault();
            }
          }
        }
      } else if (keyboardEvent.key === "Tab") {
        if (document.activeElement === this.modalDialogInstance.cancelButton) {
          this.modalDialogInstance.minimizeDiv.focus();
          keyboardEvent.stopPropagation();
          keyboardEvent.preventDefault();
        } else if (document.activeElement === this.modalDialogInstance.closeDiv) {
          if (!(this.modalDialogInstance.properties.state === "minimized")) {
            const element = document.querySelector('[title="Manual"]');
            element.focus();
            keyboardEvent.stopPropagation();
            keyboardEvent.preventDefault();
          }
        } else {
          const element = document.getElementsByClassName("wrs_formulaDisplay")[0];
          if (element.getAttribute("class") === "wrs_formulaDisplay wrs_focused") {
            this.modalDialogInstance.submitButton.focus();
            keyboardEvent.stopPropagation();
            keyboardEvent.preventDefault();
          }
        }
      }
    }
  }
};

// node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/src/customeditors.js
var CustomEditors = class {
  /**
   * @classdesc
   * This class represents the MathType custom editors manager.
   * A custom editor is MathType editor with a custom  toolbar.
   * This class associates a {@link CustomEditor} to:
   * - It's own formulas
   * - A custom toolbar
   * - An icon to open it from a HTML editor.
   * - A tooltip for the icon.
   * - A global variable to enable or disable it globally.
   * @constructs
   */
  constructor() {
    this.editors = [];
    this.activeEditor = "default";
  }
  /**
   * Adds a {@link CustomEditor} to editors array.
   * @param {String} editorName - The editor name.
   * @param {CustomEditor} editorParams - The custom editor parameters.
   */
  addEditor(editorName, editorParams) {
    const customEditor = {};
    customEditor.name = editorParams.name;
    customEditor.toolbar = editorParams.toolbar;
    customEditor.icon = editorParams.icon;
    customEditor.confVariable = editorParams.confVariable;
    customEditor.title = editorParams.title;
    customEditor.tooltip = editorParams.tooltip;
    this.editors[editorName] = customEditor;
  }
  /**
   * Enables a {@link CustomEditor}.
   * @param {String} customEditorName - The custom editor name.
   */
  enable(customEditorName) {
    this.activeEditor = customEditorName;
  }
  /**
   * Disables a {@link CustomEditor}.
   */
  disable() {
    this.activeEditor = "default";
  }
  /**
   * Returns the active editor.
   * @return {CustomEditor} - A {@link CustomEditor} if a custom editor is enabled. Null otherwise.
   */
  getActiveEditor() {
    if (this.activeEditor !== "default") {
      return this.editors[this.activeEditor];
    }
    return null;
  }
};

// node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/src/jsvariables.js
var jsProperties = {
  imageCustomEditorName: "data-custom-editor",
  imageClassName: "Wirisformula",
  CASClassName: "Wiriscas"
};
var jsvariables_default = jsProperties;

// node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/src/event.js
var Event = class {
  /**
   * @classdesc
   * This class represents a custom event. Events should be fired by the {@link Listener} class.
   *
   * ```js
   *  let customEvent = new Event();
   *  customEvent.properties = {};
   *
   *  let listeners = new Listeners();
   *  listeners.newListener(eventName, callback);
   *
   *  listeners.fire(eventName, customEvent) *
   * ```
   * @constructs
   */
  constructor() {
    this.cancelled = false;
    this.defaultPrevented = false;
  }
  /**
   * Cancels the event.
   */
  cancel() {
    this.cancelled = true;
  }
  /**
   * Prevents the default action.
   */
  preventDefault() {
    this.defaultPrevented = true;
  }
};

// node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/src/popupmessage.js
var PopUpMessage = class {
  /**
   * @classdesc
   * This class represents a dialog message overlaying a DOM element in order to
   * accept / cancel discard changes. The dialog can be closed i.e the overlay disappears
   * o canceled. In this last case a callback function should be called.
   * @constructs
   * @param {Object} popupMessageAttributes - Object containing popup properties.
   * @param {HTMLElement} popupMessageAttributes.overlayElement - Element to overlay.
   * @param {Object} popupMessageAttributes.callbacks - Contains callback
   * methods for close and cancel actions.
   * @param {Object} popupMessageAttributes.strings - Contains all the strings needed.
   */
  constructor(popupMessageAttributes) {
    this.overlayElement = popupMessageAttributes.overlayElement;
    this.callbacks = popupMessageAttributes.callbacks;
    this.overlayWrapper = this.overlayElement.appendChild(document.createElement("div"));
    this.overlayWrapper.setAttribute("class", "wrs_popupmessage_overlay_envolture");
    this.message = this.overlayWrapper.appendChild(document.createElement("div"));
    this.message.id = "wrs_popupmessage";
    this.message.setAttribute("class", "wrs_popupmessage_panel");
    this.message.setAttribute("role", "dialog");
    this.message.setAttribute("aria-describedby", "description_txt");
    const paragraph = document.createElement("p");
    const text2 = document.createTextNode(popupMessageAttributes.strings.message);
    paragraph.appendChild(text2);
    paragraph.id = "description_txt";
    this.message.appendChild(paragraph);
    const overlay = this.overlayWrapper.appendChild(document.createElement("div"));
    overlay.setAttribute("class", "wrs_popupmessage_overlay");
    overlay.addEventListener("click", this.cancelAction.bind(this));
    this.buttonArea = this.message.appendChild(document.createElement("div"));
    this.buttonArea.setAttribute("class", "wrs_popupmessage_button_area");
    this.buttonArea.id = "wrs_popup_button_area";
    const buttonSubmitArguments = {
      class: "wrs_button_accept",
      innerHTML: popupMessageAttributes.strings.submitString,
      id: "wrs_popup_accept_button",
      // To identifiy the element in automated testing
      "data-testid": "mtcteditor-cd-close-button"
    };
    this.closeButton = this.createButton(buttonSubmitArguments, this.closeAction.bind(this));
    this.buttonArea.appendChild(this.closeButton);
    const buttonCancelArguments = {
      class: "wrs_button_cancel",
      innerHTML: popupMessageAttributes.strings.cancelString,
      id: "wrs_popup_cancel_button",
      // To identifiy the element in automated testing
      "data-testid": "mtcteditor-cd-cancel-button"
    };
    this.cancelButton = this.createButton(buttonCancelArguments, this.cancelAction.bind(this));
    this.buttonArea.appendChild(this.cancelButton);
  }
  /**
   * This method create a button with arguments and return button dom object
   * @param {Object} parameters - An object containing id, class and innerHTML button text.
   * @param {String} parameters.id - Button id.
   * @param {String} parameters.class - Button class name.
   * @param {String} parameters.innerHTML - Button innerHTML text.
   * @param {Object} callback- Callback method to call on click event.
   * @returns {HTMLElement} HTML button.
   */
  // eslint-disable-next-line class-methods-use-this
  createButton(parameters, callback) {
    let element = {};
    element = document.createElement("button");
    element.setAttribute("id", parameters.id);
    element.setAttribute("class", parameters.class);
    element.innerHTML = parameters.innerHTML;
    element.addEventListener("click", callback);
    if (parameters["data-testid"]) {
      element.setAttribute("data-testid", parameters["data-testid"]);
    }
    return element;
  }
  /**
   * Shows the popupmessage containing a message, and two buttons
   * to cancel the action or close the modal dialog.
   */
  show() {
    if (this.overlayWrapper.style.display !== "block") {
      document.activeElement.blur();
      this.overlayWrapper.style.display = "block";
      this.closeButton.focus();
    } else {
      this.overlayWrapper.style.display = "none";
    }
  }
  /**
   * This method cancels the popupMessage: the dialog disappears revealing the overlaid element.
   * A callback method is called (if defined). For example a method to focus the overlaid element.
   */
  cancelAction() {
    this.overlayWrapper.style.display = "none";
    if (typeof this.callbacks.cancelCallback !== "undefined") {
      this.callbacks.cancelCallback();
    }
  }
  /**
   * This method closes the popupMessage: the dialog disappears and the close callback is called.
   * For example to close the overlaid element.
   */
  closeAction() {
    this.cancelAction();
    if (typeof this.callbacks.closeCallback !== "undefined") {
      this.callbacks.closeCallback();
    }
    IntegrationModel.setActionsOnCancelButtons();
  }
  /**
   * Handle keyboard events detected in modal when elements of this class intervene.
   * @param {KeyboardEvent} keyboardEvent - The keyboard event.
   */
  onKeyDown(keyboardEvent) {
    if (keyboardEvent.key !== void 0) {
      if (keyboardEvent.key === "Escape" || keyboardEvent.key === "Esc") {
        this.cancelAction();
        keyboardEvent.stopPropagation();
        keyboardEvent.preventDefault();
      } else if (keyboardEvent.key === "Tab") {
        if (document.activeElement === this.closeButton) {
          this.cancelButton.focus();
        } else {
          this.closeButton.focus();
        }
        keyboardEvent.stopPropagation();
        keyboardEvent.preventDefault();
      }
    }
  }
};

// node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/src/modal.js
import closeIcon from "/var/www/html/manorama/node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/styles/icons/general/close_icon.svg";
import closeHoverIcon from "/var/www/html/manorama/node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/styles/icons/hover/close_icon_h.svg";
import fullsIcon from "/var/www/html/manorama/node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/styles/icons/general/fulls_icon.svg";
import fullsHoverIcon from "/var/www/html/manorama/node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/styles/icons/hover/fulls_icon_h.svg";
import minIcon from "/var/www/html/manorama/node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/styles/icons/general/min_icon.svg";
import minHoverIcon from "/var/www/html/manorama/node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/styles/icons/hover/min_icon_h.svg";
import minsIcon from "/var/www/html/manorama/node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/styles/icons/general/mins_icon.svg";
import minsHoverIcon from "/var/www/html/manorama/node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/styles/icons/hover/mins_icon_h.svg";
import maxIcon from "/var/www/html/manorama/node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/styles/icons/general/max_icon.svg";
import maxHoverIcon from "/var/www/html/manorama/node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/styles/icons/hover/max_icon_h.svg";
var ModalDialog = class {
  /**
   * @classdesc
   * This class represents a modal dialog. The modal dialog admits
   * a {@link ContentManager} instance to manage the content of the dialog.
   * @constructs
   * @param {Object} modalDialogAttributes  - An object containing all modal dialog attributes.
   */
  constructor(modalDialogAttributes) {
    this.attributes = modalDialogAttributes;
    const ua = navigator.userAgent.toLowerCase();
    const isAndroid2 = ua.indexOf("android") > -1;
    const isIOS = ContentManager.isIOS();
    this.iosSoftkeyboardOpened = false;
    this.iosMeasureUnit = ua.indexOf("crios") === -1 ? "%" : "vh";
    this.iosDivHeight = `100%${this.iosMeasureUnit}`;
    const deviceWidth = window.outerWidth;
    const deviceHeight = window.outerHeight;
    const landscape = deviceWidth > deviceHeight;
    const portrait = deviceWidth < deviceHeight;
    const isLandscape = landscape && this.attributes.height > deviceHeight;
    const isPortrait = portrait && this.attributes.width > deviceWidth;
    const isMobile = ContentManager.isMobile();
    this.instanceId = document.getElementsByClassName("wrs_modal_dialogContainer").length;
    this.deviceProperties = {
      orientation: landscape ? "landscape" : "portait",
      isAndroid: isAndroid2,
      isIOS,
      isMobile,
      isDesktop: !isMobile && !isIOS && !isAndroid2
    };
    this.properties = {
      created: false,
      state: "",
      previousState: "",
      position: { bottom: 0, right: 10 },
      size: { height: 338, width: 580 }
    };
    this.websiteBeforeLockParameters = null;
    let attributes = {};
    attributes.class = "wrs_modal_overlay";
    attributes.id = this.getElementId(attributes.class);
    this.overlay = Util.createElement("div", attributes);
    attributes = {};
    attributes.class = "wrs_modal_title_bar";
    attributes.id = this.getElementId(attributes.class);
    this.titleBar = Util.createElement("div", attributes);
    attributes = {};
    attributes.class = "wrs_modal_title";
    attributes.id = this.getElementId(attributes.class);
    this.title = Util.createElement("div", attributes);
    this.title.innerHTML = "offline";
    attributes = {};
    attributes.class = "wrs_modal_close_button";
    attributes.id = this.getElementId(attributes.class);
    attributes.title = StringManager.get("close");
    attributes.style = {};
    this.closeDiv = Util.createElement("a", attributes);
    this.closeDiv.setAttribute("role", "button");
    this.closeDiv.setAttribute("tabindex", 3);
    let generalStyle = `background-size: 10px; background-image: url(data:image/svg+xml;base64,${window.btoa(closeIcon)})`;
    let hoverStyle = `background-size: 10px; background-image: url(data:image/svg+xml;base64,${window.btoa(closeHoverIcon)})`;
    this.closeDiv.setAttribute("style", generalStyle);
    this.closeDiv.setAttribute("onmouseover", `this.style = "${hoverStyle}";`);
    this.closeDiv.setAttribute("onmouseout", `this.style = "${generalStyle}";`);
    this.closeDiv.setAttribute("data-testid", "mtcteditor-close-button");
    attributes = {};
    attributes.class = "wrs_modal_stack_button";
    attributes.id = this.getElementId(attributes.class);
    attributes.title = StringManager.get("exit_fullscreen");
    this.stackDiv = Util.createElement("a", attributes);
    this.stackDiv.setAttribute("role", "button");
    this.stackDiv.setAttribute("tabindex", 2);
    generalStyle = `background-size: 10px; background-image: url(data:image/svg+xml;base64,${window.btoa(minsIcon)})`;
    hoverStyle = `background-size: 10px; background-image: url(data:image/svg+xml;base64,${window.btoa(minsHoverIcon)})`;
    this.stackDiv.setAttribute("style", generalStyle);
    this.stackDiv.setAttribute("onmouseover", `this.style = "${hoverStyle}";`);
    this.stackDiv.setAttribute("onmouseout", `this.style = "${generalStyle}";`);
    this.stackDiv.setAttribute("data-testid", "mtcteditor-fullscreen-disable-button");
    attributes = {};
    attributes.class = "wrs_modal_maximize_button";
    attributes.id = this.getElementId(attributes.class);
    attributes.title = StringManager.get("fullscreen");
    this.maximizeDiv = Util.createElement("a", attributes);
    this.maximizeDiv.setAttribute("role", "button");
    this.maximizeDiv.setAttribute("tabindex", 2);
    generalStyle = `background-size: 10px; background-repeat: no-repeat; background-image: url(data:image/svg+xml;base64,${window.btoa(fullsIcon)})`;
    hoverStyle = `background-size: 10px; background-repeat: no-repeat; background-image: url(data:image/svg+xml;base64,${window.btoa(fullsHoverIcon)})`;
    this.maximizeDiv.setAttribute("style", generalStyle);
    this.maximizeDiv.setAttribute("onmouseover", `this.style = "${hoverStyle}";`);
    this.maximizeDiv.setAttribute("onmouseout", `this.style = "${generalStyle}";`);
    this.maximizeDiv.setAttribute("data-testid", "mtcteditor-fullscreen-enable-button");
    attributes = {};
    attributes.class = "wrs_modal_minimize_button";
    attributes.id = this.getElementId(attributes.class);
    attributes.title = StringManager.get("minimize");
    this.minimizeDiv = Util.createElement("a", attributes);
    this.minimizeDiv.setAttribute("role", "button");
    this.minimizeDiv.setAttribute("tabindex", 1);
    generalStyle = `background-size: 10px; background-repeat: no-repeat; background-image: url(data:image/svg+xml;base64,${window.btoa(minIcon)})`;
    hoverStyle = `background-size: 10px; background-repeat: no-repeat; background-image: url(data:image/svg+xml;base64,${window.btoa(minHoverIcon)})`;
    this.minimizeDiv.setAttribute("style", generalStyle);
    this.minimizeDiv.setAttribute("onmouseover", `this.style = "${hoverStyle}";`);
    this.minimizeDiv.setAttribute("onmouseout", `this.style = "${generalStyle}";`);
    this.minimizeDiv.setAttribute("data-testid", "mtcteditor-minimize-button");
    attributes = {};
    attributes.class = "wrs_modal_dialogContainer";
    attributes.id = this.getElementId(attributes.class);
    attributes.role = "dialog";
    this.container = Util.createElement("div", attributes);
    this.container.setAttribute("aria-labeledby", "wrs_modal_title[0]");
    attributes = {};
    attributes.class = "wrs_modal_wrapper";
    attributes.id = this.getElementId(attributes.class);
    this.wrapper = Util.createElement("div", attributes);
    attributes = {};
    attributes.class = "wrs_content_container";
    attributes.id = this.getElementId(attributes.class);
    this.contentContainer = Util.createElement("div", attributes);
    attributes = {};
    attributes.class = "wrs_modal_controls";
    attributes.id = this.getElementId(attributes.class);
    this.controls = Util.createElement("div", attributes);
    attributes = {};
    attributes.class = "wrs_modal_buttons_container";
    attributes.id = this.getElementId(attributes.class);
    this.buttonContainer = Util.createElement("div", attributes);
    this.submitButton = this.createSubmitButton(
      {
        id: this.getElementId("wrs_modal_button_accept"),
        class: "wrs_modal_button_accept",
        innerHTML: StringManager.get("accept"),
        // To identifiy the element in automated testing
        "data-testid": "mtcteditor-insert-button"
      },
      this.submitAction.bind(this)
    );
    this.cancelButton = this.createSubmitButton(
      {
        id: this.getElementId("wrs_modal_button_cancel"),
        class: "wrs_modal_button_cancel",
        innerHTML: StringManager.get("cancel"),
        // To identifiy the element in automated testing
        "data-testid": "mtcteditor-cancel-button"
      },
      this.cancelAction.bind(this)
    );
    this.contentManager = null;
    const popupStrings = {
      cancelString: StringManager.get("cancel"),
      submitString: StringManager.get("close"),
      message: StringManager.get("close_modal_warning")
    };
    const callbacks = {
      closeCallback: () => {
        this.close();
      },
      cancelCallback: () => {
        this.focus();
      }
    };
    const popupupProperties = {
      overlayElement: this.container,
      callbacks,
      strings: popupStrings
    };
    this.popup = new PopUpMessage(popupupProperties);
    this.rtl = false;
    if ("rtl" in this.attributes) {
      this.rtl = this.attributes.rtl;
    }
    this.handleOpenedIosSoftkeyboard = this.handleOpenedIosSoftkeyboard.bind(this);
    this.handleClosedIosSoftkeyboard = this.handleClosedIosSoftkeyboard.bind(this);
  }
  /**
   * This method sets an ContentManager instance to ModalDialog. ContentManager
   * manages the logic of ModalDialog content: submit, update, close and changes.
   * @param {ContentManager} contentManager - ContentManager instance.
   */
  setContentManager(contentManager) {
    this.contentManager = contentManager;
  }
  /**
   * Returns the modal contentElement object.
   * @returns {ContentManager} the instance of the ContentManager class.
  */
  getContentManager() {
    return this.contentManager;
  }
  /**
   * This method is called when the modal object has been submitted. Calls
   * contentElement submitAction method - if exists - and closes the modal
   * object. No logic about the content should be placed here,
   * contentElement.submitAction is the responsible of the content logic.
   */
  submitAction() {
    if (typeof this.contentManager.submitAction !== "undefined") {
      this.contentManager.submitAction();
    }
    try {
      Telemeter2.telemeter.track("CLOSED_MTCT_EDITOR", {
        toolbar: this.contentManager.toolbar,
        trigger: "mtct_insert"
      });
    } catch (err) {
      console.error(err);
    }
    this.close();
  }
  /**
   * This method is called when the modal object has been cancelled. If
   * contentElement has implemented hasChanges method, a confirm popup
   * will be shown if hasChanges returns true.
   */
  cancelAction() {
    if (typeof this.contentManager.hasChanges === "undefined") {
      IntegrationModel.setActionsOnCancelButtons();
      try {
        Telemeter2.telemeter.track("CLOSED_MTCT_EDITOR", {
          toolbar: this.contentManager.toolbar,
          trigger: "mtct_close"
        });
      } catch (err) {
        console.error(err);
      }
      this.close();
    } else if (!this.contentManager.hasChanges()) {
      IntegrationModel.setActionsOnCancelButtons();
      try {
        Telemeter2.telemeter.track("CLOSED_MTCT_EDITOR", {
          toolbar: this.contentManager.toolbar,
          trigger: "mtct_close"
        });
      } catch (err) {
        console.error(err);
      }
      this.close();
    } else {
      this.showPopUpMessage();
      try {
        Telemeter2.telemeter.track("CLOSED_MTCT_EDITOR", {
          toolbar: this.contentManager.toolbar,
          trigger: "mtct_close"
        });
      } catch (err) {
        console.error(err);
      }
    }
  }
  /**
   * Returns a button element.
   * @param {Object} properties - Input button properties.
   * @param {String} properties.class - Input button class.
   * @param {String} properties.innerHTML - Input button innerHTML.
   * @param {Object} callback - Callback function associated to click event.
   * @returns {HTMLButtonElement} The button element.
   *
   */
  // eslint-disable-next-line class-methods-use-this
  createSubmitButton(properties, callback) {
    class SubmitButton {
      constructor() {
        this.element = document.createElement("button");
        this.element.id = properties.id;
        this.element.className = properties.class;
        this.element.innerHTML = properties.innerHTML;
        this.element.dataset.testid = properties["data-testid"];
        Util.addEvent(this.element, "click", callback);
      }
      getElement() {
        return this.element;
      }
    }
    return new SubmitButton(properties, callback).getElement();
  }
  /**
   * Creates the modal window object inserting a contentElement object.
   */
  create() {
    this.titleBar.appendChild(this.closeDiv);
    this.titleBar.appendChild(this.stackDiv);
    this.titleBar.appendChild(this.maximizeDiv);
    this.titleBar.appendChild(this.minimizeDiv);
    this.titleBar.appendChild(this.title);
    if (this.deviceProperties.isDesktop) {
      this.container.appendChild(this.titleBar);
    }
    this.wrapper.appendChild(this.contentContainer);
    this.wrapper.appendChild(this.controls);
    this.controls.appendChild(this.buttonContainer);
    this.buttonContainer.appendChild(this.submitButton);
    this.buttonContainer.appendChild(this.cancelButton);
    this.container.appendChild(this.wrapper);
    this.recalculateScrollBar();
    document.body.appendChild(this.container);
    document.body.appendChild(this.overlay);
    if (this.deviceProperties.isDesktop) {
      this.createModalWindowDesktop();
      this.createResizeButtons();
      this.addListeners();
      if (Configuration.get("modalWindowFullScreen")) {
        this.maximize();
      }
    } else if (this.deviceProperties.isAndroid) {
      this.createModalWindowAndroid();
    } else if (this.deviceProperties.isIOS) {
      this.createModalWindowIos();
    }
    if (this.contentManager != null) {
      this.contentManager.insert(this);
    }
    this.properties.open = true;
    this.properties.created = true;
    if (this.isRTL()) {
      this.container.style.right = `${window.innerWidth - this.scrollbarWidth - this.container.offsetWidth}px`;
      this.container.className += " wrs_modal_rtl";
    }
  }
  /**
   * Creates a button in the modal object to resize it.
   */
  createResizeButtons() {
    this.resizerBR = document.createElement("div");
    this.resizerBR.className = "wrs_bottom_right_resizer";
    this.resizerBR.innerHTML = "◢";
    this.resizerBR.dataset.testid = "mtcteditor-resize-button-right";
    this.resizerTL = document.createElement("div");
    this.resizerTL.className = "wrs_bottom_left_resizer";
    this.resizerTL.dataset.testid = "mtcteditor-resize-button-left";
    this.container.appendChild(this.resizerBR);
    this.titleBar.appendChild(this.resizerTL);
    Util.addEvent(this.resizerBR, "mousedown", this.activateResizeStateBR.bind(this));
    Util.addEvent(this.resizerTL, "mousedown", this.activateResizeStateTL.bind(this));
  }
  /**
   * Initialize variables for Bottom-Right resize button
   * @param {MouseEvent} mouseEvent - Mouse event.
   */
  activateResizeStateBR(mouseEvent) {
    this.initializeResizeProperties(mouseEvent, false);
  }
  /**
   * Initialize variables for Top-Left resize button
   * @param {MouseEvent} mouseEvent - Mouse event.
   */
  activateResizeStateTL(mouseEvent) {
    this.initializeResizeProperties(mouseEvent, true);
  }
  /**
   * Common method to initialize variables at resize.
   * @param {MouseEvent} mouseEvent - Mouse event.
   */
  initializeResizeProperties(mouseEvent, leftOption) {
    Util.addClass(document.body, "wrs_noselect");
    Util.addClass(this.overlay, "wrs_overlay_active");
    this.resizeDataObject = {
      x: this.eventClient(mouseEvent).X,
      y: this.eventClient(mouseEvent).Y
    };
    this.initialWidth = parseInt(this.container.style.width, 10);
    this.initialHeight = parseInt(this.container.style.height, 10);
    if (!leftOption) {
      this.initialRight = parseInt(this.container.style.right, 10);
      this.initialBottom = parseInt(this.container.style.bottom, 10);
    } else {
      this.leftScale = true;
    }
    if (!this.initialRight) {
      this.initialRight = 0;
    }
    if (!this.initialBottom) {
      this.initialBottom = 0;
    }
    document.body.style["user-select"] = "none";
  }
  /**
   * This method opens the modal window, restoring the previous state, position and metrics,
   * if exists. By default the modal object opens in stack mode.
   */
  open() {
    this.removeClass("wrs_closed");
    const { isIOS } = this.deviceProperties;
    const { isAndroid: isAndroid2 } = this.deviceProperties;
    const { isMobile } = this.deviceProperties;
    if (isIOS || isAndroid2 || isMobile) {
      this.restoreWebsiteScale();
      this.lockWebsiteScroll();
      setTimeout(() => {
        this.hideKeyboard();
      }, 400);
    }
    if (!this.properties.created) {
      this.create();
    } else {
      if (!this.properties.open) {
        this.properties.open = true;
        if (!this.deviceProperties.isAndroid && !this.deviceProperties.isIOS) {
          this.restoreState();
        }
      }
      if (this.deviceProperties.isDesktop && Configuration.get("modalWindowFullScreen")) {
        this.maximize();
      }
      if (this.deviceProperties.isIOS) {
        this.iosSoftkeyboardOpened = false;
        this.setContainerHeight(`${100 + this.iosMeasureUnit}`);
      }
    }
    if (!ContentManager.isEditorLoaded()) {
      const listener = Listeners.newListener("onLoad", () => {
        this.contentManager.onOpen(this);
      });
      this.contentManager.addListener(listener);
    } else {
      this.contentManager.onOpen(this);
    }
  }
  /**
   * Closes modal window and restores viewport header.
   */
  close() {
    this.removeClass("wrs_maximized");
    this.removeClass("wrs_minimized");
    this.removeClass("wrs_stack");
    this.addClass("wrs_closed");
    this.saveModalProperties();
    this.unlockWebsiteScroll();
    this.properties.open = false;
    Core.globalListeners.fire("onModalClose", {});
  }
  /**
   * Sets the website scale to one.
   */
  // eslint-disable-next-line class-methods-use-this
  restoreWebsiteScale() {
    let viewportmeta = document.querySelector("meta[name=viewport]");
    const contentAttrsToUpdate = ["initial-scale=", "minimum-scale=", "maximum-scale="];
    const contentAttrsValuesToUpdate = ["1.0", "1.0", "1.0"];
    const setMetaAttrFunc = (viewportelement, contentAttrs) => {
      const contentAttr = viewportelement.getAttribute("content");
      if (contentAttr) {
        const attrArray = contentAttr.split(",");
        let finalContentMeta = "";
        const oldAttrs = [];
        for (let i = 0; i < attrArray.length; i += 1) {
          let isAttrToUpdate = false;
          let j = 0;
          while (!isAttrToUpdate && j < contentAttrs.length) {
            if (attrArray[i].indexOf(contentAttrs[j])) {
              isAttrToUpdate = true;
            }
            j += 1;
          }
          if (!isAttrToUpdate) {
            oldAttrs.push(attrArray[i]);
          }
        }
        for (let i = 0; i < contentAttrs.length; i += 1) {
          const attr = contentAttrs[i] + contentAttrsValuesToUpdate[i];
          finalContentMeta += i === 0 ? attr : `,${attr}`;
        }
        for (let i = 0; i < oldAttrs.length; i += 1) {
          finalContentMeta += `,${oldAttrs[i]}`;
        }
        viewportelement.setAttribute("content", finalContentMeta);
        viewportelement.setAttribute("content", "");
        viewportelement.setAttribute("content", contentAttr);
      } else {
        viewportelement.setAttribute("content", "initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0");
        viewportelement.removeAttribute("content");
      }
    };
    if (!viewportmeta) {
      viewportmeta = document.createElement("meta");
      document.getElementsByTagName("head")[0].appendChild(viewportmeta);
      setMetaAttrFunc(viewportmeta, contentAttrsToUpdate, contentAttrsValuesToUpdate);
      viewportmeta.remove();
    } else {
      setMetaAttrFunc(viewportmeta, contentAttrsToUpdate, contentAttrsValuesToUpdate);
    }
  }
  /**
   * Locks website scroll for mobile devices.
   */
  lockWebsiteScroll() {
    this.websiteBeforeLockParameters = {
      bodyStylePosition: document.body.style.position ? document.body.style.position : "",
      bodyStyleOverflow: document.body.style.overflow ? document.body.style.overflow : "",
      htmlStyleOverflow: document.documentElement.style.overflow ? document.documentElement.style.overflow : "",
      windowScrollX: window.scrollX,
      windowScrollY: window.scrollY
    };
  }
  /**
   * Unlocks website scroll for mobile devices.
   */
  unlockWebsiteScroll() {
    if (this.websiteBeforeLockParameters) {
      document.body.style.position = this.websiteBeforeLockParameters.bodyStylePosition;
      document.body.style.overflow = this.websiteBeforeLockParameters.bodyStyleOverflow;
      document.documentElement.style.overflow = this.websiteBeforeLockParameters.htmlStyleOverflow;
      const { windowScrollX } = this.websiteBeforeLockParameters;
      const { windowScrollY } = this.websiteBeforeLockParameters;
      window.scrollTo(windowScrollX, windowScrollY);
      this.websiteBeforeLockParameters = null;
    }
  }
  /**
   * Util function to known if browser is IE11.
   * @returns {Boolean} true if the browser is IE11. false otherwise.
   */
  // eslint-disable-next-line class-methods-use-this
  isIE11() {
    if (navigator.userAgent.search("Msie/") >= 0 || navigator.userAgent.search("Trident/") >= 0 || navigator.userAgent.search("Edge/") >= 0) {
      return true;
    }
    return false;
  }
  /**
   * Returns if the current language type is RTL.
   * @return {Boolean} true if current language is RTL. false otherwise.
   */
  isRTL() {
    if (this.attributes.language === "ar" || this.attributes.language === "he") {
      return true;
    }
    return this.rtl;
  }
  /**
   * Adds a class to all modal ModalDialog DOM elements.
   * @param {String} className - Class name.
   */
  addClass(className) {
    Util.addClass(this.overlay, className);
    Util.addClass(this.titleBar, className);
    Util.addClass(this.overlay, className);
    Util.addClass(this.container, className);
    Util.addClass(this.contentContainer, className);
    Util.addClass(this.stackDiv, className);
    Util.addClass(this.minimizeDiv, className);
    Util.addClass(this.maximizeDiv, className);
    Util.addClass(this.wrapper, className);
  }
  /**
   * Remove a class from all modal DOM elements.
   * @param {String} className - Class name.
   */
  removeClass(className) {
    Util.removeClass(this.overlay, className);
    Util.removeClass(this.titleBar, className);
    Util.removeClass(this.overlay, className);
    Util.removeClass(this.container, className);
    Util.removeClass(this.contentContainer, className);
    Util.removeClass(this.stackDiv, className);
    Util.removeClass(this.minimizeDiv, className);
    Util.removeClass(this.maximizeDiv, className);
    Util.removeClass(this.wrapper, className);
  }
  /**
   * Create modal dialog for desktop.
   */
  createModalWindowDesktop() {
    this.addClass("wrs_modal_desktop");
    this.stack();
  }
  /**
   * Create modal dialog for non android devices.
   */
  createModalWindowAndroid() {
    this.addClass("wrs_modal_android");
    window.addEventListener("resize", this.orientationChangeAndroidSoftkeyboard.bind(this));
  }
  /**
   * Create modal dialog for iOS devices.
   */
  createModalWindowIos() {
    this.addClass("wrs_modal_ios");
    window.addEventListener("resize", this.orientationChangeIosSoftkeyboard.bind(this));
  }
  /**
   * Restore previous state, position and size of previous stacked modal dialog.
   */
  restoreState() {
    if (this.properties.state === "maximized") {
      this.maximize();
    } else if (this.properties.state === "minimized") {
      this.properties.state = this.properties.previousState;
      this.properties.previousState = "";
      this.minimize();
    } else {
      this.stack();
    }
  }
  /**
   * Stacks the modal object.
   */
  stack() {
    this.properties.previousState = this.properties.state;
    this.properties.state = "stack";
    this.removeClass("wrs_maximized");
    this.minimizeDiv.title = StringManager.get("minimize");
    this.removeClass("wrs_minimized");
    this.addClass("wrs_stack");
    const generalStyle = `background-size: 10px; background-repeat: no-repeat; background-image: url(data:image/svg+xml;base64,${window.btoa(minIcon)})`;
    const hoverStyle = `background-size: 10px; background-repeat: no-repeat; background-image: url(data:image/svg+xml;base64,${window.btoa(minHoverIcon)})`;
    this.minimizeDiv.setAttribute("style", generalStyle);
    this.minimizeDiv.setAttribute("onmouseover", `this.style = "${hoverStyle}";`);
    this.minimizeDiv.setAttribute("onmouseout", `this.style = "${generalStyle}";`);
    this.restoreModalProperties();
    if (typeof this.resizerBR !== "undefined" && typeof this.resizerTL !== "undefined") {
      this.setResizeButtonsVisibility();
    }
    this.recalculateScrollBar();
    this.recalculatePosition();
    this.recalculateScale();
    this.focus();
  }
  /**
   * Minimizes the modal object.
   */
  minimize() {
    this.saveModalProperties();
    this.title.style.cursor = "pointer";
    if (this.properties.state === "minimized" && this.properties.previousState === "stack") {
      this.stack();
    } else if (this.properties.state === "minimized" && this.properties.previousState === "maximized") {
      this.maximize();
    } else {
      this.container.style.height = "30px";
      this.container.style.width = "250px";
      this.container.style.bottom = "0px";
      this.container.style.right = "10px";
      this.removeListeners();
      this.properties.previousState = this.properties.state;
      this.properties.state = "minimized";
      this.setResizeButtonsVisibility();
      this.minimizeDiv.title = StringManager.get("maximize");
      if (Util.containsClass(this.overlay, "wrs_stack")) {
        this.removeClass("wrs_stack");
      } else {
        this.removeClass("wrs_maximized");
      }
      this.addClass("wrs_minimized");
      const generalStyle = `background-size: 10px; background-repeat: no-repeat; background-image: url(data:image/svg+xml;base64,${window.btoa(maxIcon)})`;
      const hoverStyle = `background-size: 10px; background-repeat: no-repeat; background-image: url(data:image/svg+xml;base64,${window.btoa(maxHoverIcon)})`;
      this.minimizeDiv.setAttribute("style", generalStyle);
      this.minimizeDiv.setAttribute("onmouseover", `this.style = "${hoverStyle}";`);
      this.minimizeDiv.setAttribute("onmouseout", `this.style = "${generalStyle}";`);
    }
  }
  /**
   * Maximizes the modal object.
   */
  maximize() {
    this.saveModalProperties();
    if (this.properties.state !== "maximized") {
      this.properties.previousState = this.properties.state;
      this.properties.state = "maximized";
    }
    this.setResizeButtonsVisibility();
    if (Util.containsClass(this.overlay, "wrs_minimized")) {
      this.minimizeDiv.title = StringManager.get("minimize");
      this.removeClass("wrs_minimized");
    } else if (Util.containsClass(this.overlay, "wrs_stack")) {
      this.container.style.left = null;
      this.container.style.top = null;
      this.removeClass("wrs_stack");
    }
    this.addClass("wrs_maximized");
    const generalStyle = `background-size: 10px; background-repeat: no-repeat; background-image: url(data:image/svg+xml;base64,${window.btoa(minIcon)})`;
    const hoverStyle = `background-size: 10px; background-repeat: no-repeat; background-image: url(data:image/svg+xml;base64,${window.btoa(minHoverIcon)})`;
    this.minimizeDiv.setAttribute("style", generalStyle);
    this.minimizeDiv.setAttribute("onmouseover", `this.style = "${hoverStyle}";`);
    this.minimizeDiv.setAttribute("onmouseout", `this.style = "${generalStyle}";`);
    this.setSize(parseInt(window.innerHeight * 0.8, 10), parseInt(window.innerWidth * 0.8, 10));
    if (this.container.clientHeight > 700) {
      this.container.style.height = "700px";
    }
    if (this.container.clientWidth > 1200) {
      this.container.style.width = "1200px";
    }
    const { innerHeight } = window;
    const { innerWidth } = window;
    const { offsetHeight } = this.container;
    const { offsetWidth } = this.container;
    const bottom = innerHeight / 2 - offsetHeight / 2;
    const right = innerWidth / 2 - offsetWidth / 2;
    this.setPosition(bottom, right);
    this.recalculateScale();
    this.recalculatePosition();
    this.recalculateSize();
    this.focus();
  }
  /**
   * Expand again the modal object from a minimized state.
   */
  reExpand() {
    if (this.properties.state === "minimized") {
      if (this.properties.previousState === "maximized") {
        this.maximize();
      } else {
        this.stack();
      }
      this.title.style.cursor = "";
    }
  }
  /**
   * Sets modal size.
   * @param {Number} height - Height of the ModalDialog
   * @param {Number} width - Width of the ModalDialog.
   */
  setSize(height, width) {
    this.container.style.height = `${height}px`;
    this.container.style.width = `${width}px`;
    this.recalculateSize();
  }
  /**
   * Sets modal position using bottom and right style attributes.
   * @param  {number} bottom - bottom attribute.
   * @param  {number} right - right attribute.
   */
  setPosition(bottom, right) {
    this.container.style.bottom = `${bottom}px`;
    this.container.style.right = `${right}px`;
  }
  /**
   * Saves position and size parameters of and open ModalDialog. This attributes
   * are needed to restore it on re-open.
   */
  saveModalProperties() {
    if (this.properties.state === "stack") {
      this.properties.position.bottom = parseInt(this.container.style.bottom, 10);
      this.properties.position.right = parseInt(this.container.style.right, 10);
      this.properties.size.width = parseInt(this.container.style.width, 10);
      this.properties.size.height = parseInt(this.container.style.height, 10);
    }
  }
  /**
   * Restore ModalDialog position and size parameters.
   */
  restoreModalProperties() {
    if (this.properties.state === "stack") {
      this.setPosition(this.properties.position.bottom, this.properties.position.right);
      this.setSize(this.properties.size.height, this.properties.size.width);
    }
  }
  /**
   * Sets the modal dialog initial size.
   */
  recalculateSize() {
    this.wrapper.style.width = `${this.container.clientWidth - 12}px`;
    this.wrapper.style.height = `${this.container.clientHeight - 38}px`;
    this.contentContainer.style.height = `${parseInt(this.wrapper.offsetHeight - 50, 10)}px`;
  }
  /**
   * Enable or disable visibility of resize buttons in modal window depend on state.
   */
  setResizeButtonsVisibility() {
    if (this.properties.state === "stack") {
      this.resizerTL.style.visibility = "visible";
      this.resizerBR.style.visibility = "visible";
    } else {
      this.resizerTL.style.visibility = "hidden";
      this.resizerBR.style.visibility = "hidden";
    }
  }
  /**
   * Makes an object draggable adding mouse and touch events.
   */
  addListeners() {
    this.maximizeDiv.addEventListener("click", this.maximize.bind(this), true);
    this.stackDiv.addEventListener("click", this.stack.bind(this), true);
    this.minimizeDiv.addEventListener("click", this.minimize.bind(this), true);
    this.closeDiv.addEventListener("click", this.cancelAction.bind(this));
    this.maximizeDiv.addEventListener("keypress", function(e) {
      if (e.key === "Enter" || e.key === " " || e.keyCode === 13 || e.keyCode === 32) {
        e.target.click();
      }
    }, true);
    this.stackDiv.addEventListener("keypress", function(e) {
      if (e.key === "Enter" || e.key === " " || e.keyCode === 13 || e.keyCode === 32) {
        e.target.click();
        e.preventDefault();
      }
    }, true);
    this.minimizeDiv.addEventListener("keypress", function(e) {
      if (e.key === "Enter" || e.key === " " || e.keyCode === 13 || e.keyCode === 32) {
        e.target.click();
        e.preventDefault();
      }
    }, true);
    this.closeDiv.addEventListener("keypress", function(e) {
      if (e.key === "Enter" || e.key === " " || e.keyCode === 13 || e.keyCode === 32) {
        e.target.click();
        e.preventDefault();
      }
    });
    this.title.addEventListener("click", this.reExpand.bind(this));
    this.overlay.addEventListener("click", this.cancelAction.bind(this));
    Util.addEvent(window, "mousedown", this.startDrag.bind(this));
    Util.addEvent(window, "mouseup", this.stopDrag.bind(this));
    Util.addEvent(window, "mousemove", this.drag.bind(this));
    Util.addEvent(window, "resize", this.onWindowResize.bind(this));
    Util.addEvent(window, "keydown", this.onKeyDown.bind(this));
  }
  /**
   * Removes draggable events from an object.
   */
  removeListeners() {
    Util.removeEvent(window, "mousedown", this.startDrag);
    Util.removeEvent(window, "mouseup", this.stopDrag);
    Util.removeEvent(window, "mousemove", this.drag);
    Util.removeEvent(window, "resize", this.onWindowResize);
    Util.removeEvent(window, "keydown", this.onKeyDown);
  }
  /**
   * Returns mouse or touch coordinates (on touch events ev.ClientX doesn't exists)
   * @param {MouseEvent} mouseEvent - Mouse event.
   * @return {Object} With the X and Y coordinates.
   */
  // eslint-disable-next-line class-methods-use-this
  eventClient(mouseEvent) {
    if (typeof mouseEvent.clientX === "undefined" && mouseEvent.changedTouches) {
      const client2 = {
        X: mouseEvent.changedTouches[0].clientX,
        Y: mouseEvent.changedTouches[0].clientY
      };
      return client2;
    }
    const client = {
      X: mouseEvent.clientX,
      Y: mouseEvent.clientY
    };
    return client;
  }
  /**
   * Start drag function: set the object dragDataObject with the draggable
   * object offsets coordinates.
   * when drag starts (on touchstart or mousedown events).
   * @param {MouseEvent} mouseEvent - Touchstart or mousedown event.
   */
  startDrag(mouseEvent) {
    if (this.properties.state === "minimized") {
      return;
    }
    if (mouseEvent.target === this.title) {
      if (typeof this.dragDataObject === "undefined" || this.dragDataObject === null) {
        this.dragDataObject = {
          x: this.eventClient(mouseEvent).X,
          y: this.eventClient(mouseEvent).Y
        };
        this.lastDrag = {
          x: "0px",
          y: "0px"
        };
        if (this.container.style.right === "") {
          this.container.style.right = "0px";
        }
        if (this.container.style.bottom === "") {
          this.container.style.bottom = "0px";
        }
        if (this.isIE11()) {
        }
        Util.addClass(document.body, "wrs_noselect");
        Util.addClass(this.overlay, "wrs_overlay_active");
        this.limitWindow = this.getLimitWindow();
      }
    }
  }
  /**
   * Updates dragDataObject with the draggable object coordinates when
   * the draggable object is being moved.
   * @param {MouseEvent} mouseEvent - The mouse event.
   */
  drag(mouseEvent) {
    if (this.dragDataObject) {
      mouseEvent.preventDefault();
      let limitY = Math.min(this.eventClient(mouseEvent).Y, this.limitWindow.minPointer.y);
      limitY = Math.max(this.limitWindow.maxPointer.y, limitY);
      let limitX = Math.min(this.eventClient(mouseEvent).X, this.limitWindow.minPointer.x);
      limitX = Math.max(this.limitWindow.maxPointer.x, limitX);
      const dragX = `${limitX - this.dragDataObject.x}px`;
      const dragY = `${limitY - this.dragDataObject.y}px`;
      this.lastDrag = {
        x: dragX,
        y: dragY
      };
      this.container.style.transform = `translate3d(${dragX},${dragY},0)`;
    }
    if (this.resizeDataObject) {
      const { innerWidth } = window;
      const { innerHeight } = window;
      let limitX = Math.min(this.eventClient(mouseEvent).X, innerWidth - this.scrollbarWidth - 7);
      let limitY = Math.min(this.eventClient(mouseEvent).Y, innerHeight - 7);
      if (limitX < 0) {
        limitX = 0;
      }
      if (limitY < 0) {
        limitY = 0;
      }
      let scaleMultiplier;
      if (this.leftScale) {
        scaleMultiplier = -1;
      } else {
        scaleMultiplier = 1;
      }
      this.container.style.width = `${this.initialWidth + scaleMultiplier * (limitX - this.resizeDataObject.x)}px`;
      this.container.style.height = `${this.initialHeight + scaleMultiplier * (limitY - this.resizeDataObject.y)}px`;
      if (!this.leftScale) {
        if (this.resizeDataObject.x - limitX - this.initialWidth < -580) {
          this.container.style.right = `${this.initialRight - (limitX - this.resizeDataObject.x)}px`;
        } else {
          this.container.style.right = `${this.initialRight + this.initialWidth - 580}px`;
          this.container.style.width = "580px";
        }
        if (this.resizeDataObject.y - limitY < this.initialHeight - 338) {
          this.container.style.bottom = `${this.initialBottom - (limitY - this.resizeDataObject.y)}px`;
        } else {
          this.container.style.bottom = `${this.initialBottom + this.initialHeight - 338}px`;
          this.container.style.height = "338px";
        }
      }
      this.recalculateScale();
      this.recalculatePosition();
    }
  }
  /**
   * Returns the boundaries of actual window to limit modal movement.
   * @return {Object} Object containing mouseX and mouseY coordinates of actual mouse on screen.
   */
  getLimitWindow() {
    const maxWidth = window.innerWidth;
    const maxHeight = window.innerHeight;
    const { offsetHeight } = this.container;
    const contStyleBottom = parseInt(this.container.style.bottom, 10);
    const contStyleRight = parseInt(this.container.style.right, 10);
    const { pageXOffset } = window;
    const dragY = this.dragDataObject.y;
    const dragX = this.dragDataObject.x;
    const offSetToolbarY = offsetHeight + contStyleBottom - (maxHeight - (dragY - pageXOffset));
    const offSetToolbarX = maxWidth - this.scrollbarWidth - (dragX - pageXOffset) - contStyleRight;
    const minPointerY = maxHeight - this.container.offsetHeight + offSetToolbarY;
    const maxPointerY = this.title.offsetHeight - (this.title.offsetHeight - offSetToolbarY);
    const minPointerX = maxWidth - offSetToolbarX - this.scrollbarWidth;
    const maxPointerX = this.container.offsetWidth - offSetToolbarX;
    const minPointer = { x: minPointerX, y: minPointerY };
    const maxPointer = { x: maxPointerX, y: maxPointerY };
    return { minPointer, maxPointer };
  }
  /**
   * Returns the scrollbar width size of browser
   * @returns {Number} The scrollbar width.
   */
  // eslint-disable-next-line class-methods-use-this
  getScrollBarWidth() {
    const inner = document.createElement("p");
    inner.style.width = "100%";
    inner.style.height = "200px";
    const outer = document.createElement("div");
    outer.style.position = "absolute";
    outer.style.top = "0px";
    outer.style.left = "0px";
    outer.style.visibility = "hidden";
    outer.style.width = "200px";
    outer.style.height = "150px";
    outer.style.overflow = "hidden";
    outer.appendChild(inner);
    document.body.appendChild(outer);
    const widthOuter = inner.offsetWidth;
    outer.style.overflow = "scroll";
    let widthInner = inner.offsetWidth;
    if (widthOuter === widthInner) {
      widthInner = outer.clientWidth;
    }
    document.body.removeChild(outer);
    return widthOuter - widthInner;
  }
  /**
   * Set the dragDataObject to null.
   */
  stopDrag() {
    if (this.dragDataObject || this.resizeDataObject) {
      this.container.style.transform = "";
      if (this.dragDataObject) {
        this.container.style.right = `${parseInt(this.container.style.right, 10) - parseInt(this.lastDrag.x, 10)}px`;
        this.container.style.bottom = `${parseInt(this.container.style.bottom, 10) - parseInt(this.lastDrag.y, 10)}px`;
      }
      this.focus();
      document.body.style["user-select"] = "";
      if (this.isIE11()) {
      }
      Util.removeClass(document.body, "wrs_noselect");
      Util.removeClass(this.overlay, "wrs_overlay_active");
    }
    this.dragDataObject = null;
    this.resizeDataObject = null;
    this.initialWidth = null;
    this.leftScale = null;
  }
  /**
   * Recalculates scale for modal when resize browser window.
   */
  onWindowResize() {
    this.recalculateScrollBar();
    this.recalculatePosition();
    this.recalculateScale();
  }
  /**
   * Triggers keyboard events:
   * - Tab key tab to go to submit button.
   * - Esc key to close the modal dialog.
   * @param {KeyboardEvent} keyboardEvent - The keyboard event.
   */
  onKeyDown(keyboardEvent) {
    if (keyboardEvent.key !== void 0) {
      if (this.popup.overlayWrapper.style.display !== "block") {
        if (keyboardEvent.key === "Escape" || keyboardEvent.key === "Esc") {
          if (this.properties.open) {
            this.contentManager.onKeyDown(keyboardEvent);
          }
        } else if (keyboardEvent.shiftKey && keyboardEvent.key === "Tab") {
          if (document.activeElement === this.cancelButton) {
            this.submitButton.focus();
            keyboardEvent.stopPropagation();
            keyboardEvent.preventDefault();
          } else {
            this.contentManager.onKeyDown(keyboardEvent);
          }
        } else if (keyboardEvent.key === "Tab") {
          if (document.activeElement === this.submitButton) {
            this.cancelButton.focus();
            keyboardEvent.stopPropagation();
            keyboardEvent.preventDefault();
          } else {
            this.contentManager.onKeyDown(keyboardEvent);
          }
        }
      } else {
        this.popup.onKeyDown(keyboardEvent);
      }
    }
  }
  /**
   * Recalculating position for modal dialog when the browser is resized.
   */
  recalculatePosition() {
    this.container.style.right = `${Math.min(parseInt(this.container.style.right, 10), window.innerWidth - this.scrollbarWidth - this.container.offsetWidth)}px`;
    if (parseInt(this.container.style.right, 10) < 0) {
      this.container.style.right = "0px";
    }
    this.container.style.bottom = `${Math.min(parseInt(this.container.style.bottom, 10), window.innerHeight - this.container.offsetHeight)}px`;
    if (parseInt(this.container.style.bottom, 10) < 0) {
      this.container.style.bottom = "0px";
    }
  }
  /**
   * Recalculating scale for modal when the browser is resized.
   */
  recalculateScale() {
    let sizeModificated = false;
    if (parseInt(this.container.style.width, 10) > 580) {
      this.container.style.width = `${Math.min(parseInt(this.container.style.width, 10), window.innerWidth - this.scrollbarWidth)}px`;
      sizeModificated = true;
    } else {
      this.container.style.width = "580px";
      sizeModificated = true;
    }
    if (parseInt(this.container.style.height, 10) > 338) {
      this.container.style.height = `${Math.min(parseInt(this.container.style.height, 10), window.innerHeight)}px`;
      sizeModificated = true;
    } else {
      this.container.style.height = "338px";
      sizeModificated = true;
    }
    if (sizeModificated) {
      this.recalculateSize();
    }
  }
  /**
   * Recalculating width of browser scroll bar.
   */
  recalculateScrollBar() {
    this.hasScrollBar = window.innerWidth > document.documentElement.clientWidth;
    if (this.hasScrollBar) {
      this.scrollbarWidth = this.getScrollBarWidth();
    } else {
      this.scrollbarWidth = 0;
    }
  }
  /**
   * Hide soft keyboards on iOS devices.
   */
  // eslint-disable-next-line class-methods-use-this
  hideKeyboard() {
    const inputField = document.createElement("input");
    this.container.appendChild(inputField);
    inputField.focus();
    inputField.blur();
    inputField.remove();
  }
  /**
   * Focus to contentManager object.
   */
  focus() {
    if (this.contentManager != null && typeof this.contentManager.onFocus !== "undefined") {
      this.contentManager.onFocus();
    }
  }
  /**
   * Returns true when the device is on portrait mode.
   */
  // eslint-disable-next-line class-methods-use-this
  portraitMode() {
    return window.innerHeight > window.innerWidth;
  }
  /**
   * Event handler that change container size when IOS softkeyboard is opened.
   */
  handleOpenedIosSoftkeyboard() {
    if (!this.iosSoftkeyboardOpened && this.iosDivHeight != null && this.iosDivHeight === `100${this.iosMeasureUnit}`) {
      if (this.portraitMode()) {
        this.setContainerHeight(`63${this.iosMeasureUnit}`);
      } else {
        this.setContainerHeight(`40${this.iosMeasureUnit}`);
      }
    }
    this.iosSoftkeyboardOpened = true;
  }
  /**
   * Event handler that change container size when IOS softkeyboard is closed.
   */
  handleClosedIosSoftkeyboard() {
    this.iosSoftkeyboardOpened = false;
    this.setContainerHeight(`100${this.iosMeasureUnit}`);
  }
  /**
   * Change container sizes when orientation is changed on iOS.
   */
  orientationChangeIosSoftkeyboard() {
    if (this.iosSoftkeyboardOpened) {
      if (this.portraitMode()) {
        this.setContainerHeight(`63${this.iosMeasureUnit}`);
      } else {
        this.setContainerHeight(`40${this.iosMeasureUnit}`);
      }
    } else {
      this.setContainerHeight(`100${this.iosMeasureUnit}`);
    }
  }
  /**
   * Change container sizes when orientation is changed on Android.
   */
  orientationChangeAndroidSoftkeyboard() {
    this.setContainerHeight("100%");
  }
  /**
   * Set iframe container height.
   * @param {Number} height - New height.
   */
  setContainerHeight(height) {
    this.iosDivHeight = height;
    this.wrapper.style.height = height;
  }
  /**
   * Check content of editor before close action.
   */
  showPopUpMessage() {
    if (this.properties.state === "minimized") {
      this.stack();
    }
    this.popup.show();
  }
  /**
   * Sets the tithle of the modal dialog.
   * @param {String} title - Modal dialog title.
   */
  setTitle(title) {
    this.title.innerHTML = title;
  }
  /**
   * Returns the id of an element, adding the instance number to
   * the element class name:
   * className --> className[idNumber]
   * @param {String} className - The element class name.
   * @returns {String} A string appending the instance id to the className.
   */
  getElementId(className) {
    return `${className}[${this.instanceId}]`;
  }
};

// node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/src/polyfills.js
if (!String.prototype.codePointAt) {
  (function() {
    "use strict";
    var codePointAt = function(position) {
      if (this == null) {
        throw TypeError();
      }
      var string = String(this);
      var size = string.length;
      var index = position ? Number(position) : 0;
      if (index != index) {
        index = 0;
      }
      if (index < 0 || index >= size) {
        return void 0;
      }
      var first2 = string.charCodeAt(index);
      var second;
      if (
        // check if it’s the start of a surrogate pair
        first2 >= 55296 && first2 <= 56319 && // high surrogate
        size > index + 1
      ) {
        second = string.charCodeAt(index + 1);
        if (second >= 56320 && second <= 57343) {
          return (first2 - 55296) * 1024 + second - 56320 + 65536;
        }
      }
      return first2;
    };
    if (Object.defineProperty) {
      Object.defineProperty(String.prototype, "codePointAt", {
        "value": codePointAt,
        "configurable": true,
        "writable": true
      });
    } else {
      String.prototype.codePointAt = codePointAt;
    }
  })();
}
if (typeof Object.assign != "function") {
  Object.defineProperty(Object, "assign", {
    value: function assign(target, varArgs) {
      "use strict";
      if (target == null) {
        throw new TypeError("Cannot convert undefined or null to object");
      }
      var to = Object(target);
      for (var index = 1; index < arguments.length; index++) {
        var nextSource = arguments[index];
        if (nextSource != null) {
          for (var nextKey in nextSource) {
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      return to;
    },
    writable: true,
    configurable: true
  });
}
if (!Array.prototype.includes) {
  Object.defineProperty(Array.prototype, "includes", {
    value: function(searchElement, fromIndex) {
      if (this == null) {
        throw new TypeError('"this" s null or is not defined');
      }
      var o = Object(this);
      var len = o.length >>> 0;
      if (len === 0) {
        return false;
      }
      var n = fromIndex | 0;
      var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);
      function sameValueZero(x, y) {
        return x === y || typeof x === "number" && typeof y === "number" && isNaN(x) && isNaN(y);
      }
      while (k < len) {
        if (sameValueZero(o[k], searchElement)) {
          return true;
        }
        k++;
      }
      return false;
    }
  });
}
if (!String.prototype.includes) {
  String.prototype.includes = function(search, start) {
    "use strict";
    if (search instanceof RegExp) {
      throw TypeError("first argument must not be a RegExp");
    }
    if (start === void 0) {
      start = 0;
    }
    return this.indexOf(search, start) !== -1;
  };
}
if (!String.prototype.startsWith) {
  Object.defineProperty(String.prototype, "startsWith", {
    value: function(search, rawPos) {
      var pos = rawPos > 0 ? rawPos | 0 : 0;
      return this.substring(pos, pos + search.length) === search;
    }
  });
}

// node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/src/core.src.js
import "/var/www/html/manorama/node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/styles/styles.css";
var Core = class _Core {
  /**
   * @classdesc
   * This class represents MathType integration Core, managing the following:
   * - Integration initialization.
   * - Event managing.
   * - Insertion of formulas into the edit area.
   * ```js
   *       let core = new Core();
   *       core.addListener(listener);
   *       core.language = 'en';
   *
   *       // Initializing Core class.
   *       core.init(configurationService);
   * ```
   * @constructs
   * Core constructor.
   * @param {CoreProperties}
   */
  constructor(coreProperties) {
    this.language = "en";
    this.editMode = "images";
    this.modalDialog = null;
    this.customEditors = new CustomEditors();
    const chemEditorParams = {
      name: "Chemistry",
      toolbar: "chemistry",
      icon: "chem.png",
      confVariable: "chemEnabled",
      title: "ChemType",
      tooltip: "Insert a chemistry formula - ChemType"
      // TODO: Localize tooltip.
    };
    this.customEditors.addEditor("chemistry", chemEditorParams);
    this.environment = {};
    this.editionProperties = {};
    this.editionProperties.isNewElement = true;
    this.editionProperties.temporalImage = null;
    this.editionProperties.latexRange = null;
    this.editionProperties.range = null;
    this.editionProperties.editionStartTime = null;
    this.integrationModel = null;
    this.contentManager = null;
    this.browser = (() => {
      const ua = navigator.userAgent;
      let browser = "none";
      if (ua.search("Edge/") >= 0) {
        browser = "EDGE";
      } else if (ua.search("Chrome/") >= 0) {
        browser = "CHROME";
      } else if (ua.search("Trident/") >= 0) {
        browser = "IE";
      } else if (ua.search("Firefox/") >= 0) {
        browser = "FIREFOX";
      } else if (ua.search("Safari/") >= 0) {
        browser = "SAFARI";
      }
      return browser;
    })();
    this.listeners = new Listeners();
    this.serviceProviderProperties = {};
    if ("serviceProviderProperties" in coreProperties) {
      this.serviceProviderProperties = coreProperties.serviceProviderProperties;
    } else {
      throw new Error("serviceProviderProperties property missing.");
    }
  }
  /**
   * Static property.
   * Core listeners.
   * @private
   * @type {Listeners}
   */
  static get globalListeners() {
    return _Core._globalListeners;
  }
  /**
   * Static property setter.
   * Set core listeners.
   * @param {Listeners} value - The property value.
   * @ignore
   */
  static set globalListeners(value) {
    _Core._globalListeners = value;
  }
  /**
   * Core state. Says if it was loaded previously.
   * True when Core.init was called. Otherwise, false.
   * @private
   * @type {Boolean}
   */
  static get initialized() {
    return _Core._initialized;
  }
  /**
   * Core state. Says if it was loaded previously.
   * @param {Boolean} value - True to say that Core.init was called. Otherwise, false.
   * @ignore
   */
  static set initialized(value) {
    _Core._initialized = value;
  }
  /**
   * Sets the {@link Core.integrationModel} property.
   * @param {IntegrationModel} integrationModel - The {@link IntegrationModel} property.
   */
  setIntegrationModel(integrationModel) {
    this.integrationModel = integrationModel;
  }
  /**
   * Sets the {@link Core.environment} property.
   * @param {IntegrationEnvironment} integrationEnvironment -
   * The {@link IntegrationEnvironment} object.
   */
  setEnvironment(integrationEnvironment) {
    if ("editor" in integrationEnvironment) {
      this.environment.editor = integrationEnvironment.editor;
    }
    if ("mode" in integrationEnvironment) {
      this.environment.mode = integrationEnvironment.mode;
    }
    if ("version" in integrationEnvironment) {
      this.environment.version = integrationEnvironment.version;
    }
  }
  /**
   * Returns the current {@link ModalDialog} instance.
   * @returns {ModalDialog} The current {@link ModalDialog} instance.
   */
  getModalDialog() {
    return this.modalDialog;
  }
  /**
   * Inits the {@link Core} class, doing the following:
   * - Calls asynchronously configuration service, retrieving the backend configuration in a JSON.
   * - Updates {@link Configuration} class with the previous configuration properties.
   * - Updates the {@link ServiceProvider} class using the configuration service path as reference.
   * - Loads language strings.
   * - Fires onLoad event.
   * @param {Object} serviceParameters - Service parameters.
   */
  init() {
    if (!_Core.initialized) {
      const serviceProviderListener = Listeners.newListener("onInit", () => {
        const jsConfiguration = ServiceProvider.getService("configurationjs", "", "get");
        const jsonConfiguration = JSON.parse(jsConfiguration);
        Configuration.addConfiguration(jsonConfiguration);
        Configuration.addConfiguration(jsvariables_default);
        StringManager.language = this.language;
        this.listeners.fire("onLoad", {});
      });
      ServiceProvider.addListener(serviceProviderListener);
      ServiceProvider.init(this.serviceProviderProperties);
      _Core.initialized = true;
    } else {
      this.listeners.fire("onLoad", {});
    }
  }
  /**
   * Adds a {@link Listener} to the current instance of the {@link Core} class.
   * @param {Listener} listener - The listener object.
   */
  addListener(listener) {
    this.listeners.add(listener);
  }
  /**
   * Adds the global {@link Listener} instance to {@link Core} class.
   * @param {Listener} listener - The event listener to be added.
   * @static
   */
  static addGlobalListener(listener) {
    _Core.globalListeners.add(listener);
  }
  beforeUpdateFormula(mathml, wirisProperties) {
    const beforeUpdateEvent = new Event();
    beforeUpdateEvent.mathml = mathml;
    beforeUpdateEvent.wirisProperties = {};
    if (wirisProperties != null) {
      Object.keys(wirisProperties).forEach((attr) => {
        beforeUpdateEvent.wirisProperties[attr] = wirisProperties[attr];
      });
    }
    beforeUpdateEvent.language = this.language;
    beforeUpdateEvent.editMode = this.editMode;
    if (this.listeners.fire("onBeforeFormulaInsertion", beforeUpdateEvent)) {
      return {};
    }
    if (_Core.globalListeners.fire("onBeforeFormulaInsertion", beforeUpdateEvent)) {
      return {};
    }
    return {
      mathml: beforeUpdateEvent.mathml,
      wirisProperties: beforeUpdateEvent.wirisProperties
    };
  }
  /**
   * Converts a MathML into it's correspondent image and inserts the image is
   * inserted in a HTMLElement target by creating
   * a new image or updating an existing one.
   * @param {HTMLElement} focusElement - The HTMLElement to be focused after the insertion.
   * @param {Window} windowTarget - The window element where the editable content is.
   * @param {String} mathml - The MathML.
   * @param {Array.<Object>} wirisProperties - The extra attributes for the formula.
   * @returns {ReturnObject} - Object with the information of the node or latex to insert.
   */
  insertFormula(focusElement, windowTarget, mathml, wirisProperties) {
    const returnObject = {};
    if (!mathml) {
      this.insertElementOnSelection(null, focusElement, windowTarget);
    } else if (this.editMode === "latex") {
      returnObject.latex = Latex.getLatexFromMathML(mathml);
      if (!!this.integrationModel.fillNonLatexNode && !returnObject.latex) {
        const afterUpdateEvent = new Event();
        afterUpdateEvent.editMode = this.editMode;
        afterUpdateEvent.windowTarget = windowTarget;
        afterUpdateEvent.focusElement = focusElement;
        afterUpdateEvent.latex = returnObject.latex;
        this.integrationModel.fillNonLatexNode(afterUpdateEvent, windowTarget, mathml);
      } else {
        returnObject.node = windowTarget.document.createTextNode(`$$${returnObject.latex}$$`);
      }
      this.insertElementOnSelection(returnObject.node, focusElement, windowTarget);
    } else {
      returnObject.node = Parser.mathmlToImgObject(
        windowTarget.document,
        mathml,
        wirisProperties,
        this.language
      );
      this.insertElementOnSelection(returnObject.node, focusElement, windowTarget);
    }
    return returnObject;
  }
  afterUpdateFormula(focusElement, windowTarget, node, latex) {
    const afterUpdateEvent = new Event();
    afterUpdateEvent.editMode = this.editMode;
    afterUpdateEvent.windowTarget = windowTarget;
    afterUpdateEvent.focusElement = focusElement;
    afterUpdateEvent.node = node;
    afterUpdateEvent.latex = latex;
    if (this.listeners.fire("onAfterFormulaInsertion", afterUpdateEvent)) {
      return {};
    }
    if (_Core.globalListeners.fire("onAfterFormulaInsertion", afterUpdateEvent)) {
      return {};
    }
    return {};
  }
  /**
   * Sets the caret after a given Node and set the focus to the owner document.
   * @param {Node} node - The Node element.
   */
  placeCaretAfterNode(node) {
    this.integrationModel.getSelection();
    const nodeDocument = node.ownerDocument;
    if (typeof nodeDocument.getSelection !== "undefined" && !!node.parentElement) {
      const range = nodeDocument.createRange();
      range.setStartAfter(node);
      range.collapse(true);
      const selection = nodeDocument.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
      nodeDocument.body.focus();
    }
  }
  /**
   * Replaces a Selection object with an HTMLElement.
   * @param {HTMLElement} element - The HTMLElement to replace the selection.
   * @param {HTMLElement} focusElement - The HTMLElement to be focused after the replace.
   * @param {Window} windowTarget - The window target.
   */
  insertElementOnSelection(element, focusElement, windowTarget) {
    var _a, _b;
    let mathmlOrigin = null;
    if (this.editionProperties.isNewElement) {
      if (element) {
        if (focusElement.type === "textarea") {
          Util.updateTextArea(focusElement, element.textContent);
        } else if (document.selection && document.getSelection === 0) {
          let range = windowTarget.document.selection.createRange();
          windowTarget.document.execCommand("InsertImage", false, element.src);
          if (!("parentElement" in range)) {
            windowTarget.document.execCommand("delete", false);
            range = windowTarget.document.selection.createRange();
            windowTarget.document.execCommand("InsertImage", false, element.src);
          }
          if ("parentElement" in range) {
            const temporalObject = range.parentElement();
            if (temporalObject.nodeName.toUpperCase() === "IMG") {
              temporalObject.parentNode.replaceChild(element, temporalObject);
            } else {
              range.pasteHTML(Util.createObjectCode(element));
            }
          }
        } else {
          const editorSelection = this.integrationModel.getSelection();
          let range = null;
          if (this.editionProperties.range) {
            ({ range } = this.editionProperties);
            this.editionProperties.range = null;
          } else {
            range = editorSelection.getRangeAt(0);
          }
          range.deleteContents();
          let node = range.startContainer;
          const position = range.startOffset;
          if (node.nodeType === 3) {
            node = node.splitText(position);
            node.parentNode.insertBefore(element, node);
          } else if (node.nodeType === 1) {
            node.insertBefore(element, node.childNodes[position]);
          }
          this.placeCaretAfterNode(element);
        }
      } else if (focusElement.type === "textarea") {
        focusElement.focus();
      } else {
        const editorSelection = this.integrationModel.getSelection();
        editorSelection.removeAllRanges();
        if (this.editionProperties.range) {
          const { range } = this.editionProperties;
          this.editionProperties.range = null;
          editorSelection.addRange(range);
        }
      }
    } else if (this.editionProperties.latexRange) {
      if (document.selection && document.getSelection === 0) {
        this.editionProperties.isNewElement = true;
        this.editionProperties.latexRange.select();
        this.insertElementOnSelection(element, focusElement, windowTarget);
      } else {
        this.editionProperties.latexRange.deleteContents();
        this.editionProperties.latexRange.insertNode(element);
        this.placeCaretAfterNode(element);
      }
    } else if (focusElement.type === "textarea") {
      let item;
      if (typeof this.integrationModel.getSelectedItem !== "undefined") {
        item = this.integrationModel.getSelectedItem(focusElement, false);
      } else {
        item = Util.getSelectedItemOnTextarea(focusElement);
      }
      Util.updateExistingTextOnTextarea(
        focusElement,
        element.textContent,
        item.startPosition,
        item.endPosition
      );
    } else {
      mathmlOrigin = (_a = this.editionProperties.temporalImage) == null ? void 0 : _a.dataset.mathml;
      if (element && element.nodeName.toLowerCase() === "img") {
        Image.removeImgDataAttributes(this.editionProperties.temporalImage);
        Image.clone(element, this.editionProperties.temporalImage);
      } else {
        this.editionProperties.temporalImage.remove();
      }
      this.placeCaretAfterNode(this.editionProperties.temporalImage);
    }
    const mathml = (_b = element == null ? void 0 : element.dataset) == null ? void 0 : _b.mathml;
    let payload = {
      mathml_origin: mathmlOrigin ? MathML.safeXmlDecode(mathmlOrigin) : mathmlOrigin,
      mathml: mathml ? MathML.safeXmlDecode(mathml) : mathml,
      elapsed_time: Date.now() - this.editionProperties.editionStartTime,
      editor_origin: null,
      // TODO read formula to find out whether it comes from Oxygen Desktop
      toolbar: this.modalDialog.contentManager.toolbar,
      size: mathml == null ? void 0 : mathml.length
    };
    Object.keys(payload).forEach((key) => {
      if (key === "mathml_origin" || key === "editor_origin")
        !payload[key] ? delete payload[key] : {};
    });
    try {
      Telemeter2.telemeter.track("INSERTED_FORMULA", {
        ...payload
      });
    } catch (err) {
      console.error(err);
    }
  }
  /**
   * Opens a modal dialog containing MathType editor..
   * @param {HTMLElement} target - The target HTMLElement where formulas should be inserted.
   * @param {Boolean} isIframe - True if the target HTMLElement is an iframe. False otherwise.
   */
  openModalDialog(target, isIframe) {
    this.editionProperties.editionStartTime = Date.now();
    this.editMode = "images";
    try {
      if (isIframe) {
        target.contentWindow.focus();
        const selection = target.contentWindow.getSelection();
        this.editionProperties.range = selection.getRangeAt(0);
      } else {
        target.focus();
        const selection = getSelection();
        this.editionProperties.range = selection.getRangeAt(0);
      }
    } catch (e) {
      this.editionProperties.range = null;
    }
    if (isIframe === void 0) {
      isIframe = true;
    }
    this.editionProperties.latexRange = null;
    if (target) {
      let selectedItem;
      if (typeof this.integrationModel.getSelectedItem !== "undefined") {
        selectedItem = this.integrationModel.getSelectedItem(target, isIframe);
      } else {
        selectedItem = Util.getSelectedItem(target, isIframe);
      }
      if (selectedItem) {
        if (!selectedItem.caretPosition && Util.containsClass(selectedItem.node, Configuration.get("imageClassName"))) {
          this.editionProperties.temporalImage = selectedItem.node;
          this.editionProperties.isNewElement = false;
        } else if (selectedItem.node.nodeType === 3) {
          if (this.integrationModel.getMathmlFromTextNode) {
            const mathml = this.integrationModel.getMathmlFromTextNode(
              selectedItem.node,
              selectedItem.caretPosition
            );
            if (mathml) {
              this.editMode = "latex";
              this.editionProperties.isNewElement = false;
              this.editionProperties.temporalImage = document.createElement("img");
              this.editionProperties.temporalImage.setAttribute(
                Configuration.get("imageMathmlAttribute"),
                MathML.safeXmlEncode(mathml)
              );
            }
          } else {
            const latexResult = Latex.getLatexFromTextNode(
              selectedItem.node,
              selectedItem.caretPosition
            );
            if (latexResult) {
              const mathml = Latex.getMathMLFromLatex(latexResult.latex);
              this.editMode = "latex";
              this.editionProperties.isNewElement = false;
              this.editionProperties.temporalImage = document.createElement("img");
              this.editionProperties.temporalImage.setAttribute(
                Configuration.get("imageMathmlAttribute"),
                MathML.safeXmlEncode(mathml)
              );
              const windowTarget = isIframe ? target.contentWindow : window;
              if (target.tagName.toLowerCase() !== "textarea") {
                if (document.selection) {
                  let leftOffset = 0;
                  let previousNode = latexResult.startNode.previousSibling;
                  while (previousNode) {
                    leftOffset += Util.getNodeLength(previousNode);
                    previousNode = previousNode.previousSibling;
                  }
                  this.editionProperties.latexRange = windowTarget.document.selection.createRange();
                  this.editionProperties.latexRange.moveToElementText(
                    latexResult.startNode.parentNode
                  );
                  this.editionProperties.latexRange.move(
                    "character",
                    leftOffset + latexResult.startPosition
                  );
                  this.editionProperties.latexRange.moveEnd(
                    "character",
                    latexResult.latex.length + 4
                  );
                } else {
                  this.editionProperties.latexRange = windowTarget.document.createRange();
                  this.editionProperties.latexRange.setStart(
                    latexResult.startNode,
                    latexResult.startPosition
                  );
                  this.editionProperties.latexRange.setEnd(
                    latexResult.endNode,
                    latexResult.endPosition
                  );
                }
              }
            }
          }
        }
      } else if (target.tagName.toLowerCase() === "textarea") {
        this.editMode = "latex";
      }
    }
    const defaultEditorAttributesArray = Configuration.get("editorAttributes").split(", ");
    const defaultEditorAttributes = {};
    for (let i = 0, len = defaultEditorAttributesArray.length; i < len; i += 1) {
      const tempAttribute = defaultEditorAttributesArray[i].split("=");
      const key = tempAttribute[0];
      const value = tempAttribute[1];
      defaultEditorAttributes[key] = value;
    }
    const editorAttributes = {
      language: this.language
      // Default language value
    };
    const serverEditorParameters = Configuration.get("editorParameters");
    const cliendEditorParameters = this.integrationModel.editorParameters;
    Object.assign(editorAttributes, defaultEditorAttributes, serverEditorParameters);
    Object.assign(editorAttributes, defaultEditorAttributes, cliendEditorParameters);
    this.language = editorAttributes.language;
    StringManager.language = this.language;
    editorAttributes.rtl = this.integrationModel.rtl;
    const contentManagerAttributes = {};
    contentManagerAttributes.editorAttributes = editorAttributes;
    contentManagerAttributes.language = this.language;
    contentManagerAttributes.customEditors = this.customEditors;
    contentManagerAttributes.environment = this.environment;
    if (this.modalDialog == null) {
      this.modalDialog = new ModalDialog(editorAttributes);
      this.contentManager = new ContentManager(contentManagerAttributes);
      const listener = Listeners.newListener("onLoad", () => {
        this.contentManager.dbclick = this.editionProperties.dbclick;
        this.contentManager.isNewElement = this.editionProperties.isNewElement;
        if (this.editionProperties.temporalImage != null) {
          const mathML = MathML.safeXmlDecode(this.editionProperties.temporalImage.getAttribute(Configuration.get("imageMathmlAttribute")));
          this.contentManager.mathML = mathML;
        }
      });
      this.contentManager.addListener(listener);
      this.contentManager.init();
      this.modalDialog.setContentManager(this.contentManager);
      this.contentManager.setModalDialogInstance(this.modalDialog);
    } else {
      this.contentManager.dbclick = this.editionProperties.dbclick;
      this.contentManager.isNewElement = this.editionProperties.isNewElement;
      if (this.editionProperties.temporalImage != null) {
        const mathML = MathML.safeXmlDecode(this.editionProperties.temporalImage.getAttribute(Configuration.get("imageMathmlAttribute")));
        this.contentManager.mathML = mathML;
      }
    }
    this.contentManager.setIntegrationModel(this.integrationModel);
    this.modalDialog.open();
  }
  /**
   * Returns the {@link CustomEditors} instance.
   * @return {CustomEditors} The current {@link CustomEditors} instance.
   */
  getCustomEditors() {
    return this.customEditors;
  }
};
Core._globalListeners = new Listeners();
Core._initialized = false;

// node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/src/integrationmodel.js
import warnIcon from "/var/www/html/manorama/node_modules/@wiris/mathtype-ckeditor5/node_modules/@wiris/mathtype-html-integration-devkit/styles/icons/general/warn_icon.svg";
var IntegrationModel = class _IntegrationModel {
  /**
   * @classdesc
   * This class represents an integration model, allowing the integration script to
   * communicate with Core class. Each integration must extend this class.
   * @constructs
   * @param {IntegrationModelProperties} integrationModelProperties
   */
  constructor(integrationModelProperties) {
    this.language = "en";
    this.serviceProviderProperties = {};
    if ("serviceProviderProperties" in integrationModelProperties) {
      this.serviceProviderProperties = integrationModelProperties.serviceProviderProperties;
    }
    this.configurationService = "";
    if ("configurationService" in integrationModelProperties) {
      this.serviceProviderProperties.URI = integrationModelProperties.configurationService;
      console.warn(
        "Deprecated property configurationService. Use serviceParameters on instead.",
        [integrationModelProperties.configurationService]
      );
    }
    this.version = "version" in integrationModelProperties ? integrationModelProperties.version : "";
    this.target = null;
    if ("target" in integrationModelProperties) {
      this.target = integrationModelProperties.target;
    } else {
      throw new Error("IntegrationModel constructor error: target property missed.");
    }
    if ("scriptName" in integrationModelProperties) {
      this.scriptName = integrationModelProperties.scriptName;
    }
    this.callbackMethodArguments = {};
    if ("callbackMethodArguments" in integrationModelProperties) {
      this.callbackMethodArguments = integrationModelProperties.callbackMethodArguments;
    }
    this.environment = {};
    if ("environment" in integrationModelProperties) {
      this.environment = integrationModelProperties.environment;
    }
    this.isIframe = false;
    if (this.target != null) {
      this.isIframe = this.target.tagName.toUpperCase() === "IFRAME";
    }
    this.editorObject = null;
    if ("editorObject" in integrationModelProperties) {
      this.editorObject = integrationModelProperties.editorObject;
    }
    this.rtl = false;
    if ("rtl" in integrationModelProperties) {
      this.rtl = integrationModelProperties.rtl;
    }
    this.managesLanguage = false;
    if ("managesLanguage" in integrationModelProperties) {
      this.managesLanguage = integrationModelProperties.managesLanguage;
    }
    this.temporalImageResizing = false;
    this.core = null;
    this.listeners = new Listeners();
    if ("integrationParameters" in integrationModelProperties) {
      _IntegrationModel.integrationParameters.forEach((parameter) => {
        if (parameter in integrationModelProperties.integrationParameters) {
          const value = integrationModelProperties.integrationParameters[parameter];
          if (Object.keys(value).length !== 0) {
            this[parameter] = value;
          }
        }
      });
    }
  }
  /**
   * Init function. Usually called from the integration side once the core.js file is loaded.
   */
  init() {
    this.language = this.getLanguage();
    const listener = Listeners.newListener("onLoad", () => {
      this.callbackFunction(this.callbackMethodArguments);
    });
    if (this.serviceProviderProperties.URI.indexOf("configuration") !== -1) {
      const uri = this.serviceProviderProperties.URI;
      const server = ServiceProvider.getServerLanguageFromService(uri);
      this.serviceProviderProperties.server = server;
      const configurationIndex = this.serviceProviderProperties.URI.indexOf("configuration");
      const subsTring = this.serviceProviderProperties.URI.substring(0, configurationIndex);
      this.serviceProviderProperties.URI = subsTring;
    }
    let serviceParametersURI = this.serviceProviderProperties.URI;
    serviceParametersURI = serviceParametersURI.indexOf("/") === 0 || serviceParametersURI.indexOf("http") === 0 ? serviceParametersURI : Util.concatenateUrl(this.getPath(), serviceParametersURI);
    this.serviceProviderProperties.URI = serviceParametersURI;
    const coreProperties = {};
    coreProperties.serviceProviderProperties = this.serviceProviderProperties;
    this.setCore(new Core(coreProperties));
    this.core.addListener(listener);
    this.core.language = this.language;
    this.core.init();
    this.core.setEnvironment(this.environment);
    let attributes = {};
    attributes.class = attributes.id = "wrs_modal_offline";
    this.offlineModal = Util.createElement("div", attributes);
    attributes = {};
    attributes.class = "wrs_modal_content_offline";
    this.offlineModalContent = Util.createElement("div", attributes);
    attributes = {};
    attributes.class = "wrs_modal_offline_close";
    this.offlineModalClose = Util.createElement("span", attributes);
    this.offlineModalClose.innerHTML = "&times;";
    attributes = {};
    attributes.class = "wrs_modal_offline_warn";
    this.offlineModalWarn = Util.createElement("span", attributes);
    let generalStyle = `background-image: url(data:image/svg+xml;base64,${window.btoa(warnIcon)})`;
    this.offlineModalWarn.setAttribute("style", generalStyle);
    attributes = {};
    attributes.class = "wrs_modal_offline_text_container";
    this.offlineModalMessage = Util.createElement("div", attributes);
    attributes = {};
    attributes.class = "wrs_modal_offline_text_warn";
    this.offlineModalMessage1 = Util.createElement("p", attributes);
    this.offlineModalMessage1.innerHTML = "You are not online!";
    attributes = {};
    attributes.class = "wrs_modal_offline_text";
    this.offlineModalMessage2 = Util.createElement("p", attributes);
    this.offlineModalMessage2.innerHTML = `Thank you for using MathType. We have detected you are disconnected from the network. We remind you that you'll need to be connected to use MathType. <br /><br />Please refresh the page if this message continues appearing.`;
    this.offlineModalContent.appendChild(this.offlineModalClose);
    this.offlineModalMessage.appendChild(this.offlineModalMessage1);
    this.offlineModalMessage.appendChild(this.offlineModalMessage2);
    this.offlineModalContent.appendChild(this.offlineModalMessage);
    this.offlineModalContent.appendChild(this.offlineModalWarn);
    this.offlineModal.appendChild(this.offlineModalContent);
    document.body.appendChild(this.offlineModal);
    let modal = document.getElementById("wrs_modal_offline");
    this.offlineModalClose.addEventListener("click", function() {
      modal.style.display = "none";
    });
    let editorName = this.environment.editor;
    editorName = editorName.slice(0, -1);
    if (editorName.includes("TinyMCE"))
      editorName = "TinyMCE";
    if (editorName.includes("Generic"))
      editorName = "Generic";
    let solutionTelemeter = editorName;
    let isMoodle = !!(typeof M === "object" && M !== null), lms;
    if (isMoodle) {
      solutionTelemeter = "Moodle";
      lms = {
        nam: "moodle",
        fam: "lms",
        ver: this.environment.moodleVersion,
        category: this.environment.moodleCourseCategory,
        course: this.environment.moodleCourseName
      };
      if (!editorName.includes("TinyMCE")) {
        editorName = "Atto";
      }
    }
    let OSData = this.getOS();
    let broswerData = this.getBrowser();
    let hosts = [
      {
        nam: broswerData.detectedBrowser,
        fam: "browser",
        ver: broswerData.versionBrowser
      },
      {
        nam: editorName.toLowerCase(),
        fam: "html-editor",
        ver: this.environment.editorVersion
      },
      {
        nam: OSData.detectedOS,
        fam: "os",
        ver: OSData.versionOS
      },
      {
        nam: window.location.hostname,
        fam: "domain"
      },
      lms
    ];
    hosts = hosts.filter(function(element) {
      if (element)
        Object.keys(element).forEach((key) => element[key] === "unknown" ? delete element[key] : {});
      return element !== void 0;
    });
    Telemeter2.init({
      solution: {
        name: "MathType for " + solutionTelemeter,
        version: this.version
      },
      hosts,
      config: {
        test: false,
        // True to use the staging Telemetry endpoint instead of the production one.
        debug: false,
        // True to show more information about Telemeter's execution and use dev-tools.
        dry_run: false,
        // True to skip sending data to the Telemetry endpoint (for example for unit tests).
        api_key: "eda2ce9b-0e8a-46f2-acdd-c228a615314e"
        // to auth against Telemetry. Data team is the responsible of providing it.
      },
      url: void 0
    });
  }
  /**
   * Returns the Browser name and its version.
   * @return {array} - detectedBrowser = Operating System name.
   *                   versionBrowser = Operating System version.
   */
  getBrowser() {
    let detectedBrowser = "unknown", versionBrowser = "unknown";
    let userAgent2 = window.navigator.userAgent;
    if (/Brave/.test(userAgent2)) {
      detectedBrowser = "brave";
      if (userAgent2.indexOf("Brave/")) {
        let start = userAgent2.indexOf("Brave") + 6;
        let end = userAgent2.substring(start).indexOf(" ");
        end = end === -1 ? userAgent2.lastIndexOf("") : end;
        versionBrowser = userAgent2.substring(start, end + start).replace("_", ".").replace(/[^\d.-]/g, "");
      }
    } else if (userAgent2.indexOf("Edg/") !== -1) {
      detectedBrowser = "edge_chromium";
      let start = userAgent2.indexOf("Edg/") + 4;
      versionBrowser = userAgent2.substring(start).replace("_", ".").replace(/[^\d.-]/g, "");
    } else if (/Edg/.test(userAgent2)) {
      detectedBrowser = "edge";
      let start = userAgent2.indexOf("Edg") + 3;
      start = start + userAgent2.substring(start).indexOf("/");
      let end = userAgent2.substring(start).indexOf(" ");
      end = end === -1 ? userAgent2.lastIndexOf("") : end;
      versionBrowser = userAgent2.substring(start, end + start).replace("_", ".").replace(/[^\d.-]/g, "");
    } else if (/Firefox/.test(userAgent2) || /FxiOS/.test(userAgent2)) {
      detectedBrowser = "firefox";
      let start = userAgent2.indexOf("Firefox");
      start = start === -1 ? userAgent2.indexOf("FxiOS") : start;
      start = start + userAgent2.substring(start).indexOf("/") + 1;
      let end = userAgent2.substring(start).indexOf(" ");
      end = end === -1 ? userAgent2.lastIndexOf("") : end;
      versionBrowser = userAgent2.substring(start, end + start).replace("_", ".");
    } else if (/OPR/.test(userAgent2)) {
      detectedBrowser = "opera";
      let start = userAgent2.indexOf("OPR/") + 4;
      let end = userAgent2.substring(start).indexOf(" ");
      end = end === -1 ? userAgent2.lastIndexOf("") : end;
      versionBrowser = userAgent2.substring(start, end + start).replace("_", ".").replace(/[^\d.-]/g, "");
    } else if (/Chrome/.test(userAgent2) || /CriOS/.test(userAgent2)) {
      detectedBrowser = "chrome";
      let start = userAgent2.indexOf("Chrome");
      start = start === -1 ? userAgent2.indexOf("CriOS") : start;
      start = start + userAgent2.substring(start).indexOf("/") + 1;
      let end = userAgent2.substring(start).indexOf(" ");
      end = end === -1 ? userAgent2.lastIndexOf("") : end;
      versionBrowser = userAgent2.substring(start, end + start).replace("_", ".");
    } else if (/Safari/.test(userAgent2)) {
      detectedBrowser = "safari";
      let start = userAgent2.indexOf("Version/");
      start = start + userAgent2.substring(start).indexOf("/") + 1;
      let end = userAgent2.substring(start).indexOf(" ");
      end = end === -1 ? userAgent2.lastIndexOf("") : end;
      versionBrowser = userAgent2.substring(start, end + start).replace("_", ".");
    }
    return { detectedBrowser, versionBrowser };
  }
  /**
   * Returns the operating system and its version.
   * @return {array} - detectedOS = Operating System name.
   *                   versionOS = Operating System version.
   */
  getOS() {
    let detectedOS = "unknown", versionOS = "unknown";
    let userAgent2 = window.navigator.userAgent, platform = window.navigator.platform, macosPlatforms = ["Macintosh", "MacIntel", "MacPPC", "Mac68K"], windowsPlatforms = ["Win32", "Win64", "Windows", "WinCE"], iosPlatforms = ["iPhone", "iPad", "iPod"];
    if (macosPlatforms.indexOf(platform) !== -1) {
      detectedOS = "macos";
      if (userAgent2.indexOf("OS X") !== -1) {
        let start = userAgent2.indexOf("OS X") + 5;
        let end = userAgent2.substring(start).indexOf(" ");
        versionOS = userAgent2.substring(start, end + start).replace("_", ".").replace(/[^\d.-]/g, "");
      }
    } else if (iosPlatforms.indexOf(platform) !== -1) {
      detectedOS = "ios";
      if (userAgent2.indexOf("OS ") !== -1) {
        let start = userAgent2.indexOf("OS ") + 3;
        let end = userAgent2.substring(start).indexOf(")");
        versionOS = userAgent2.substring(start, end + start).replace("_", ".").replace(/[^\d.-]/g, "");
      }
    } else if (windowsPlatforms.indexOf(platform) !== -1) {
      detectedOS = "windows";
      let start = userAgent2.indexOf("Windows");
      let end = userAgent2.substring(start).indexOf(";");
      if (end === -1) {
        end = userAgent2.substring(start).indexOf(")");
      }
      versionOS = userAgent2.substring(start, end + start).replace("_", ".").replace(/[^\d.-]/g, "");
    } else if (/Android/.test(userAgent2)) {
      detectedOS = "android";
      let start = userAgent2.indexOf("Android");
      let end = userAgent2.substring(start).indexOf(";");
      if (end === -1) {
        end = userAgent2.substring(start).indexOf(")");
      }
      versionOS = userAgent2.substring(start, end + start).replace("_", ".").replace(/[^\d.-]/g, "");
    } else if (/CrOS/.test(userAgent2)) {
      detectedOS = "chromeos";
      let start = userAgent2.indexOf("CrOS ") + 5;
      start = start + userAgent2.substring(start).indexOf(" ");
      let end = userAgent2.substring(start).indexOf(")");
      versionOS = userAgent2.substring(start, end + start).replace("_", ".").replace(/[^\d.-]/g, "");
    } else if (detectedOS === "unknown" && /Linux/.test(platform)) {
      detectedOS = "linux";
    }
    return { detectedOS, versionOS };
  }
  /**
   * Returns the absolute path of the integration script.
   * @return {string} - Absolute path for the integration script.
   */
  getPath() {
    if (typeof this.scriptName === "undefined") {
      throw new Error("scriptName property needed for getPath.");
    }
    const col = document.getElementsByTagName("script");
    let path = "";
    for (let i = 0; i < col.length; i += 1) {
      const j = col[i].src.lastIndexOf(this.scriptName);
      if (j >= 0) {
        path = col[i].src.substr(0, j - 1);
      }
    }
    return path;
  }
  /**
   * Returns integration model plugin version
   * @param {string} - Plugin version
   */
  getVersion() {
    return this.version;
  }
  /**
   * Sets the language property.
   * @param {string} language - language code.
   */
  setLanguage(language) {
    this.language = language;
  }
  /**
   * Sets a Core instance.
   * @param {Core} core - instance of Core class.
   */
  setCore(core) {
    this.core = core;
    core.setIntegrationModel(this);
  }
  /**
   * Returns the Core instance.
   * @returns {Core} instance of Core class.
   */
  getCore() {
    return this.core;
  }
  /**
   * Sets the object target and updates the iframe property.
   * @param {HTMLElement} target - target object.
   */
  setTarget(target) {
    this.target = target;
    this.isIframe = this.target.tagName.toUpperCase() === "IFRAME";
  }
  /**
   * Sets the editor object.
   * @param {Object} editorObject - The editor object.
   */
  setEditorObject(editorObject) {
    this.editorObject = editorObject;
  }
  /**
   * Opens formula editor to editing a new formula. Can be overwritten in order to make some
   * actions from integration part before the formula is edited.
   */
  openNewFormulaEditor() {
    if (window.navigator.onLine) {
      this.core.editionProperties.dbclick = false;
      this.core.editionProperties.isNewElement = true;
      this.core.openModalDialog(this.target, this.isIframe);
    } else {
      let modal = document.getElementById("wrs_modal_offline");
      modal.style.display = "block";
    }
  }
  /**
   * Opens formula editor to editing an existing formula. Can be overwritten in order to make some
   * actions from integration part before the formula is edited.
   */
  openExistingFormulaEditor() {
    if (window.navigator.onLine) {
      this.core.editionProperties.isNewElement = false;
      this.core.openModalDialog(this.target, this.isIframe);
    } else {
      let modal = document.getElementById("wrs_modal_offline");
      modal.style.display = "block";
    }
  }
  /**
   * Wrapper to Core.updateFormula method.
   * Transform a MathML into a image formula.
   * Then the image formula is inserted in the specified target, creating a new image (new formula)
   * or updating an existing one.
   * @param {string} mathml - MathML to generate the formula.
   * @param {string} editMode - Edit Mode (LaTeX or images).
   */
  updateFormula(mathml) {
    if (this.editorParameters) {
      mathml = com.wiris.editor.util.EditorUtils.addAnnotation(mathml, "application/vnd.wiris.mtweb-params+json", JSON.stringify(this.editorParameters));
    }
    let focusElement;
    let windowTarget;
    const wirisProperties = null;
    if (this.isIframe) {
      focusElement = this.target.contentWindow;
      windowTarget = this.target.contentWindow;
    } else {
      focusElement = this.target;
      windowTarget = window;
    }
    let obj = this.core.beforeUpdateFormula(mathml, wirisProperties);
    if (!obj) {
      return "";
    }
    obj = this.insertFormula(focusElement, windowTarget, obj.mathml, obj.wirisProperties);
    if (!obj) {
      return "";
    }
    return this.core.afterUpdateFormula(obj.focusElement, obj.windowTarget, obj.node, obj.latex);
  }
  /**
   * Wrapper to Core.insertFormula method.
   * Inserts the formula in the specified target, creating
   * a new image (new formula) or updating an existing one.
   * @param {string} mathml - MathML to generate the formula.
   * @param {string} editMode - Edit Mode (LaTeX or images).
   * @returns {ReturnObject} - Object with the information of the node or latex to insert.
   */
  insertFormula(focusElement, windowTarget, mathml, wirisProperties) {
    const obj = this.core.insertFormula(focusElement, windowTarget, mathml, wirisProperties);
    this.core.editionProperties.temporalImage = null;
    return obj;
  }
  /**
   * Returns the target selection.
   * @returns {Selection} target selection.
   */
  getSelection() {
    if (this.isIframe) {
      this.target.contentWindow.focus();
      return this.target.contentWindow.getSelection();
    }
    this.target.focus();
    return window.getSelection();
  }
  /**
   * Add events to formulas in the DOM target. The events added are the following:
   * - doubleClickHandler: handles Double-click event on formulas by opening an editor
   * to edit them.
   * - mouseDownHandler: handles mouse down event on formulas by saving the size of the formula
   * in case the the formula is resized.
   * - mouseUpHandler: handles mouse up event on formulas by restoring the saved formula size
   * in case the formula is resized.
   */
  addEvents() {
    const eventTarget = this.isIframe ? this.target.contentWindow.document : this.target;
    Util.addElementEvents(
      eventTarget,
      (element, event) => {
        this.doubleClickHandler(element, event);
        event.stopImmediatePropagation();
      },
      (element, event) => {
        this.mousedownHandler(element, event);
      },
      (element, event) => {
        this.mouseupHandler(element, event);
      }
    );
  }
  /**
   * Remove events to formulas in the DOM target.
   */
  removeEvents() {
    const eventTarget = this.isIframe ? this.target.contentWindow.document : this.target;
    Util.removeElementEvents(eventTarget);
  }
  /**
   * Remove events and set this.editorObject to null in order to prevent memory leaks.
   */
  destroy() {
    this.removeEvents();
    this.editorObject = null;
  }
  /**
   * Handles a Double-click on the target element. Opens an editor
   * to re-edit the double-clicked formula.
   * @param {HTMLElement} element - DOM object target.
   */
  doubleClickHandler(element) {
    this.core.editionProperties.dbclick = true;
    if (element.nodeName.toLowerCase() === "img") {
      this.core.getCustomEditors().disable();
      const customEditorAttributeName = Configuration.get("imageCustomEditorName");
      if (element.hasAttribute(customEditorAttributeName)) {
        const customEditor = element.getAttribute(customEditorAttributeName);
        this.core.getCustomEditors().enable(customEditor);
      }
      if (Util.containsClass(element, Configuration.get("imageClassName"))) {
        this.core.editionProperties.temporalImage = element;
        this.core.editionProperties.isNewElement = true;
        this.openExistingFormulaEditor();
      }
    }
  }
  /**
   * Handles a mouse up event on the target element. Restores the image size to avoid
   * resizing formulas.
   */
  mouseupHandler() {
    if (this.temporalImageResizing) {
      setTimeout(() => {
        Image.fixAfterResize(this.temporalImageResizing);
      }, 10);
    }
  }
  /**
   * Handles a mouse down event on the target element. Saves the formula size to avoid
   * resizing formulas.
   * @param {HTMLElement} element - target element.
   */
  mousedownHandler(element) {
    if (element.nodeName.toLowerCase() === "img") {
      if (Util.containsClass(element, Configuration.get("imageClassName"))) {
        this.temporalImageResizing = element;
      }
    }
  }
  /**
   * Returns the integration language. By default the browser agent. This method
   * should be overwritten to obtain the integration language, for example using the
   * plugin API of an HTML editor.
   * @returns {string} integration language.
   */
  getLanguage() {
    return this.getBrowserLanguage();
  }
  /**
   * Returns the browser language.
   * @returns {string} the browser language.
   */
  // eslint-disable-next-line class-methods-use-this
  getBrowserLanguage() {
    let language = "en";
    if (navigator.userLanguage) {
      language = navigator.userLanguage.substring(0, 2);
    } else if (navigator.language) {
      language = navigator.language.substring(0, 2);
    } else {
      language = "en";
    }
    return language;
  }
  /**
   * This function is called once the {@link Core} is loaded. IntegrationModel class
   * will fire this method when {@link Core} 'onLoad' event is fired.
   * This method should content all the logic to init
   * the integration.
   */
  callbackFunction() {
    const listener = Listeners.newListener("onTargetReady", () => {
      this.addEvents(this.target);
    });
    this.listeners.add(listener);
  }
  /**
   * Function called when the content submits an action.
   */
  // eslint-disable-next-line class-methods-use-this
  notifyWindowClosed() {
  }
  /**
   * Wrapper.
   * Extracts mathml of a determined text node. This function is used as a wrapper inside core.js
   * in order to get mathml from a text node that can contain normal LaTeX or other chosen text.
   * @param {string} textNode - text node to extract the MathML.
   * @param {int} caretPosition - caret position inside the text node.
   * @returns {string} MathML inside the text node.
   */
  // eslint-disable-next-line class-methods-use-this, no-unused-vars
  getMathmlFromTextNode(textNode, caretPosition) {
  }
  /**
   * Wrapper
   * It fills wrs event object of nonLatex with the desired data.
   * @param {Object} event - event object.
   * @param {Object} window dom window object.
   * @param {string} mathml valid mathml.
   */
  // eslint-disable-next-line class-methods-use-this, no-unused-vars
  fillNonLatexNode(event, window2, mathml) {
  }
  /**
    Wrapper.
   * Returns selected item from the target.
   * @param {HTMLElement} target - target element
   * @param {boolean} iframe
   */
  // eslint-disable-next-line class-methods-use-this, no-unused-vars
  getSelectedItem(target, isIframe) {
  }
  // Set temporal image to null and make focus come back.
  static setActionsOnCancelButtons() {
    const currentInstance2 = WirisPlugin.currentInstance;
    const editorSelection = currentInstance2.getSelection();
    editorSelection.removeAllRanges();
    if (currentInstance2.core.editionProperties.range) {
      const { range } = currentInstance2.core.editionProperties;
      currentInstance2.core.editionProperties.range = null;
      editorSelection.addRange(range);
      if (range.startOffset !== range.endOffset) {
        currentInstance2.core.placeCaretAfterNode(currentInstance2.core.editionProperties.temporalImage);
      }
    }
    if (WirisPlugin.currentInstance) {
      WirisPlugin.currentInstance.core.editionProperties.temporalImage = null;
    }
  }
};
IntegrationModel.prototype.getMathmlFromTextNode = void 0;
IntegrationModel.prototype.fillNonLatexNode = void 0;
IntegrationModel.prototype.getSelectedItem = void 0;
IntegrationModel.integrationParameters = ["serviceProviderProperties", "editorParameters"];

// node_modules/@wiris/mathtype-ckeditor5/src/integration.js
var CKEditor5Integration = class extends IntegrationModel {
  constructor(ckeditorIntegrationModelProperties) {
    const editor = ckeditorIntegrationModelProperties.editorObject;
    if (typeof editor.config !== "undefined" && typeof editor.config.get("mathTypeParameters") !== "undefined") {
      ckeditorIntegrationModelProperties.integrationParameters = editor.config.get("mathTypeParameters");
    }
    super(ckeditorIntegrationModelProperties);
    this.integrationFolderName = "ckeditor_wiris";
  }
  /**
     * @inheritdoc
     * @returns {string} - The CKEditor instance language.
     * @override
     */
  getLanguage() {
    try {
      return this.editorParameters.language;
    } catch (e) {
    }
    const languageObject = this.editorObject.config.get("language");
    if (languageObject != null) {
      if (typeof languageObject === "object") {
        if (languageObject.hasOwnProperty("ui")) {
          return languageObject.ui;
        }
        return languageObject;
      }
      return languageObject;
    }
    return super.getLanguage();
  }
  /**
     * Adds callbacks to the following CKEditor listeners:
     * - 'focus' - updates the current instance.
     * - 'contentDom' - adds 'doubleclick' callback.
     * - 'doubleclick' - sets to null data.dialog property to avoid modifications for MathType formulas.
     * - 'setData' - parses the data converting MathML into images.
     * - 'afterSetData' - adds an observer to MathType formulas to avoid modifications.
     * - 'getData' - parses the data converting images into selected save mode (MathML by default).
     * - 'mode' - recalculates the active element.
     */
  addEditorListeners() {
    const editor = this.editorObject;
    if (typeof editor.config.wirislistenersdisabled === "undefined" || !editor.config.wirislistenersdisabled) {
      this.checkElement();
    }
  }
  /**
     * Checks the current container and assign events in case that it doesn't have them.
     * CKEditor replaces several times the element element during its execution,
     * so we must assign the events again to editor element.
     */
  checkElement() {
    const editor = this.editorObject;
    const newElement = editor.sourceElement;
    if (!newElement.wirisActive) {
      this.setTarget(newElement);
      this.addEvents();
      newElement.wirisActive = true;
    }
  }
  /**
     * @inheritdoc
     * @param {HTMLElement} element - HTMLElement target.
     * @param {MouseEvent} event - event which trigger the handler.
     */
  doubleClickHandler(element, event) {
    this.core.editionProperties.dbclick = true;
    if (this.editorObject.isReadOnly === false) {
      if (element.nodeName.toLowerCase() === "img") {
        if (Util.containsClass(element, Configuration.get("imageClassName"))) {
          if (typeof event.stopPropagation !== "undefined") {
            event.stopPropagation();
          } else {
            event.returnValue = false;
          }
          this.core.getCustomEditors().disable();
          const customEditorAttr = element.getAttribute(Configuration.get("imageCustomEditorName"));
          if (customEditorAttr) {
            this.core.getCustomEditors().enable(customEditorAttr);
          }
          this.core.editionProperties.temporalImage = element;
          this.openExistingFormulaEditor();
        }
      }
    }
  }
  /** @inheritdoc */
  static getCorePath() {
    return null;
  }
  /** @inheritdoc */
  callbackFunction() {
    super.callbackFunction();
    this.addEditorListeners();
  }
  openNewFormulaEditor() {
    this.core.editionProperties.selection = this.editorObject.editing.view.document.selection;
    return super.openNewFormulaEditor();
  }
  /**
     * Replaces old formula with new MathML or inserts it in caret position if new
     * @param {String} mathml MathML to update old one or insert
     * @returns {module:engine/model/element~Element} The model element corresponding to the inserted image
     */
  insertMathml(mathml) {
    return this.editorObject.model.change((writer) => {
      const core = this.getCore();
      const selection = this.editorObject.model.document.selection;
      const modelElementNew = writer.createElement("mathml", {
        formula: mathml,
        ...Object.fromEntries(selection.getAttributes())
        // To keep the format, such as style and font
      });
      if (core.editionProperties.isNewElement) {
        if (!mathml)
          return;
        const viewSelection = this.core.editionProperties.selection || this.editorObject.editing.view.document.selection;
        const modelPosition = this.editorObject.editing.mapper.toModelPosition(viewSelection.getLastPosition());
        this.editorObject.model.insertObject(modelElementNew, modelPosition);
        if (!viewSelection.isCollapsed) {
          for (const range of viewSelection.getRanges()) {
            writer.remove(this.editorObject.editing.mapper.toModelRange(range));
          }
        }
        const position = this.editorObject.model.createPositionAfter(modelElementNew);
        writer.setSelection(position);
      } else {
        const img = core.editionProperties.temporalImage;
        const viewElement = this.editorObject.editing.view.domConverter.domToView(img).parent;
        const modelElementOld = this.editorObject.editing.mapper.toModelElement(viewElement);
        const position = this.editorObject.model.createPositionBefore(modelElementOld);
        if (mathml) {
          this.editorObject.model.insertObject(modelElementNew, position);
        }
        writer.remove(modelElementOld);
      }
      return modelElementNew;
    });
  }
  /**
     * Finds the text node corresponding to given DOM text element.
     * @param {element} viewElement Element to find corresponding text node of.
     * @returns {module:engine/model/text~Text|undefined} Text node corresponding to the given element or undefined if it doesn't exist.
     */
  findText(viewElement) {
    let pivot = viewElement;
    let element;
    while (!element) {
      element = this.editorObject.editing.mapper.toModelElement(
        this.editorObject.editing.view.domConverter.domToView(
          pivot
        )
      );
      pivot = pivot.parentElement;
    }
    const range = this.editorObject.model.createRangeIn(element);
    const descendants = Array.from(range.getItems());
    for (const node of descendants) {
      let viewElementData = viewElement.data;
      if (viewElement.nodeType === 3) {
        viewElementData = viewElementData.replaceAll(String.fromCharCode(8288), "");
      }
      if (node.is("textProxy") && node.data === viewElementData.replace(String.fromCharCode(160), " ")) {
        return node.textNode;
      }
    }
  }
  /** @inheritdoc */
  insertFormula(focusElement, windowTarget, mathml, wirisProperties) {
    var _a;
    const returnObject = {};
    let mathmlOrigin;
    if (!mathml) {
      this.insertMathml("");
    } else if (this.core.editMode === "latex") {
      returnObject.latex = Latex.getLatexFromMathML(mathml);
      returnObject.node = windowTarget.document.createTextNode(`$$${returnObject.latex}$$`);
      this.editorObject.model.change((writer) => {
        var _a2;
        const { latexRange } = this.core.editionProperties;
        const startNode = this.findText(latexRange.startContainer);
        const endNode = this.findText(latexRange.endContainer);
        let startPosition = writer.createPositionAt(startNode.parent, startNode.startOffset + latexRange.startOffset);
        let endPosition = writer.createPositionAt(endNode.parent, endNode.startOffset + latexRange.endOffset);
        let range = writer.createRange(
          startPosition,
          endPosition
        );
        if (latexRange.startContainer.nodeType === 3 && ((_a2 = latexRange.startContainer.previousSibling) == null ? void 0 : _a2.nodeType) === 1) {
          let latexEdited = "$$" + Latex.getLatexFromMathML(MathML.safeXmlDecode(this.core.editionProperties.temporalImage.dataset.mathml)) + "$$";
          let data = latexRange.startContainer.data;
          data = data.replaceAll(String.fromCharCode(8288), "");
          let offset = data.indexOf(latexEdited);
          let dataOffset = data.substring(offset);
          let second$ = dataOffset.substring(2).indexOf("$$") + 4;
          let substring = dataOffset.substr(0, second$);
          data = data.replace(substring, "");
          if (!data) {
            startPosition = writer.createPositionBefore(startNode);
            range = startNode;
          } else {
            startPosition = startPosition = writer.createPositionAt(startNode.parent, startNode.startOffset + offset);
            endPosition = writer.createPositionAt(endNode.parent, endNode.startOffset + second$ + offset);
            range = writer.createRange(
              startPosition,
              endPosition
            );
          }
        }
        writer.remove(range);
        writer.insertText(`$$${returnObject.latex}$$`, startNode.getAttributes(), startPosition);
      });
    } else {
      mathmlOrigin = (_a = this.core.editionProperties.temporalImage) == null ? void 0 : _a.dataset.mathml;
      try {
        returnObject.node = this.editorObject.editing.view.domConverter.viewToDom(
          this.editorObject.editing.mapper.toViewElement(
            this.insertMathml(mathml)
          ),
          windowTarget.document
        );
      } catch (e) {
        const x = e.toString();
        if (x.includes("CKEditorError: Cannot read property 'parent' of undefined")) {
          this.core.modalDialog.cancelAction();
        }
      }
    }
    let payload = {
      mathml_origin: mathmlOrigin ? MathML.safeXmlDecode(mathmlOrigin) : mathmlOrigin,
      mathml: mathml ? MathML.safeXmlDecode(mathml) : mathml,
      elapsed_time: Date.now() - this.core.editionProperties.editionStartTime,
      editor_origin: null,
      // TODO read formula to find out whether it comes from Oxygen Desktop
      toolbar: this.core.modalDialog.contentManager.toolbar,
      size: mathml == null ? void 0 : mathml.length
    };
    Object.keys(payload).forEach((key) => {
      if (key === "mathml_origin" || key === "editor_origin")
        !payload[key] ? delete payload[key] : {};
    });
    try {
      Telemeter2.telemeter.track("INSERTED_FORMULA", {
        ...payload
      });
    } catch (err) {
      console.error(err);
    }
    this.core.editionProperties.temporalImage = null;
    return returnObject;
  }
  /**
     * Function called when the content submits an action.
     */
  notifyWindowClosed() {
    this.editorObject.editing.view.focus();
  }
};

// node_modules/@wiris/mathtype-ckeditor5/src/commands.js
var MathTypeCommand = class extends Command {
  execute(options = {}) {
    if (!options.hasOwnProperty("integration") || !(options.integration instanceof CKEditor5Integration)) {
      throw 'Must pass a valid CKEditor5Integration instance as attribute "integration" of options';
    }
    this.integration = options.integration;
    this.setEditor();
    this.openEditor();
  }
  /**
     * Sets the appropriate custom editor, if any, or disables them.
     */
  setEditor() {
    this.integration.core.getCustomEditors().disable();
  }
  /**
     * Checks whether we are editing an existing formula or a new one and opens the editor.
     */
  openEditor() {
    this.integration.core.editionProperties.dbclick = false;
    const image = this._getSelectedImage();
    if (typeof image !== "undefined" && image !== null && image.classList.contains(WirisPlugin.Configuration.get("imageClassName"))) {
      this.integration.core.editionProperties.temporalImage = image;
      this.integration.openExistingFormulaEditor();
    } else {
      this.integration.openNewFormulaEditor();
    }
  }
  /**
     * Gets the currently selected formula image
     * @returns {Element} selected image, if any, undefined otherwise
     */
  _getSelectedImage() {
    const { selection } = this.editor.editing.view.document;
    if (selection.isCollapsed || selection.rangeCount !== 1) {
      return;
    }
    const range = selection.getFirstRange();
    let image;
    for (const span of range) {
      if (span.item.name !== "span") {
        return;
      }
      image = span.item.getChild(0);
      break;
    }
    if (!image) {
      return;
    }
    return this.editor.editing.view.domConverter.mapViewToDom(image);
  }
};
var ChemTypeCommand = class extends MathTypeCommand {
  setEditor() {
    this.integration.core.getCustomEditors().enable("chemistry");
  }
};

// node_modules/@wiris/mathtype-ckeditor5/src/plugin.js
import mathIcon from "/var/www/html/manorama/node_modules/@wiris/mathtype-ckeditor5/theme/icons/formula.svg";
import chemIcon from "/var/www/html/manorama/node_modules/@wiris/mathtype-ckeditor5/theme/icons/chem.svg";

// node_modules/@wiris/mathtype-ckeditor5/package.json
var package_default = {
  name: "@wiris/mathtype-ckeditor5",
  version: "8.7.1",
  description: "MathType Web for CKEditor5 editor",
  keywords: [
    "chem",
    "chemistry",
    "chemtype",
    "ckeditor",
    "ckeditor5",
    "editor",
    "equation",
    "latex",
    "math",
    "mathml",
    "maths",
    "mathtype",
    "wiris"
  ],
  repository: "https://github.com/wiris/html-integrations/tree/stable/packages/mathtype-ckeditor5",
  homepage: "https://www.wiris.com/",
  bugs: {
    email: "support@wiris.com"
  },
  license: "MIT",
  author: "WIRIS Team (http://www.wiris.com)",
  files: [
    "/src",
    "icons",
    "theme",
    "lang"
  ],
  main: "src/plugin.js",
  scripts: {
    build: "exit 0"
  },
  dependencies: {
    "@ckeditor/ckeditor5-core": ">=23.0.0",
    "@ckeditor/ckeditor5-engine": ">=23.0.0",
    "@ckeditor/ckeditor5-ui": ">=23.0.0",
    "@ckeditor/ckeditor5-widget": ">=23.0.0",
    "@wiris/mathtype-html-integration-devkit": "1.14.1"
  }
};

// node_modules/@wiris/mathtype-ckeditor5/src/plugin.js
var currentInstance = null;
var MathType = class extends Plugin {
  static get requires() {
    return [Widget];
  }
  static get pluginName() {
    return "MathType";
  }
  init() {
    const integration = this._addIntegration();
    currentInstance = integration;
    this._addCommands();
    this._addViews(integration);
    this._addSchema();
    this._addConverters();
    this._exposeWiris();
  }
  /**
   * Inherited from Plugin class: Executed when CKEditor5 is destroyed
   */
  destroy() {
    currentInstance.destroy();
  }
  /**
     * Create the MathType API Integration object
     * @returns {CKEditor5Integration} the integration object
     */
  _addIntegration() {
    const { editor } = this;
    const integrationProperties = {};
    integrationProperties.environment = {};
    integrationProperties.environment.editor = "CKEditor5";
    integrationProperties.environment.editorVersion = "5.x";
    integrationProperties.version = package_default.version;
    integrationProperties.editorObject = editor;
    integrationProperties.serviceProviderProperties = {};
    integrationProperties.serviceProviderProperties.URI = "https://www.wiris.net/demo/plugins/app";
    integrationProperties.serviceProviderProperties.server = "java";
    integrationProperties.target = editor.sourceElement;
    integrationProperties.scriptName = "bundle.js";
    integrationProperties.managesLanguage = true;
    let integration;
    if (integrationProperties.target) {
      integration = new CKEditor5Integration(integrationProperties);
      integration.init();
      integration.listeners.fire("onTargetReady", {});
      integration.checkElement();
      this.listenTo(editor.editing.view.document, "click", (evt, data) => {
        if (data.domEvent.detail === 2) {
          integration.doubleClickHandler(data.domTarget, data.domEvent);
          evt.stop();
        }
      }, { priority: "highest" });
    }
    return integration;
  }
  /**
     * Add the MathType and ChemType commands to the editor
     */
  _addCommands() {
    const { editor } = this;
    editor.commands.add("MathType", new MathTypeCommand(editor));
    editor.commands.add("ChemType", new ChemTypeCommand(editor));
  }
  /**
     * Add the buttons for MathType and ChemType
     * @param {CKEditor5Integration} integration the integration object
     */
  _addViews(integration) {
    const { editor } = this;
    if (Configuration.get("editorEnabled")) {
      editor.ui.componentFactory.add("MathType", (locale) => {
        const view = new ButtonView(locale);
        view.bind("isEnabled").to(editor.commands.get("MathType"), "isEnabled");
        view.set({
          label: StringManager.get("insert_math", editor.config.get("language")),
          icon: mathIcon,
          tooltip: true
        });
        view.on("execute", () => {
          editor.execute("MathType", {
            integration
            // Pass integration as parameter
          });
        });
        return view;
      });
    }
    if (Configuration.get("chemEnabled")) {
      editor.ui.componentFactory.add("ChemType", (locale) => {
        const view = new ButtonView(locale);
        view.bind("isEnabled").to(editor.commands.get("ChemType"), "isEnabled");
        view.set({
          label: StringManager.get("insert_chem", editor.config.get("language")),
          icon: chemIcon,
          tooltip: true
        });
        view.on("execute", () => {
          editor.execute("ChemType", {
            integration
            // Pass integration as parameter
          });
        });
        return view;
      });
    }
    editor.editing.view.addObserver(ClickObserver);
  }
  /**
     * Registers the <mathml> element in the schema
     */
  _addSchema() {
    const { schema } = this.editor.model;
    schema.register("mathml", {
      inheritAllFrom: "$inlineObject",
      allowAttributes: ["formula"]
    });
  }
  /**
     * Add the downcast and upcast converters
     */
  _addConverters() {
    const { editor } = this;
    editor.conversion.for("upcast").elementToElement({
      view: {
        name: "span",
        classes: "ck-math-widget"
      },
      model: (viewElement, { writer: modelWriter }) => {
        const formula = MathML.safeXmlDecode(viewElement.getChild(0).getAttribute("data-mathml"));
        return modelWriter.createElement("mathml", {
          formula
        });
      }
    });
    editor.data.upcastDispatcher.on("element:math", (evt, data, conversionApi) => {
      const { consumable, writer } = conversionApi;
      const { viewItem } = data;
      if (!consumable.test(viewItem, { name: true })) {
        return;
      }
      const isLatex = mathIsLatex(viewItem);
      const processor = new XmlDataProcessor(editor.editing.view.document);
      const upcastWriter = new UpcastWriter(editor.editing.view.document);
      const viewDocumentFragment = upcastWriter.createDocumentFragment(viewItem.getChildren());
      const mathAttributes = [...viewItem.getAttributes()].map(([key, value]) => ` ${key}="${value}"`).join("");
      let formula = processor.toData(viewDocumentFragment) || "";
      formula = Util.htmlSanitize(`<math${mathAttributes}>${formula}</math>`);
      formula = formula.replaceAll('"<"', '"&lt;"').replaceAll('">"', '"&gt;"').replaceAll("><<", ">&lt;<");
      const modelNode = isLatex ? writer.createText(Parser.initParse(formula, editor.config.get("language"))) : writer.createElement("mathml", { formula });
      const splitResult = conversionApi.splitToAllowedParent(modelNode, data.modelCursor);
      if (!splitResult) {
        return;
      }
      conversionApi.writer.insert(modelNode, splitResult.position);
      consumable.consume(viewItem, { name: true });
      const parts = conversionApi.getSplitParts(modelNode);
      data.modelRange = writer.createRange(
        conversionApi.writer.createPositionBefore(modelNode),
        conversionApi.writer.createPositionAfter(parts[parts.length - 1])
      );
      if (splitResult.cursorParent) {
        data.modelCursor = conversionApi.writer.createPositionAt(splitResult.cursorParent, 0);
      } else {
        data.modelCursor = data.modelRange.end;
      }
    });
    function mathIsLatex(math) {
      const semantics = math.getChild(0);
      if (!semantics || semantics.name !== "semantics")
        return false;
      for (const child of semantics.getChildren()) {
        if (child.name === "annotation" && child.getAttribute("encoding") === "LaTeX") {
          return true;
        }
      }
      return false;
    }
    function createViewWidget(modelItem, { writer: viewWriter }) {
      const widgetElement = viewWriter.createContainerElement("span", {
        class: "ck-math-widget"
      });
      const mathUIElement = createViewImage(modelItem, { writer: viewWriter });
      if (mathUIElement) {
        viewWriter.insert(viewWriter.createPositionAt(widgetElement, 0), mathUIElement);
      }
      return toWidget(widgetElement, viewWriter);
    }
    function createViewImage(modelItem, { writer: viewWriter }) {
      const htmlDataProcessor = new HtmlDataProcessor(viewWriter.document);
      const mathString = modelItem.getAttribute("formula").replaceAll('ref="<"', 'ref="&lt;"');
      const imgHtml = Parser.initParse(mathString, editor.config.get("language"));
      const imgElement = htmlDataProcessor.toView(imgHtml).getChild(0);
      if (imgElement) {
        return viewWriter.createEmptyElement("img", imgElement.getAttributes(), {
          renderUnsafeAttributes: ["src"]
        });
      }
      return null;
    }
    editor.conversion.for("editingDowncast").elementToElement({
      model: "mathml",
      view: createViewWidget
    });
    editor.conversion.for("dataDowncast").elementToElement({
      model: "mathml",
      view: createDataString
      // eslint-disable-line no-use-before-define
    });
    function clone3(viewWriter, sourceNode) {
      if (sourceNode.is("text")) {
        return viewWriter.createText(sourceNode.data);
      }
      if (sourceNode.is("element")) {
        if (sourceNode.is("emptyElement")) {
          return viewWriter.createEmptyElement(sourceNode.name, sourceNode.getAttributes());
        }
        const element = viewWriter.createContainerElement(sourceNode.name, sourceNode.getAttributes());
        for (const child of sourceNode.getChildren()) {
          viewWriter.insert(viewWriter.createPositionAt(element, "end"), clone3(viewWriter, child));
        }
        return element;
      }
      throw new Exception("Given node has unsupported type.");
    }
    function createDataString(modelItem, { writer: viewWriter }) {
      const htmlDataProcessor = new HtmlDataProcessor(viewWriter.document);
      let mathString = Parser.endParseSaveMode(modelItem.getAttribute("formula"));
      const sourceMathElement = htmlDataProcessor.toView(mathString).getChild(0);
      return clone3(viewWriter, sourceMathElement);
    }
    editor.editing.mapper.on(
      "viewToModelPosition",
      viewToModelPositionOutsideModelElement(editor.model, (viewElement) => viewElement.hasClass("ck-math-widget"))
    );
    const { get, set } = editor.data;
    editor.data.get = (options) => {
      let output = get.bind(editor.data)(options);
      output = output.replaceAll('"<"', '"&lt;"').replaceAll('">"', '"&gt;"').replaceAll("><<", ">&lt;<");
      let imageFormula = Parser.initParse(output);
      return Parser.endParse(imageFormula);
    };
    editor.data.set = (data) => {
      let modifiedData = data;
      const regexp = /<math(.*?)<\/math>/gm;
      let formulas = [...data.matchAll(regexp)];
      formulas.forEach((formula) => {
        let mathml = formula[0];
        if (mathml.includes('encoding="LaTeX"')) {
          let latex = "$$$" + Latex.getLatexFromMathML(mathml) + "$$$";
          modifiedData = modifiedData.replace(mathml, latex);
        }
      });
      set.bind(editor.data)(modifiedData);
    };
  }
  /**
     * Expose the WirisPlugin variable to the window
     */
  // eslint-disable-next-line class-methods-use-this
  _exposeWiris() {
    window.WirisPlugin = {
      Core,
      Parser,
      Image,
      MathML,
      Util,
      Configuration,
      Listeners,
      IntegrationModel,
      currentInstance,
      Latex
    };
  }
};
export {
  currentInstance,
  MathType as default
};
/*! Bundled license information:

@ckeditor/ckeditor5-utils/src/env.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/fastdiff.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/diff.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/difftochanges.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/mix.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/spy.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/eventinfo.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/uid.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/priorities.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/inserttopriorityarray.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/ckeditorerror.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/version.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/version.js:
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-utils/src/emittermixin.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-utils/src/observablemixin.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/elementreplacer.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/abortabledebounce.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/count.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/comparearrays.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/isiterable.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/createelement.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/config.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/isnode.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/iswindow.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/emittermixin.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/global.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-utils/src/dom/findclosestscrollableancestor.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/getancestors.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/getdatafromelement.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/getborderwidths.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/istext.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/isrange.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/getpositionedancestor.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/rect.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/resizeobserver.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/setdatainelement.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/tounit.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/indexof.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/insertat.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/iscomment.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/isvalidattributename.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/isvisible.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/position.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/remove.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/scroll.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/keyboard.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/language.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/toarray.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/translation-service.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore else -- @preserve *)

@ckeditor/ckeditor5-utils/src/locale.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/collection.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/first.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/focustracker.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/keystrokehandler.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/objecttomap.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/tomap.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/wait.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/retry.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/splicearray.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/delay.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/verifylicense.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/unicode.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/viewcollection.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/template.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/view.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/icon/iconview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/button/buttonlabelview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/button/buttonview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/observer/observer.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/observer/domeventdata.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/observer/domeventobserver.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/observer/clickobserver.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/dataprocessor/basichtmlwriter.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/typecheckable.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/node.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/text.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/textproxy.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/matcher.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/stylesmap.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/element.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/uielement.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/containerelement.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/editableelement.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/treewalker.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/position.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/range.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/documentselection.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/selection.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/documentfragment.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/filler.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/domconverter.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/dataprocessor/htmldataprocessor.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/dataprocessor/xmldataprocessor.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/upcastwriter.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

dompurify/dist/purify.es.js:
  (*! @license DOMPurify 2.4.7 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.7/LICENSE *)

@wiris/mathtype-html-integration-devkit/src/polyfills.js:
  (*! http://mths.be/codepointat v0.1.0 by @mathias *)
*/
//# sourceMappingURL=@wiris_mathtype-ckeditor5.js.map
